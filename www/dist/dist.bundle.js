(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&false)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Scalar = _dereq_('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":4}],2:[function(_dereq_,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],3:[function(_dereq_,module,exports){
var Line = _dereq_("./Line")
,   Point = _dereq_("./Point")
,   Scalar = _dereq_("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(_dereq_,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],5:[function(_dereq_,module,exports){
module.exports = {
    Polygon : _dereq_("./Polygon"),
    Point : _dereq_("./Point"),
};

},{"./Point":2,"./Polygon":3}],6:[function(_dereq_,module,exports){
module.exports={
  "name": "p2",
  "version": "0.7.1",
  "description": "A JavaScript 2D physics engine.",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-nodeunit": "^0.4.1",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.1"
  }
}

},{}],7:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points, transformed by the given position and angle.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 * @param {Array} position
 * @param {number} angle
 * @param {number} skinSize Some margin to be added to the AABB.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

/**
 * @method containsPoint
 * @param  {Array} point
 * @return {boolean}
 */
AABB.prototype.containsPoint = function(point){
    var l = this.lowerBound,
        u = this.upperBound;
    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
};

/**
 * Check if the AABB is hit by a ray.
 * @method overlapsRay
 * @param  {Ray} ray
 * @return {number} -1 if no hit, a number between 0 and 1 if hit.
 */
AABB.prototype.overlapsRay = function(ray){
    var t = 0;

    // ray.direction is unit direction vector of ray
    var dirFracX = 1 / ray.direction[0];
    var dirFracY = 1 / ray.direction[1];

    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
    var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;
    var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;
    var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;
    var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;

    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
    if (tmax < 0){
        //t = tmax;
        return -1;
    }

    // if tmin > tmax, ray doesn't intersect AABB
    if (tmin > tmax){
        //t = tmax;
        return -1;
    }

    return tmin;
};
},{"../math/vec2":30,"../utils/Utils":57}],8:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Body = _dereq_('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in.
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){
    var KINEMATIC = Body.KINEMATIC;
    var STATIC = Body.STATIC;

    // Cannot collide static bodies
    if(bodyA.type === STATIC && bodyB.type === STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === KINEMATIC && bodyB.type === STATIC) ||
        (bodyA.type === STATIC    && bodyB.type === KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === KINEMATIC && bodyB.type === KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":30,"../objects/Body":31}],9:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle'),
    Plane = _dereq_('../shapes/Plane'),
    Shape = _dereq_('../shapes/Shape'),
    Particle = _dereq_('../shapes/Particle'),
    Broadphase = _dereq_('../collision/Broadphase'),
    vec2 = _dereq_('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../math/vec2":30,"../shapes/Circle":39,"../shapes/Particle":43,"../shapes/Plane":44,"../shapes/Shape":45}],10:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = _dereq_('../utils/Utils')
,   ContactEquationPool = _dereq_('../utils/ContactEquationPool')
,   FrictionEquationPool = _dereq_('../utils/FrictionEquationPool')
,   TupleDictionary = _dereq_('../utils/TupleDictionary')
,   Equation = _dereq_('../equations/Equation')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   FrictionEquation = _dereq_('../equations/FrictionEquation')
,   Circle = _dereq_('../shapes/Circle')
,   Convex = _dereq_('../shapes/Convex')
,   Shape = _dereq_('../shapes/Shape')
,   Body = _dereq_('../objects/Body')
,   Box = _dereq_('../shapes/Box');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    /**
     * Keeps track of the allocated ContactEquations.
     * @property {ContactEquationPool} contactEquationPool
     *
     * @example
     *
     *     // Allocate a few equations before starting the simulation.
     *     // This way, no contact objects need to be created on the fly in the game loop.
     *     world.narrowphase.contactEquationPool.resize(1024);
     *     world.narrowphase.frictionEquationPool.resize(1024);
     */
    this.contactEquationPool = new ContactEquationPool({ size: 32 });

    /**
     * Keeps track of the allocated ContactEquations.
     * @property {FrictionEquationPool} frictionEquationPool
     */
    this.frictionEquationPool = new FrictionEquationPool({ size: 64 });

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 * @todo shape world transforms are wrong
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k];

        bodyA.toWorldFrame(shapePositionA, shapeA.position);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l];

            bodyB.toWorldFrame(shapePositionB, shapeB.position);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    var ce = this.contactEquations,
        fe = this.frictionEquations;
    for(var i=0; i<ce.length; i++){
        this.contactEquationPool.release(ce[i]);
    }
    for(var i=0; i<fe.length; i++){
        this.frictionEquationPool.release(fe[i]);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.contactEquationPool.get();
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.frictionEquationPool.get();
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/box narrowphase
 * @method lineBox
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       boxBody
 * @param  {Box}  boxShape
 * @param  {Array}      boxOffset
 * @param  {Number}     boxAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.BOX] =
Narrowphase.prototype.lineBox = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    boxBody,
    boxShape,
    boxOffset,
    boxAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Box({ width: 1, height: 1 }),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.BOX] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center boxs
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.BOX] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle({ radius: 1 }),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =
Narrowphase.prototype[Shape.BOX] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Box && c2 instanceof Box){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.heights,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex({ vertices: [vec2.create(),vec2.create(),vec2.create(),vec2.create()] });
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.heights,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":21,"../equations/Equation":22,"../equations/FrictionEquation":23,"../math/vec2":30,"../objects/Body":31,"../shapes/Box":37,"../shapes/Circle":39,"../shapes/Convex":40,"../shapes/Shape":45,"../utils/ContactEquationPool":48,"../utils/FrictionEquationPool":49,"../utils/TupleDictionary":56,"../utils/Utils":57}],11:[function(_dereq_,module,exports){
module.exports = Ray;

var vec2 = _dereq_('../math/vec2');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
 * @class Ray
 * @constructor
 * @param {object} [options]
 * @param {array} [options.from]
 * @param {array} [options.to]
 * @param {boolean} [options.checkCollisionResponse=true]
 * @param {boolean} [options.skipBackfaces=false]
 * @param {number} [options.collisionMask=-1]
 * @param {number} [options.collisionGroup=-1]
 * @param {number} [options.mode=Ray.ANY]
 * @param {number} [options.callback]
 */
function Ray(options){
    options = options || {};

    /**
     * Ray start point.
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * Ray end point
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = !!options.skipBackfaces;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;

    /**
     * The intersection mode. Should be {{#crossLink "Ray/ANY:property"}}Ray.ANY{{/crossLink}}, {{#crossLink "Ray/ALL:property"}}Ray.ALL{{/crossLink}} or {{#crossLink "Ray/CLOSEST:property"}}Ray.CLOSEST{{/crossLink}}.
     * @property {number} mode
     */
    this.mode = options.mode !== undefined ? options.mode : Ray.ANY;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = options.callback || function(result){};

    /**
     * @readOnly
     * @property {array} direction
     */
    this.direction = vec2.create();

    /**
     * Length of the ray
     * @readOnly
     * @property {number} length
     */
    this.length = 1;

    this.update();
}
Ray.prototype.constructor = Ray;

/**
 * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
 * @static
 * @property {Number} CLOSEST
 */
Ray.CLOSEST = 1;

/**
 * This raycasting mode will make the Ray stop when it finds the first intersection point.
 * @static
 * @property {Number} ANY
 */
Ray.ANY = 2;

/**
 * This raycasting mode will traverse all intersection points and executes a callback for each one.
 * @static
 * @property {Number} ALL
 */
Ray.ALL = 4;

/**
 * Should be called if you change the from or to point.
 * @method update
 */
Ray.prototype.update = function(){

    // Update .direction and .length
    var d = this.direction;
    vec2.sub(d, this.to, this.from);
    this.length = vec2.length(d);
    vec2.normalize(d, d);

};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 */
Ray.prototype.intersectBodies = function (result, bodies) {
    for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
        var body = bodies[i];
        var aabb = body.getAABB();
        if(aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)){
            this.intersectBody(result, body);
        }
    }
};

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 */
Ray.prototype.intersectBody = function (result, body) {
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        if((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0){
            continue;
        }

        // Get world angle and position of the shape
        vec2.rotate(worldPosition, shape.position, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = shape.angle + body.angle;

        this.intersectShape(
            result,
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(result.shouldStop(this)){
            break;
        }
    }
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(result, shape, angle, position, body){
    var from = this.from;

    // Checking radius
    var distance = distanceFromIntersectionSquared(from, this.direction, position);
    if (distance > shape.boundingRadius * shape.boundingRadius) {
        return;
    }

    this._currentBody = body;
    this._currentShape = shape;

    shape.raycast(result, this, position, angle);

    this._currentBody = this._currentShape = null;
};

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    vec2.set(
        result.lowerBound,
        Math.min(to[0], from[0]),
        Math.min(to[1], from[1])
    );
    vec2.set(
        result.upperBound,
        Math.max(to[0], from[0]),
        Math.max(to[1], from[1])
    );
};

var hitPointWorld = vec2.create();

/**
 * @method reportIntersection
 * @private
 * @param  {number} fraction
 * @param  {array} normal
 * @param  {number} [faceIndex=-1]
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(result, fraction, normal, faceIndex){
    var from = this.from;
    var to = this.to;
    var shape = this._currentShape;
    var body = this._currentBody;

    // Skip back faces?
    if(this.skipBackfaces && vec2.dot(normal, this.direction) > 0){
        return;
    }

    switch(this.mode){

    case Ray.ALL:
        result.set(
            normal,
            shape,
            body,
            fraction,
            faceIndex
        );
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(fraction < result.fraction || !result.hasHit()){
            result.set(
                normal,
                shape,
                body,
                fraction,
                faceIndex
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        result.set(
            normal,
            shape,
            body,
            fraction,
            faceIndex
        );
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersectionSquared(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from);
    var dot = vec2.dot(v0, direction);

    // intersect = direction * dot + from
    vec2.scale(intersect, direction, dot);
    vec2.add(intersect, intersect, from);

    return vec2.squaredDistance(position, intersect);
}


},{"../collision/AABB":7,"../collision/RaycastResult":12,"../math/vec2":30,"../shapes/Shape":45}],12:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Ray = _dereq_('../collision/Ray');

module.exports = RaycastResult;

/**
 * Storage for Ray casting hit data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * The normal of the hit, oriented in world space.
	 * @property {array} normal
	 */
	this.normal = vec2.create();

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was indexable.
	 * @property {number} faceIndex
	 * @default -1
	 */
	this.faceIndex = -1;

	/**
	 * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
	 * @property {number} fraction
	 * @default -1
	 */
	this.fraction = -1;

	/**
	 * If the ray should stop traversing.
	 * @readonly
	 * @property {Boolean} isStopped
	 */
	this.isStopped = false;
}

/**
 * Reset all result data. Must be done before re-using the result object.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.normal, 0, 0);
	this.shape = null;
	this.body = null;
	this.faceIndex = -1;
	this.fraction = -1;
	this.isStopped = false;
};

/**
 * Get the distance to the hit point.
 * @method getHitDistance
 * @param {Ray} ray
 */
RaycastResult.prototype.getHitDistance = function (ray) {
	return vec2.distance(ray.from, ray.to) * this.fraction;
};

/**
 * Returns true if the ray hit something since the last reset().
 * @method hasHit
 */
RaycastResult.prototype.hasHit = function () {
	return this.fraction !== -1;
};

/**
 * Get world hit point.
 * @method getHitPoint
 * @param {array} out
 * @param {Ray} ray
 */
RaycastResult.prototype.getHitPoint = function (out, ray) {
	vec2.lerp(out, ray.from, ray.to, this.fraction);
};

/**
 * Can be called while iterating over hits to stop searching for hit points.
 * @method stop
 */
RaycastResult.prototype.stop = function(){
	this.isStopped = true;
};

/**
 * @method shouldStop
 * @private
 * @param {Ray} ray
 * @return {boolean}
 */
RaycastResult.prototype.shouldStop = function(ray){
	return this.isStopped || (this.fraction !== -1 && ray.mode === Ray.ANY);
};

/**
 * @method set
 * @private
 * @param {array} normal
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} fraction
 */
RaycastResult.prototype.set = function(
	normal,
	shape,
	body,
	fraction,
	faceIndex
){
	vec2.copy(this.normal, normal);
	this.shape = shape;
	this.body = body;
	this.fraction = fraction;
	this.faceIndex = faceIndex;
};
},{"../collision/Ray":11,"../math/vec2":30}],13:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../utils/Utils":57}],14:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":57}],15:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 *
 * @example
 *     // Manually set the distance and anchors
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 *     world.addConstraint(constraint);
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points:
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} maxForce
 */
DistanceConstraint.prototype.setMaxForce = function(maxForce){
    var normal = this.equations[0];
    normal.minForce = -maxForce;
    normal.maxForce =  maxForce;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":22,"../math/vec2":30,"../utils/Utils":57,"./Constraint":14}],16:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   AngleLockEquation = _dereq_('../equations/AngleLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = GearConstraint;

/**
 * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 *
 * @example
 *     var constraint = new GearConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 *
 * @example
 *     var constraint = new GearConstraint(bodyA, bodyB, {
 *         ratio: 2,
 *         maxTorque: 1000
 *     });
 *     world.addConstraint(constraint);
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = options.ratio !== undefined ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(options.maxTorque !== undefined){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":20,"../equations/Equation":22,"../math/vec2":30,"./Constraint":14}],17:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position and rotation between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 *
 * @example
 *     // Locks the relative position and rotation between bodyA and bodyB
 *     var constraint = new LockConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":22,"../math/vec2":30,"./Constraint":14}],18:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":21,"../equations/Equation":22,"../equations/RotationalLockEquation":24,"../math/vec2":30,"./Constraint":14}],19:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":22,"../equations/RotationalLockEquation":24,"../equations/RotationalVelocityEquation":25,"../math/vec2":30,"./Constraint":14}],20:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":30,"./Equation":22}],21:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

var vi = vec2.create();
var vj = vec2.create();
var relVel = vec2.create();

/**
 * Get the relative velocity along the normal vector.
 * @return {number}
 */
ContactEquation.prototype.getVelocityAlongNormal = function(){

    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);

    vec2.subtract(relVel, vi, vj);

    return vec2.dot(this.normalA, relVel);
};
},{"../math/vec2":30,"./Equation":22}],22:[function(_dereq_,module,exports){
module.exports = Equation;

var vec2 = _dereq_('../math/vec2'),
    Utils = _dereq_('../utils/Utils'),
    Body = _dereq_('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi, invMassi);
    vec2.multiply(iMfi, bi.massMultiplier, iMfi);
    vec2.scale(iMfj, fj,invMassj);
    vec2.multiply(iMfj, bj.massMultiplier, iMfj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi * bi.massMultiplier[0] +
            G[1] * G[1] * invMassi * bi.massMultiplier[1] +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj * bj.massMultiplier[0] +
            G[4] * G[4] * invMassj * bj.massMultiplier[1] +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.multiply(temp, temp, bi.massMultiplier);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.multiply(temp, temp, bj.massMultiplier);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":30,"../objects/Body":31,"../utils/Utils":57}],23:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('./Equation')
,   Utils = _dereq_('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":30,"../utils/Utils":57,"./Equation":22}],24:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":30,"./Equation":22}],25:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":30,"./Equation":22}],26:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],27:[function(_dereq_,module,exports){
var Material = _dereq_('./Material');
var Equation = _dereq_('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.
     * @property friction
     * @type {Number}
     * @default 0.3
     */
    this.friction = typeof(options.friction) !== "undefined" ? Number(options.friction) : 0.3;

    /**
     * Restitution, or "bounciness" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.
     * @property restitution
     * @type {Number}
     * @default 0
     */
    this.restitution = typeof(options.restitution) !== "undefined" ? Number(options.restitution) : 0;

    /**
     * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = typeof(options.stiffness) !== "undefined" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = typeof(options.relaxation) !== "undefined" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = typeof(options.frictionStiffness) !== "undefined" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = typeof(options.frictionRelaxation) !== "undefined" ? Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     * @default 0
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity) !== "undefined" ? Number(options.surfaceVelocity) : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":22,"./Material":28}],28:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],29:[function(_dereq_,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],30:[function(_dereq_,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = _dereq_('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Transform a vector to local frame.
 * @method vectorToLocalFrame
 * @param  {Array} out
 * @param  {Array} worldVector
 * @param  {Number} frameAngle
 */
vec2.vectorToLocalFrame = function(out, worldVector, frameAngle){
    vec2.rotate(out, worldVector, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localVector
 * @param  {Number} frameAngle
 */
vec2.vectorToGlobalFrame = function(out, localVector, frameAngle){
    vec2.rotate(out, localVector, frameAngle);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Linearly interpolate/mix two vectors.
 * @static
 * @method lerp
 * @param {Array} out
 * @param {Array} a First vector
 * @param {Array} b Second vector
 * @param {number} t Lerp factor
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Reflect a vector along a normal.
 * @static
 * @method reflect
 * @param {Array} out
 * @param {Array} vector
 * @param {Array} normal
 */
vec2.reflect = function(out, vector, normal){
    var dot = vector[0] * normal[0] + vector[1] * normal[1];
    out[0] = vector[0] - 2 * normal[0] * dot;
    out[1] = vector[1] - 2 * normal[1] * dot;
};

/**
 * Get the intersection point between two line segments.
 * @static
 * @method getLineSegmentsIntersection
 * @param  {Array} out
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @return {boolean} True if there was an intersection, otherwise false.
 */
vec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {
    var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
    if(t < 0){
        return false;
    } else {
        out[0] = p0[0] + (t * (p1[0] - p0[0]));
        out[1] = p0[1] + (t * (p1[1] - p0[1]));
        return true;
    }
};

/**
 * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
 * @static
 * @method getLineSegmentsIntersectionFraction
 * @param  {Array} p0
 * @param  {Array} p1
 * @param  {Array} p2
 * @param  {Array} p3
 * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
 */
vec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {
    var s1_x = p1[0] - p0[0];
    var s1_y = p1[1] - p0[1];
    var s2_x = p3[0] - p2[0];
    var s2_y = p3[1] - p2[1];

    var s, t;
    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
        return t;
    }
    return -1; // No collision
};

},{"../utils/Utils":57}],31:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   decomp = _dereq_('poly-decomp')
,   Convex = _dereq_('../shapes/Convex')
,   RaycastResult = _dereq_('../collision/RaycastResult')
,   Ray = _dereq_('../collision/Ray')
,   AABB = _dereq_('../collision/AABB')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Array} [options.force]
 * @param {Array} [options.position]
 * @param {Array} [options.velocity]
 * @param {Boolean} [options.allowSleep]
 * @param {Boolean} [options.collisionResponse]
 * @param {Number} [options.angle=0]
 * @param {Number} [options.angularForce=0]
 * @param {Number} [options.angularVelocity=0]
 * @param {Number} [options.ccdIterations=10]
 * @param {Number} [options.ccdSpeedThreshold=-1]
 * @param {Number} [options.fixedRotation=false]
 * @param {Number} [options.gravityScale]
 * @param {Number} [options.id]
 * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Number} [options.sleepSpeedLimit]
 * @param {Number} [options.sleepTimeLimit]
 * @param {Object} [options]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle({ radius: 1 }));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = options.id || ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body.
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
     * @property {Boolean} fixedX
     */
    this.fixedX = !!options.fixedX;

    /**
     * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X.
     * @property {Boolean} fixedY
     */
    this.fixedY = !!options.fixedY;

    /**
     * @private
     * @property {array} massMultiplier
     */
    this.massMultiplier = vec2.create();

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body. Use this for rendering.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body. Use this for rendering.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The current velocity of the body.
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

/**
 * @private
 * @method updateSolveMassProperties
 */
Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 * @param {number} density
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 * @return {AABB} The AABB instance (this.aabb)
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shape.angle + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shape.position, bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shape.position),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle({ radius: 1 });
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape, offset, angle){
    if(shape.body){
        throw new Error('A shape can only be added to one body.');
    }
    shape.body = this;

    // Copy the offset vector
    if(offset){
        vec2.copy(shape.position, offset);
    } else {
        vec2.set(shape.position, 0, 0);
    }

    shape.angle = angle || 0;

    this.shapes.push(shape);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape} shape
 * @return {Boolean} True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.aabbNeedsUpdate = true;
        shape.body = null;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(shape.position),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1 / this.mass;

        vec2.set(
            this.massMultiplier,
            this.fixedX ? 0 : 1,
            this.fixedY ? 0 : 1
        );
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a point relative to the center of mass of the body. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce. If relativePoint is zero, the force will be applied directly on the center of mass, and the torque produced will be zero.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} [relativePoint] A world point to apply the force on.
 */
Body.prototype.applyForce = function(force, relativePoint){

    // Add linear force
    vec2.add(this.force, this.force, force);

    if(relativePoint){

        // Compute produced rotational force
        var rotForce = vec2.crossLength(relativePoint,force);

        // Add rotational force
        this.angularForce += rotForce;
    }
};

/**
 * Apply force to a body-local point.
 * @method applyForceLocal
 * @param  {Array} localForce The force vector to add, oriented in local body space.
 * @param  {Array} [localPoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */
var Body_applyForce_forceWorld = vec2.create();
var Body_applyForce_pointWorld = vec2.create();
var Body_applyForce_pointLocal = vec2.create();
Body.prototype.applyForceLocal = function(localForce, localPoint){
    localPoint = localPoint || Body_applyForce_pointLocal;
    var worldForce = Body_applyForce_forceWorld;
    var worldPoint = Body_applyForce_pointWorld;
    this.vectorToWorldFrame(worldForce, localForce);
    this.vectorToWorldFrame(worldPoint, localPoint);
    this.applyForce(worldForce, worldPoint);
};

/**
 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Array} impulse The impulse vector to add, oriented in world space.
 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */
var Body_applyImpulse_velo = vec2.create();
Body.prototype.applyImpulse = function(impulseVector, relativePoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute produced central impulse velocity
    var velo = Body_applyImpulse_velo;
    vec2.scale(velo, impulseVector, this.invMass);
    vec2.multiply(velo, this.massMultiplier, velo);

    // Add linear impulse
    vec2.add(this.velocity, velo, this.velocity);

    if(relativePoint){
        // Compute produced rotational impulse velocity
        var rotVelo = vec2.crossLength(relativePoint, impulseVector);
        rotVelo *= this.invInertia;

        // Add rotational Impulse
        this.angularVelocity += rotVelo;
    }
};

/**
 * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulseLocal
 * @param  {Array} impulse The impulse vector to add, oriented in world space.
 * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.
 */
var Body_applyImpulse_impulseWorld = vec2.create();
var Body_applyImpulse_pointWorld = vec2.create();
var Body_applyImpulse_pointLocal = vec2.create();
Body.prototype.applyImpulseLocal = function(localImpulse, localPoint){
    localPoint = localPoint || Body_applyImpulse_pointLocal;
    var worldImpulse = Body_applyImpulse_impulseWorld;
    var worldPoint = Body_applyImpulse_pointWorld;
    this.vectorToWorldFrame(worldImpulse, localImpulse);
    this.vectorToWorldFrame(worldPoint, localPoint);
    this.applyImpulse(worldImpulse, worldPoint);
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world point
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local point
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Transform a world point to local body frame.
 * @method vectorToLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldVector  The input world vector
 */
Body.prototype.vectorToLocalFrame = function(out, worldVector){
    vec2.vectorToLocalFrame(out, worldVector, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method vectorToWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localVector  The input local vector
 */
Body.prototype.vectorToWorldFrame = function(out, localVector){
    vec2.vectorToGlobalFrame(out, localVector, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex({ vertices: convexes[i].vertices });

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i];
        vec2.scale(offset_times_area, s.position, s.area);
        vec2.add(sum, sum, offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i];
        vec2.sub(s.position, s.position, cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var result = new RaycastResult();
var ray = new Ray({
    mode: Ray.ALL
});
var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    result.reset();
    ray.callback = function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        result.getHitPoint(end, ray);
        vec2.sub(startToEnd, end, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.stop();
    };
    vec2.copy(ray.from, this.position);
    vec2.copy(ray.to, end);
    ray.update();
    this.world.raycast(result, ray);

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * Get velocity of a point in the body.
 * @method getVelocityAtPoint
 * @param  {Array} result A vector to store the result in
 * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
 * @return {Array} The result vector
 */
Body.prototype.getVelocityAtPoint = function(result, relativePoint){
    vec2.crossVZ(result, relativePoint, this.angularVelocity);
    vec2.subtract(result, this.velocity, result);
    return result;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":7,"../collision/Ray":11,"../collision/RaycastResult":12,"../events/EventEmitter":26,"../math/vec2":30,"../shapes/Convex":40,"poly-decomp":5}],32:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');
var Utils = _dereq_('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":30,"../utils/Utils":57,"./Spring":34}],33:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":30,"./Spring":34}],34:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":30,"../utils/Utils":57}],35:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');
var Constraint = _dereq_('../constraints/Constraint');
var FrictionEquation = _dereq_('../equations/FrictionEquation');
var Body = _dereq_('../objects/Body');

module.exports = TopDownVehicle;

/**
 * @class TopDownVehicle
 * @constructor
 * @param {Body} chassisBody A dynamic body, already added to the world.
 * @param {Object} [options]
 *
 * @example
 *
 *     // Create a dynamic body for the chassis
 *     var chassisBody = new Body({
 *         mass: 1
 *     });
 *     var boxShape = new Box({ width: 0.5, height: 1 });
 *     chassisBody.addShape(boxShape);
 *     world.addBody(chassisBody);
 *
 *     // Create the vehicle
 *     var vehicle = new TopDownVehicle(chassisBody);
 *
 *     // Add one front wheel and one back wheel - we don't actually need four :)
 *     var frontWheel = vehicle.addWheel({
 *         localPosition: [0, 0.5] // front
 *     });
 *     frontWheel.setSideFriction(4);
 *
 *     // Back wheel
 *     var backWheel = vehicle.addWheel({
 *         localPosition: [0, -0.5] // back
 *     });
 *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
 *     vehicle.addToWorld(world);
 *
 *     // Steer value zero means straight forward. Positive is left and negative right.
 *     frontWheel.steerValue = Math.PI / 16;
 *
 *     // Engine force forward
 *     backWheel.engineForce = 10;
 *     backWheel.setBrakeForce(0);
 */
function TopDownVehicle(chassisBody, options){
    options = options || {};

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = chassisBody;

    /**
     * @property {Array} wheels
     */
    this.wheels = [];

    // A dummy body to constrain the chassis to
    this.groundBody = new Body({ mass: 0 });

    this.world = null;

    var that = this;
    this.preStepCallback = function(){
        that.update();
    };
}

/**
 * @method addToWorld
 * @param {World} world
 */
TopDownVehicle.prototype.addToWorld = function(world){
    this.world = world;
    world.addBody(this.groundBody);
    world.on('preStep', this.preStepCallback);
    for (var i = 0; i < this.wheels.length; i++) {
        var wheel = this.wheels[i];
        world.addConstraint(wheel);
    }
};

/**
 * @method removeFromWorld
 * @param {World} world
 */
TopDownVehicle.prototype.removeFromWorld = function(){
    var world = this.world;
    world.removeBody(this.groundBody);
    world.off('preStep', this.preStepCallback);
    for (var i = 0; i < this.wheels.length; i++) {
        var wheel = this.wheels[i];
        world.removeConstraint(wheel);
    }
    this.world = null;
};

/**
 * @method addWheel
 * @param {object} [wheelOptions]
 * @return {WheelConstraint}
 */
TopDownVehicle.prototype.addWheel = function(wheelOptions){
    var wheel = new WheelConstraint(this,wheelOptions);
    this.wheels.push(wheel);
    return wheel;
};

/**
 * @method update
 */
TopDownVehicle.prototype.update = function(){
    for (var i = 0; i < this.wheels.length; i++) {
        this.wheels[i].update();
    }
};

/**
 * @class WheelConstraint
 * @constructor
 * @extends {Constraint}
 * @param {Vehicle} vehicle
 * @param {object} [options]
 * @param {Array} [options.localForwardVector]The local wheel forward vector in local body space. Default is zero.
 * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
 * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
 */
function WheelConstraint(vehicle, options){
    options = options || {};

    this.vehicle = vehicle;

    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);

    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);

    /**
     * @property {number} steerValue
     */
    this.steerValue = 0;

    /**
     * @property {number} engineForce
     */
    this.engineForce = 0;

    this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);

    /**
     * @property {Array} localForwardVector
     */
    this.localForwardVector = vec2.fromValues(0, 1);
    if(options.localForwardVector){
        vec2.copy(this.localForwardVector, options.localForwardVector);
    }

    /**
     * @property {Array} localPosition
     */
    this.localPosition = vec2.fromValues(0, 0);
    if(options.localPosition){
        vec2.copy(this.localPosition, options.localPosition);
    }

    Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);

    this.equations.push(
        this.forwardEquation,
        this.sideEquation
    );

    this.setBrakeForce(0);
}
WheelConstraint.prototype = new Constraint();

/**
 * @method setForwardFriction
 */
WheelConstraint.prototype.setBrakeForce = function(force){
    this.forwardEquation.setSlipForce(force);
};

/**
 * @method setSideFriction
 */
WheelConstraint.prototype.setSideFriction = function(force){
    this.sideEquation.setSlipForce(force);
};

var worldVelocity = vec2.create();
var relativePoint = vec2.create();

/**
 * @method getSpeed
 */
WheelConstraint.prototype.getSpeed = function(){
    this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);
    this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);
    return vec2.dot(worldVelocity, relativePoint);
};

var tmpVec = vec2.create();

/**
 * @method update
 */
WheelConstraint.prototype.update = function(){

    // Directional
    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);
    vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);
    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);

    vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);
    vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);

    // Attachment point
    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);
    vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);

    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);
    vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);

    // Add engine force
    vec2.normalize(tmpVec, this.forwardEquation.t);
    vec2.scale(tmpVec, tmpVec, this.engineForce);

    this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);
};
},{"../constraints/Constraint":14,"../equations/FrictionEquation":23,"../math/vec2":30,"../objects/Body":31,"../utils/Utils":57}],36:[function(_dereq_,module,exports){
// Export p2 classes
var p2 = module.exports = {
    AABB :                          _dereq_('./collision/AABB'),
    AngleLockEquation :             _dereq_('./equations/AngleLockEquation'),
    Body :                          _dereq_('./objects/Body'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Capsule :                       _dereq_('./shapes/Capsule'),
    Circle :                        _dereq_('./shapes/Circle'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    ContactEquationPool :           _dereq_('./utils/ContactEquationPool'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    Convex :                        _dereq_('./shapes/Convex'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventEmitter :                  _dereq_('./events/EventEmitter'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    FrictionEquationPool :          _dereq_('./utils/FrictionEquationPool'),
    GearConstraint :                _dereq_('./constraints/GearConstraint'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    Line :                          _dereq_('./shapes/Line'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Material :                      _dereq_('./material/Material'),
    Narrowphase :                   _dereq_('./collision/Narrowphase'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    Pool :                          _dereq_('./utils/Pool'),
    RevoluteConstraint :            _dereq_('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           _dereq_('./constraints/PrismaticConstraint'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    Box :                           _dereq_('./shapes/Box'),
    RotationalVelocityEquation :    _dereq_('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Spring :                        _dereq_('./objects/Spring'),
    TopDownVehicle :                _dereq_('./objects/TopDownVehicle'),
    LinearSpring :                  _dereq_('./objects/LinearSpring'),
    RotationalSpring :              _dereq_('./objects/RotationalSpring'),
    Utils :                         _dereq_('./utils/Utils'),
    World :                         _dereq_('./world/World'),
    vec2 :                          _dereq_('./math/vec2'),
    version :                       _dereq_('../package.json').version,
};

Object.defineProperty(p2, 'Rectangle', {
    get: function() {
        console.warn('The Rectangle class has been renamed to Box.');
        return this.Box;
    }
});
},{"../package.json":6,"./collision/AABB":7,"./collision/Broadphase":8,"./collision/NaiveBroadphase":9,"./collision/Narrowphase":10,"./collision/Ray":11,"./collision/RaycastResult":12,"./collision/SAPBroadphase":13,"./constraints/Constraint":14,"./constraints/DistanceConstraint":15,"./constraints/GearConstraint":16,"./constraints/LockConstraint":17,"./constraints/PrismaticConstraint":18,"./constraints/RevoluteConstraint":19,"./equations/AngleLockEquation":20,"./equations/ContactEquation":21,"./equations/Equation":22,"./equations/FrictionEquation":23,"./equations/RotationalVelocityEquation":25,"./events/EventEmitter":26,"./material/ContactMaterial":27,"./material/Material":28,"./math/vec2":30,"./objects/Body":31,"./objects/LinearSpring":32,"./objects/RotationalSpring":33,"./objects/Spring":34,"./objects/TopDownVehicle":35,"./shapes/Box":37,"./shapes/Capsule":38,"./shapes/Circle":39,"./shapes/Convex":40,"./shapes/Heightfield":41,"./shapes/Line":42,"./shapes/Particle":43,"./shapes/Plane":44,"./shapes/Shape":45,"./solver/GSSolver":46,"./solver/Solver":47,"./utils/ContactEquationPool":48,"./utils/FrictionEquationPool":49,"./utils/Pool":55,"./utils/Utils":57,"./world/World":61}],37:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Shape = _dereq_('./Shape')
,   Convex = _dereq_('./Convex');

module.exports = Box;

/**
 * Box shape class.
 * @class Box
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.width=1] Total width of the box
 * @param {Number} [options.height=1] Total height of the box
 * @extends Convex
 */
function Box(options){
    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){
        options = {
            width: arguments[0],
            height: arguments[1]
        };
        console.warn('The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })');
    }
    options = options || {};

    /**
     * Total width of the box
     * @property width
     * @type {Number}
     */
    var width = this.width = options.width || 1;

    /**
     * Total height of the box
     * @property height
     * @type {Number}
     */
    var height = this.height = options.height || 1;

    var verts = [
        vec2.fromValues(-width/2, -height/2),
        vec2.fromValues( width/2, -height/2),
        vec2.fromValues( width/2,  height/2),
        vec2.fromValues(-width/2,  height/2)
    ];
    var axes = [
        vec2.fromValues(1, 0),
        vec2.fromValues(0, 1)
    ];

    options.vertices = verts;
    options.axes = axes;
    options.type = Shape.BOX;
    Convex.call(this, options);
}
Box.prototype = new Convex();
Box.prototype.constructor = Box;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Box.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Box.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Box.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Box.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":30,"./Convex":40,"./Shape":45}],38:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.length=1] The distance between the end points
 * @param {Number} [options.radius=1] Radius of the capsule
 * @example
 *     var capsuleShape = new Capsule({
 *         length: 1,
 *         radius: 2
 *     });
 *     body.addShape(capsuleShape);
 */
function Capsule(options){
    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){
        options = {
            length: arguments[0],
            radius: arguments[1]
        };
        console.warn('The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })');
    }
    options = options || {};

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = options.length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = options.radius || 1;

    options.type = Shape.CAPSULE;
    Shape.call(this, options);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

var intersectCapsule_hitPointWorld = vec2.create();
var intersectCapsule_normal = vec2.create();
var intersectCapsule_l0 = vec2.create();
var intersectCapsule_l1 = vec2.create();
var intersectCapsule_unit_y = vec2.fromValues(0,1);

/**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */
Capsule.prototype.raycast = function(result, ray, position, angle){
    var from = ray.from;
    var to = ray.to;
    var direction = ray.direction;

    var hitPointWorld = intersectCapsule_hitPointWorld;
    var normal = intersectCapsule_normal;
    var l0 = intersectCapsule_l0;
    var l1 = intersectCapsule_l1;

    // The sides
    var halfLen = this.length / 2;
    for(var i=0; i<2; i++){

        // get start and end of the line
        var y = this.radius * (i*2-1);
        vec2.set(l0, -halfLen, y);
        vec2.set(l1, halfLen, y);
        vec2.toGlobalFrame(l0, l0, position, angle);
        vec2.toGlobalFrame(l1, l1, position, angle);

        var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);
        if(delta >= 0){
            vec2.rotate(normal, intersectCapsule_unit_y, angle);
            vec2.scale(normal, normal, (i*2-1));
            ray.reportIntersection(result, delta, normal, -1);
            if(result.shouldStop(ray)){
                return;
            }
        }
    }

    // Circles
    var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
    for(var i=0; i<2; i++){
        vec2.set(l0, halfLen * (i*2-1), 0);
        vec2.toGlobalFrame(l0, l0, position, angle);

        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
        var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
        var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;

        if(delta < 0){
            // No intersection
            continue;

        } else if(delta === 0){
            // single intersection point
            vec2.lerp(hitPointWorld, from, to, delta);

            if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
                vec2.sub(normal, hitPointWorld, l0);
                vec2.normalize(normal,normal);
                ray.reportIntersection(result, delta, normal, -1);
                if(result.shouldStop(ray)){
                    return;
                }
            }

        } else {
            var sqrtDelta = Math.sqrt(delta);
            var inv2a = 1 / (2 * a);
            var d1 = (- b - sqrtDelta) * inv2a;
            var d2 = (- b + sqrtDelta) * inv2a;

            if(d1 >= 0 && d1 <= 1){
                vec2.lerp(hitPointWorld, from, to, d1);
                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
                    vec2.sub(normal, hitPointWorld, l0);
                    vec2.normalize(normal,normal);
                    ray.reportIntersection(result, d1, normal, -1);
                    if(result.shouldStop(ray)){
                        return;
                    }
                }
            }

            if(d2 >= 0 && d2 <= 1){
                vec2.lerp(hitPointWorld, from, to, d2);
                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){
                    vec2.sub(normal, hitPointWorld, l0);
                    vec2.normalize(normal,normal);
                    ray.reportIntersection(result, d2, normal, -1);
                    if(result.shouldStop(ray)){
                        return;
                    }
                }
            }
        }
    }
};
},{"../math/vec2":30,"./Shape":45}],39:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {number} [options.radius=1] The radius of this circle
 *
 * @example
 *     var circleShape = new Circle({ radius: 1 });
 *     body.addShape(circleShape);
 */
function Circle(options){
    if(typeof(arguments[0]) === 'number'){
        options = {
            radius: arguments[0]
        };
        console.warn('The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })');
    }
    options = options || {};

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = options.radius || 1;

    options.type = Shape.CIRCLE;
    Shape.call(this, options);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();

/**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */
Circle.prototype.raycast = function(result, ray, position, angle){
    var from = ray.from,
        to = ray.to,
        r = this.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta);

        vec2.sub(normal, intersectionPoint, position);
        vec2.normalize(normal,normal);

        ray.reportIntersection(result, delta, normal, -1);

    } else {
        var sqrtDelta = Math.sqrt(delta);
        var inv2a = 1 / (2 * a);
        var d1 = (- b - sqrtDelta) * inv2a;
        var d2 = (- b + sqrtDelta) * inv2a;

        if(d1 >= 0 && d1 <= 1){
            vec2.lerp(intersectionPoint, from, to, d1);

            vec2.sub(normal, intersectionPoint, position);
            vec2.normalize(normal,normal);

            ray.reportIntersection(result, d1, normal, -1);

            if(result.shouldStop(ray)){
                return;
            }
        }

        if(d2 >= 0 && d2 <= 1){
            vec2.lerp(intersectionPoint, from, to, d2);

            vec2.sub(normal, intersectionPoint, position);
            vec2.normalize(normal,normal);

            ray.reportIntersection(result, d2, normal, -1);
        }
    }
};
},{"../math/vec2":30,"./Shape":45}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2')
,   polyk = _dereq_('../math/polyk')
,   decomp = _dereq_('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [options.axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex({ vertices: vertices });
 *     body.addShape(convexShape);
 */
function Convex(options){
    if(Array.isArray(arguments[0])){
        options = {
            vertices: arguments[0],
            axes: arguments[1]
        };
        console.warn('The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })');
    }
    options = options || {};

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    // Copy the verts
    var vertices = options.vertices !== undefined ? options.vertices : [];
    for(var i=0; i < vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v, vertices[i]);
        this.vertices.push(v);
    }

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    if(options.axes){

        // Copy the axes
        for(var i=0; i < options.axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, options.axes[i]);
            this.axes.push(axis);
        }

    } else {

        // Construct axes from the vertex data
        for(var i = 0; i < this.vertices.length; i++){
            // Get the world edge
            var worldPoint0 = this.vertices[i];
            var worldPoint1 = this.vertices[(i+1) % this.vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }

    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    options.type = Shape.CONVEX;
    Shape.call(this, options);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

var intersectConvex_rayStart = vec2.create();
var intersectConvex_rayEnd = vec2.create();
var intersectConvex_normal = vec2.create();

/**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */
Convex.prototype.raycast = function(result, ray, position, angle){
    var rayStart = intersectConvex_rayStart;
    var rayEnd = intersectConvex_rayEnd;
    var normal = intersectConvex_normal;
    var vertices = this.vertices;

    // Transform to local shape space
    vec2.toLocalFrame(rayStart, ray.from, position, angle);
    vec2.toLocalFrame(rayEnd, ray.to, position, angle);

    var n = vertices.length;

    for (var i = 0; i < n && !result.shouldStop(ray); i++) {
        var q1 = vertices[i];
        var q2 = vertices[(i+1) % n];
        var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);

        if(delta >= 0){
            vec2.sub(normal, q2, q1);
            vec2.rotate(normal, normal, -Math.PI / 2 + angle);
            vec2.normalize(normal, normal);
            ray.reportIntersection(result, delta, normal, i);
        }
    }
};

},{"../math/polyk":29,"../math/vec2":30,"./Shape":45,"poly-decomp":5}],41:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 *
 * @example
 *     // Generate some height data (y-values).
 *     var heights = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         heights.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield({
 *         heights: heights,
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 *
 * @todo Should use a scale property with X and Y direction instead of just elementWidth
 */
function Heightfield(options){
    if(Array.isArray(arguments[0])){
        options = {
            heights: arguments[0]
        };

        if(typeof(arguments[1]) === 'object'){
            for(var key in arguments[1]){
                options[key] = arguments[1][key];
            }
        }

        console.warn('The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })');
    }
    options = options || {};

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} heights
     */
    this.heights = options.heights ? options.heights.slice(0) : [];

    /**
     * Max value of the heights
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue || null;

    /**
     * Max value of the heights
     * @property {number} minValue
     */
    this.minValue = options.minValue || null;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth || 0.1;

    if(options.maxValue === undefined || options.minValue === undefined){
        this.updateMaxMinValues();
    }

    options.type = Shape.HEIGHTFIELD;
    Shape.call(this, options);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * Update the .minValue and the .maxValue
 * @method updateMaxMinValues
 */
Heightfield.prototype.updateMaxMinValues = function(){
    var data = this.heights;
    var maxValue = data[0];
    var minValue = data[0];
    for(var i=0; i !== data.length; i++){
        var v = data[i];
        if(v > maxValue){
            maxValue = v;
        }
        if(v < minValue){
            minValue = v;
        }
    }
    this.maxValue = maxValue;
    this.minValue = minValue;
};

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.heights,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

var points = [
    vec2.create(),
    vec2.create(),
    vec2.create(),
    vec2.create()
];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    vec2.set(points[0], 0, this.maxValue);
    vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
    vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);
    vec2.set(points[3], 0, this.minValue);
    out.setFromPoints(points, position, angle);
};

/**
 * Get a line segment in the heightfield
 * @method getLineSegment
 * @param  {array} start Where to store the resulting start point
 * @param  {array} end Where to store the resulting end point
 * @param  {number} i
 */
Heightfield.prototype.getLineSegment = function(start, end, i){
    var data = this.heights;
    var width = this.elementWidth;
    vec2.set(start, i * width, data[i]);
    vec2.set(end, (i + 1) * width, data[i + 1]);
};

Heightfield.prototype.getSegmentIndex = function(position){
    return Math.floor(position[0] / this.elementWidth);
};

Heightfield.prototype.getClampedSegmentIndex = function(position){
    var i = this.getSegmentIndex(position);
    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
    return i;
};

var intersectHeightfield_hitPointWorld = vec2.create();
var intersectHeightfield_worldNormal = vec2.create();
var intersectHeightfield_l0 = vec2.create();
var intersectHeightfield_l1 = vec2.create();
var intersectHeightfield_localFrom = vec2.create();
var intersectHeightfield_localTo = vec2.create();
var intersectHeightfield_unit_y = vec2.fromValues(0,1);

// Returns 1 if the lines intersect, otherwise 0.
function getLineSegmentsIntersection (out, p0, p1, p2, p3) {

    var s1_x, s1_y, s2_x, s2_y;
    s1_x = p1[0] - p0[0];
    s1_y = p1[1] - p0[1];
    s2_x = p3[0] - p2[0];
    s2_y = p3[1] - p2[1];

    var s, t;
    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
        var intX = p0[0] + (t * s1_x);
        var intY = p0[1] + (t * s1_y);
        out[0] = intX;
        out[1] = intY;
        return t;
    }
    return -1; // No collision
}

/**
 * @method raycast
 * @param  {RayResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */
Heightfield.prototype.raycast = function(result, ray, position, angle){
    var from = ray.from;
    var to = ray.to;
    var direction = ray.direction;

    var hitPointWorld = intersectHeightfield_hitPointWorld;
    var worldNormal = intersectHeightfield_worldNormal;
    var l0 = intersectHeightfield_l0;
    var l1 = intersectHeightfield_l1;
    var localFrom = intersectHeightfield_localFrom;
    var localTo = intersectHeightfield_localTo;

    // get local ray start and end
    vec2.toLocalFrame(localFrom, from, position, angle);
    vec2.toLocalFrame(localTo, to, position, angle);

    // Get the segment range
    var i0 = this.getClampedSegmentIndex(localFrom);
    var i1 = this.getClampedSegmentIndex(localTo);
    if(i0 > i1){
        var tmp = i0;
        i0 = i1;
        i1 = tmp;
    }

    // The segments
    for(var i=0; i<this.heights.length - 1; i++){
        this.getLineSegment(l0, l1, i);
        var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
        if(t >= 0){
            vec2.sub(worldNormal, l1, l0);
            vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
            vec2.normalize(worldNormal, worldNormal);
            ray.reportIntersection(result, t, worldNormal, -1);
            if(result.shouldStop(ray)){
                return;
            }
        }
    }
};
},{"../math/vec2":30,"../utils/Utils":57,"./Shape":45}],42:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @param {Number} [options.length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(options){
    if(typeof(arguments[0]) === 'number'){
        options = {
            length: arguments[0]
        };
        console.warn('The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })');
    }
    options = options || {};

    /**
     * Length of this line
     * @property {Number} length
     * @default 1
     */
    this.length = options.length || 1;

    options.type = Shape.LINE;
    Shape.call(this, options);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};

var raycast_hitPoint = vec2.create();
var raycast_normal = vec2.create();
var raycast_l0 = vec2.create();
var raycast_l1 = vec2.create();
var raycast_unit_y = vec2.fromValues(0,1);

/**
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @param  {number} angle
 * @param  {array} position
 */
Line.prototype.raycast = function(result, ray, position, angle){
    var from = ray.from;
    var to = ray.to;

    var l0 = raycast_l0;
    var l1 = raycast_l1;

    // get start and end of the line
    var halfLen = this.length / 2;
    vec2.set(l0, -halfLen, 0);
    vec2.set(l1, halfLen, 0);
    vec2.toGlobalFrame(l0, l0, position, angle);
    vec2.toGlobalFrame(l1, l1, position, angle);

    var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);
    if(fraction >= 0){
        var normal = raycast_normal;
        vec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
        ray.reportIntersection(result, fraction, normal, -1);
    }
};
},{"../math/vec2":30,"./Shape":45}],43:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 * @extends Shape
 */
function Particle(options){
    options = options || {};
	options.type = Shape.PARTICLE;
    Shape.call(this, options);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":30,"./Shape":45}],44:[function(_dereq_,module,exports){
var Shape =  _dereq_('./Shape')
,    vec2 =  _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
 */
function Plane(options){
    options = options || {};
    options.type = Shape.PLANE;
    Shape.call(this, options);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = angle % (2 * Math.PI);
    var set = vec2.set;
    var max = 1e7;
    var lowerBound = out.lowerBound;
    var upperBound = out.upperBound;

    // Set max bounds
    set(lowerBound, -max, -max);
    set(upperBound,  max,  max);

    if(a === 0){
        // y goes from -inf to 0
        upperBound[1] = 0;
        // set(lowerBound, -max, -max);
        // set(upperBound,  max,  0);

    } else if(a === Math.PI / 2){

        // x goes from 0 to inf
        lowerBound[0] = 0;
        // set(lowerBound, 0, -max);
        // set(upperBound,      max,  max);

    } else if(a === Math.PI){

        // y goes from 0 to inf
        lowerBound[1] = 0;
        // set(lowerBound, -max, 0);
        // set(upperBound,  max, max);

    } else if(a === 3*Math.PI/2){

        // x goes from -inf to 0
        upperBound[0] = 0;
        // set(lowerBound, -max,     -max);
        // set(upperBound,  0,  max);

    }
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPoint = vec2.create();
var intersectPlane_normal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method raycast
 * @param  {RayResult} result
 * @param  {Ray} ray
 * @param  {array} position
 * @param  {number} angle
 */
Plane.prototype.raycast = function(result, ray, position, angle){
    var from = ray.from;
    var to = ray.to;
    var direction = ray.direction;
    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPoint = intersectPlane_hitPoint;
    var normal = intersectPlane_normal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(normal, 0, 1);
    vec2.rotate(normal, normal, angle);

    vec2.sub(len, from, position);
    var planeToFrom = vec2.dot(len, normal);
    vec2.sub(len, to, position);
    var planeToTo = vec2.dot(len, normal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.squaredDistance(from, to) < planeToFrom * planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(normal, direction);

    vec2.sub(planePointToFrom, from, position);
    var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;

    ray.reportIntersection(result, t, normal, -1);
};
},{"../math/vec2":30,"../utils/Utils":57,"./Shape":45}],45:[function(_dereq_,module,exports){
module.exports = Shape;

var vec2 = _dereq_('../math/vec2');

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {object} [options]
 * @param {array} [options.position]
 * @param {number} [options.angle=0]
 * @param {number} [options.collisionGroup=1]
 * @param {number} [options.collisionMask=1]
 * @param {boolean} [options.sensor=false]
 * @param {boolean} [options.collisionResponse=true]
 * @param {object} [options.type=0]
 */
function Shape(options){
    options = options || {};

    /**
     * The body this shape is attached to. A shape can only be attached to a single body.
     * @property {Body} body
     */
    this.body = null;

    /**
     * Body-local position of the shape.
     * @property {Array} position
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * Body-local angle of the shape.
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/BOX:property"}}Shape.BOX{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = options.type || 0;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = options.material || null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = options.sensor !== undefined ? options.sensor : false;

    if(this.type){
        this.updateBoundingRadius();
    }

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} BOX
 */
Shape.BOX =   32;

Object.defineProperty(Shape, 'RECTANGLE', {
    get: function() {
        console.warn('Shape.RECTANGLE is deprecated, use Shape.BOX instead.');
        return Shape.BOX;
    }
});

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB} out The resulting AABB.
 * @param  {Array} position World position of the shape.
 * @param  {Number} angle World angle of the shape.
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

/**
 * Perform raycasting on this shape.
 * @method raycast
 * @param  {RayResult} result Where to store the resulting data.
 * @param  {Ray} ray The Ray that you want to use for raycasting.
 * @param  {array} position World position of the shape (the .position property will be ignored).
 * @param  {number} angle World angle of the shape (the .angle property will be ignored).
 */
Shape.prototype.raycast = function(result, ray, position, angle){
    // To be implemented in each subclass
};
},{"../math/vec2":30}],46:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Solver = _dereq_('./Solver')
,   Utils = _dereq_('../utils/Utils')
,   FrictionEquation = _dereq_('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The max number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     * @default 1e-7
     */
    this.tolerance = options.tolerance || 1e-7;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     * @todo Remove, not used
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.
     *
     * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.
     *
     * @property frictionIterations
     * @type {Number}
     * @default 0
     */
    this.frictionIterations = options.frictionIterations !== undefined ? 0 : options.frictionIterations;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":23,"../math/vec2":30,"../utils/Utils":57,"./Solver":47}],47:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":26,"../utils/Utils":57}],48:[function(_dereq_,module,exports){
var ContactEquation = _dereq_('../equations/ContactEquation');
var Pool = _dereq_('./Pool');

module.exports = ContactEquationPool;

/**
 * @class
 */
function ContactEquationPool() {
	Pool.apply(this, arguments);
}
ContactEquationPool.prototype = new Pool();
ContactEquationPool.prototype.constructor = ContactEquationPool;

/**
 * @method create
 * @return {ContactEquation}
 */
ContactEquationPool.prototype.create = function () {
	return new ContactEquation();
};

/**
 * @method destroy
 * @param {ContactEquation} equation
 * @return {ContactEquationPool}
 */
ContactEquationPool.prototype.destroy = function (equation) {
	equation.bodyA = equation.bodyB = null;
	return this;
};

},{"../equations/ContactEquation":21,"./Pool":55}],49:[function(_dereq_,module,exports){
var FrictionEquation = _dereq_('../equations/FrictionEquation');
var Pool = _dereq_('./Pool');

module.exports = FrictionEquationPool;

/**
 * @class
 */
function FrictionEquationPool() {
	Pool.apply(this, arguments);
}
FrictionEquationPool.prototype = new Pool();
FrictionEquationPool.prototype.constructor = FrictionEquationPool;

/**
 * @method create
 * @return {FrictionEquation}
 */
FrictionEquationPool.prototype.create = function () {
	return new FrictionEquation();
};

/**
 * @method destroy
 * @param {FrictionEquation} equation
 * @return {FrictionEquationPool}
 */
FrictionEquationPool.prototype.destroy = function (equation) {
	equation.bodyA = equation.bodyB = null;
	return this;
};

},{"../equations/FrictionEquation":23,"./Pool":55}],50:[function(_dereq_,module,exports){
var IslandNode = _dereq_('../world/IslandNode');
var Pool = _dereq_('./Pool');

module.exports = IslandNodePool;

/**
 * @class
 */
function IslandNodePool() {
	Pool.apply(this, arguments);
}
IslandNodePool.prototype = new Pool();
IslandNodePool.prototype.constructor = IslandNodePool;

/**
 * @method create
 * @return {IslandNode}
 */
IslandNodePool.prototype.create = function () {
	return new IslandNode();
};

/**
 * @method destroy
 * @param {IslandNode} node
 * @return {IslandNodePool}
 */
IslandNodePool.prototype.destroy = function (node) {
	node.reset();
	return this;
};

},{"../world/IslandNode":60,"./Pool":55}],51:[function(_dereq_,module,exports){
var Island = _dereq_('../world/Island');
var Pool = _dereq_('./Pool');

module.exports = IslandPool;

/**
 * @class
 */
function IslandPool() {
	Pool.apply(this, arguments);
}
IslandPool.prototype = new Pool();
IslandPool.prototype.constructor = IslandPool;

/**
 * @method create
 * @return {Island}
 */
IslandPool.prototype.create = function () {
	return new Island();
};

/**
 * @method destroy
 * @param {Island} island
 * @return {IslandPool}
 */
IslandPool.prototype.destroy = function (island) {
	island.reset();
	return this;
};

},{"../world/Island":58,"./Pool":55}],52:[function(_dereq_,module,exports){
var TupleDictionary = _dereq_('./TupleDictionary');
var OverlapKeeperRecord = _dereq_('./OverlapKeeperRecord');
var OverlapKeeperRecordPool = _dereq_('./OverlapKeeperRecordPool');
var Utils = _dereq_('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = new OverlapKeeperRecordPool({ size: 16 });
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.release(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){
        var data = this.recordPool.get();
        data.set(bodyA, shapeA, bodyB, shapeB);
        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

},{"./OverlapKeeperRecord":53,"./OverlapKeeperRecordPool":54,"./TupleDictionary":56,"./Utils":57}],53:[function(_dereq_,module,exports){
module.exports = OverlapKeeperRecord;

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{}],54:[function(_dereq_,module,exports){
var OverlapKeeperRecord = _dereq_('./OverlapKeeperRecord');
var Pool = _dereq_('./Pool');

module.exports = OverlapKeeperRecordPool;

/**
 * @class
 */
function OverlapKeeperRecordPool() {
	Pool.apply(this, arguments);
}
OverlapKeeperRecordPool.prototype = new Pool();
OverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;

/**
 * @method create
 * @return {OverlapKeeperRecord}
 */
OverlapKeeperRecordPool.prototype.create = function () {
	return new OverlapKeeperRecord();
};

/**
 * @method destroy
 * @param {OverlapKeeperRecord} record
 * @return {OverlapKeeperRecordPool}
 */
OverlapKeeperRecordPool.prototype.destroy = function (record) {
	record.bodyA = record.bodyB = record.shapeA = record.shapeB = null;
	return this;
};

},{"./OverlapKeeperRecord":53,"./Pool":55}],55:[function(_dereq_,module,exports){
module.exports = Pool;

/**
 * @class Object pooling utility.
 */
function Pool(options) {
	options = options || {};

	/**
	 * @property {Array} objects
	 * @type {Array}
	 */
	this.objects = [];

	if(options.size !== undefined){
		this.resize(options.size);
	}
}

/**
 * @method resize
 * @param {number} size
 * @return {Pool} Self, for chaining
 */
Pool.prototype.resize = function (size) {
	var objects = this.objects;

	while (objects.length > size) {
		objects.pop();
	}

	while (objects.length < size) {
		objects.push(this.create());
	}

	return this;
};

/**
 * Get an object from the pool or create a new instance.
 * @method get
 * @return {Object}
 */
Pool.prototype.get = function () {
	var objects = this.objects;
	return objects.length ? objects.pop() : this.create();
};

/**
 * Clean up and put the object back into the pool for later use.
 * @method release
 * @param {Object} object
 * @return {Pool} Self for chaining
 */
Pool.prototype.release = function (object) {
	this.destroy(object);
	this.objects.push(object);
	return this;
};

},{}],56:[function(_dereq_,module,exports){
var Utils = _dereq_('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":57}],57:[function(_dereq_,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],58:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":31}],59:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Island = _dereq_('./Island')
,   IslandNode = _dereq_('./IslandNode')
,   IslandNodePool = _dereq_('./../utils/IslandNodePool')
,   IslandPool = _dereq_('./../utils/IslandPool')
,   Body = _dereq_('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    /**
     * @property nodePool
     * @type {IslandNodePool}
     */
    this.nodePool = new IslandNodePool({ size: 16 });

    /**
     * @property islandPool
     * @type {IslandPool}
     */
    this.islandPool = new IslandPool({ size: 8 });

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this.nodePool.release(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        var node = this.nodePool.get();
        node.body = bodies[i];
        nodes.push(node);
        // if(this.nodePool.length){
        //     var node = this.nodePool.pop();
        //     node.reset();
        //     node.body = bodies[i];
        //     nodes.push(node);
        // } else {
        //     nodes.push(new IslandNode(bodies[i]));
        // }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    for(var i=0; i<islands.length; i++){
        this.islandPool.release(islands[i]);
    }
    islands.length = 0;

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this.islandPool.get();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":30,"../objects/Body":31,"./../utils/IslandNodePool":50,"./../utils/IslandPool":51,"./Island":58,"./IslandNode":60}],60:[function(_dereq_,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],61:[function(_dereq_,module,exports){
var  GSSolver = _dereq_('../solver/GSSolver')
,    Solver = _dereq_('../solver/Solver')
,    Ray = _dereq_('../collision/Ray')
,    vec2 = _dereq_('../math/vec2')
,    Circle = _dereq_('../shapes/Circle')
,    Convex = _dereq_('../shapes/Convex')
,    Line = _dereq_('../shapes/Line')
,    Plane = _dereq_('../shapes/Plane')
,    Capsule = _dereq_('../shapes/Capsule')
,    Particle = _dereq_('../shapes/Particle')
,    EventEmitter = _dereq_('../events/EventEmitter')
,    Body = _dereq_('../objects/Body')
,    Shape = _dereq_('../shapes/Shape')
,    LinearSpring = _dereq_('../objects/LinearSpring')
,    Material = _dereq_('../material/Material')
,    ContactMaterial = _dereq_('../material/ContactMaterial')
,    DistanceConstraint = _dereq_('../constraints/DistanceConstraint')
,    Constraint = _dereq_('../constraints/Constraint')
,    LockConstraint = _dereq_('../constraints/LockConstraint')
,    RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint')
,    PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint')
,    GearConstraint = _dereq_('../constraints/GearConstraint')
,    pkg = _dereq_('../../package.json')
,    Broadphase = _dereq_('../collision/Broadphase')
,    AABB = _dereq_('../collision/AABB')
,    SAPBroadphase = _dereq_('../collision/SAPBroadphase')
,    Narrowphase = _dereq_('../collision/Narrowphase')
,    Utils = _dereq_('../utils/Utils')
,    OverlapKeeper = _dereq_('../utils/OverlapKeeper')
,    IslandManager = _dereq_('./IslandManager')
,    RotationalSpring = _dereq_('../objects/RotationalSpring');

module.exports = World;

/**
 * The dynamics world, where all bodies and constraints live.
 *
 * @class World
 * @constructor
 * @param {Object} [options]
 * @param {Solver} [options.solver] Defaults to GSSolver.
 * @param {Array} [options.gravity] Defaults to y=-9.78.
 * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
 * @param {Boolean} [options.islandSplit=true]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -10],
 *         broadphase: new SAPBroadphase()
 *     });
 *     world.addBody(new Body());
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     * @default true
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     * @default true
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     * @default true
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     * @default true
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     * @default true
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     * @default true
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;
    this.accumulator = 0;

    /**
     * Is true during step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     * @default true
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : true;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     * @default true
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep"
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type: "postBroadphase",
        pairs: null
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type: "beginContact",
        shapeA: null,
        shapeB: null,
        bodyA: null,
        bodyB: null,
        contactEquations: []
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     */
    this.endContactEvent = {
        type: "endContact",
        shapeA: null,
        shapeB: null,
        bodyA: null,
        bodyB: null
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type: "preSolve",
        contactEquations: null,
        frictionEquations: null
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    /**
     * @property {OverlapKeeper} overlapKeeper
     */
    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} constraint
 * @example
 *     var constraint = new LockConstraint(bodyA, bodyB);
 *     world.addConstraint(constraint);
 */
World.prototype.addConstraint = function(constraint){
    this.constraints.push(constraint);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} constraint
 */
World.prototype.removeConstraint = function(constraint){
    var idx = this.constraints.indexOf(constraint);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // Simple fixed timestepping without interpolation
 *     var fixedTimeStep = 1 / 60;
 *     var world = new World();
 *     var body = new Body({ mass: 1 });
 *     world.addBody(body);
 *
 *     function animate(){
 *         requestAnimationFrame(animate);
 *         world.step(fixedTimeStep);
 *         renderBody(body.position, body.angle);
 *     }
 *
 *     // Start animation loop
 *     requestAnimationFrame(animate);
 *
 * @example
 *     // Fixed timestepping with interpolation
 *     var maxSubSteps = 10;
 *     var lastTimeSeconds;
 *
 *     function animate(t){
 *         requestAnimationFrame(animate);
 *         timeSeconds = t / 1000;
 *         lastTimeSeconds = lastTimeSeconds || timeSeconds;
 *
 *         deltaTime = timeSeconds - lastTimeSeconds;
 *         world.step(fixedTimeStep, deltaTime, maxSubSteps);
 *
 *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
 *     }
 *
 *     // Start animation loop
 *     requestAnimationFrame(animate);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        this.accumulator += timeSinceLastCalled;
        var substeps = 0;
        while (this.accumulator >= dt && substeps < maxSubSteps) {
            // Do fixed steps to catch up
            this.internalStep(dt);
            this.time += dt;
            this.accumulator -= dt;
            substeps++;
        }

        var t = (this.accumulator % dt) / dt;
        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
            b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);
    this.postBroadphaseEvent.pairs = null;

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = si.position,
                ai = si.angle;

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = sj.position,
                    aj = sj.angle;

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
        endOverlaps.length = 0;
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);
    preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || Nconstraints){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        // if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
        body.integrate(dt);
        // }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    var bodiesToBeRemoved = this.bodiesToBeRemoved;
    for(var i=0; i!==bodiesToBeRemoved.length; i++){
        this.removeBody(bodiesToBeRemoved[i]);
    }
    bodiesToBeRemoved.length = 0;

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} spring
 */
World.prototype.addSpring = function(spring){
    this.springs.push(spring);
    var evt = this.addSpringEvent;
    evt.spring = spring;
    this.emit(evt);
    evt.spring = null;
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} spring
 */
World.prototype.removeSpring = function(spring){
    var idx = this.springs.indexOf(spring);
    if(idx !== -1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        var evt = this.addBodyEvent;
        evt.body = body;
        this.emit(evt);
        evt.body = null;
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
            this.removeBodyEvent.body = null;
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @param {number} id
 * @return {Body} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableBodyCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableBodyCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 * @todo Should use an api similar to the raycast function
 * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
 * @todo Should use the broadphase
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];

        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j];

            // Get shape world position + angle
            vec2.rotate(x, s.position, b.angle);
            vec2.add(x, x, b.position);
            var a = s.angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){

    // Set for all constraints
    var constraints = this.constraints;
    for(var i=0; i !== constraints.length; i++){
        var c = constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            eq.stiffness = stiffness;
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    var contactMaterials = this.contactMaterials;
    for(var i=0; i !== contactMaterials.length; i++){
        var c = contactMaterials[i];
        c.stiffness = c.frictionStiffness = stiffness;
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    c.stiffness = c.frictionStiffness = stiffness;
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            eq.relaxation = relaxation;
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        c.relaxation = c.frictionRelaxation = relaxation;
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    c.relaxation = c.frictionRelaxation = relaxation;
};

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Ray cast against all bodies in the world.
 * @method raycast
 * @param  {RaycastResult} result
 * @param  {Ray} ray
 * @return {boolean} True if any body was hit.
 *
 * @example
 *     var ray = new Ray({
 *         mode: Ray.CLOSEST, // or ANY
 *         from: [0, 0],
 *         to: [10, 0],
 *     });
 *     var result = new RaycastResult();
 *     world.raycast(result, ray);
 *
 *     // Get the hit point
 *     var hitPoint = vec2.create();
 *     result.getHitPoint(hitPoint, ray);
 *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
 *
 * @example
 *     var ray = new Ray({
 *         mode: Ray.ALL,
 *         from: [0, 0],
 *         to: [10, 0],
 *         callback: function(result){
 *
 *             // Print some info about the hit
 *             console.log('Hit body and shape: ', result.body, result.shape);
 *
 *             // Get the hit point
 *             var hitPoint = vec2.create();
 *             result.getHitPoint(hitPoint, ray);
 *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
 *
 *             // If you are happy with the hits you got this far, you can stop the traversal here:
 *             result.stop();
 *         }
 *     });
 *     var result = new RaycastResult();
 *     world.raycast(result, ray);
 */
World.prototype.raycast = function(result, ray){

    // Get all bodies within the ray AABB
    ray.getAABB(tmpAABB);
    this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
    ray.intersectBodies(result, tmpArray);
    tmpArray.length = 0;

    return result.hasHit();
};

},{"../../package.json":6,"../collision/AABB":7,"../collision/Broadphase":8,"../collision/Narrowphase":10,"../collision/Ray":11,"../collision/SAPBroadphase":13,"../constraints/Constraint":14,"../constraints/DistanceConstraint":15,"../constraints/GearConstraint":16,"../constraints/LockConstraint":17,"../constraints/PrismaticConstraint":18,"../constraints/RevoluteConstraint":19,"../events/EventEmitter":26,"../material/ContactMaterial":27,"../material/Material":28,"../math/vec2":30,"../objects/Body":31,"../objects/LinearSpring":32,"../objects/RotationalSpring":33,"../shapes/Capsule":38,"../shapes/Circle":39,"../shapes/Convex":40,"../shapes/Line":42,"../shapes/Particle":43,"../shapes/Plane":44,"../shapes/Shape":45,"../solver/GSSolver":46,"../solver/Solver":47,"../utils/OverlapKeeper":52,"../utils/Utils":57,"./IslandManager":59}]},{},[36])
(36)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2016 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*
* @overview
*
* Phaser - http://phaser.io
*
* v2.7.7 "2017-04-20" - Built: Wed Apr 19 2017 21:51:30
*
* By Richard Davey http://www.photonstorm.com @photonstorm
*
* Phaser is a fun, free and fast 2D game framework for making HTML5 games
* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.
*
* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23
* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe
* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com
*
* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.
*
* Follow development at http://phaser.io and on our forum
*
* "If you want your children to be intelligent,  read them fairy tales."
* "If you want them to be more intelligent, read them more fairy tales."
*                                                     -- Albert Einstein
*/

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

(function(){

    var root = this;

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The [pixi.js](http://www.pixijs.com/) module/namespace.
 *
 * @module PIXI
 */
 
/**
 * Namespace-class for [pixi.js](http://www.pixijs.com/).
 *
 * Contains assorted static properties and enumerations.
 *
 * @class PIXI
 * @static
 */
var PIXI = PIXI || {};

/**
* @author       Mat Groves http://matgroves.com @Doormat23
* @author       Richard Davey <rich@photonstorm.com>
* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
*/

/**
* The base class for all objects that are rendered. Contains properties for position, scaling,
* rotation, masks and cache handling.
*
* This is an abstract class and should not be used on its own, rather it should be extended.
*
* It is used internally by the likes of PIXI.Sprite.
*
* @class DisplayObject
* @constructor
*/
PIXI.DisplayObject = function () {

    /**
    * The coordinates, in pixels, of this DisplayObject, relative to its parent container.
    *
    * The value of this property does not reflect any positioning happening further up the display list.
    * To obtain that value please see the `worldPosition` property.
    *
    * @property {PIXI.Point} position
    * @default
    */
    this.position = new PIXI.Point(0, 0);

    /**
    * The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject
    * at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.
    *
    * The value of this property does not reflect any scaling happening further up the display list.
    * To obtain that value please see the `worldScale` property.
    *
    * @property {PIXI.Point} scale
    * @default
    */
    this.scale = new PIXI.Point(1, 1);

    /**
    * The pivot point of this DisplayObject that it rotates around. The values are expressed
    * in pixel values.
    * @property {PIXI.Point} pivot
    * @default
    */
    this.pivot = new PIXI.Point(0, 0);

    /**
    * The rotation of this DisplayObject. The value is given, and expressed, in radians, and is based on
    * a right-handed orientation.
    *
    * The value of this property does not reflect any rotation happening further up the display list.
    * To obtain that value please see the `worldRotation` property.
    *
    * @property {number} rotation
    * @default
    */
    this.rotation = 0;

    /**
    * The alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.
    * Please note that an object with an alpha value of 0 is skipped during the render pass.
    *
    * The value of this property does not reflect any alpha values set further up the display list.
    * To obtain that value please see the `worldAlpha` property.
    *
    * @property {number} alpha
    * @default
    */
    this.alpha = 1;

    /**
    * The visibility of this DisplayObject. A value of `false` makes the object invisible.
    * A value of `true` makes it visible. Please note that an object with a visible value of
    * `false` is skipped during the render pass. Equally a DisplayObject with visible false will
    * not render any of its children.
    *
    * The value of this property does not reflect any visible values set further up the display list.
    * To obtain that value please see the `worldVisible` property.
    *
    * @property {boolean} visible
    * @default
    */
    this.visible = true;

    /**
     * This is the defined area that will pick up mouse / touch events. It is null by default.
     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)
     *
     * @property hitArea
     * @type Rectangle|Circle|Ellipse|Polygon
     */
    this.hitArea = null;

    /**
    * Should this DisplayObject be rendered by the renderer? An object with a renderable value of
    * `false` is skipped during the render pass.
    *
    * @property {boolean} renderable
    * @default
    */
    this.renderable = false;

    /**
    * The parent DisplayObjectContainer that this DisplayObject is a child of.
    * All DisplayObjects must belong to a parent in order to be rendered.
    * The root parent is the Stage object. This property is set automatically when the
    * DisplayObject is added to, or removed from, a DisplayObjectContainer.
    *
    * @property {PIXI.DisplayObjectContainer} parent
    * @default
    * @readOnly
    */
    this.parent = null;

    /**
    * The multiplied alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.
    * This value is the calculated total, based on the alpha values of all parents of this DisplayObjects
    * in the display list.
    *
    * To obtain, and set, the local alpha value, see the `alpha` property.
    *
    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
    * that happens this property will contain values based on the previous frame. Be mindful of this if
    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
    *
    * @property {number} worldAlpha
    * @readOnly
    */
    this.worldAlpha = 1;

    /**
    * The current transform of this DisplayObject.
    *
    * This property contains the calculated total, based on the transforms of all parents of this
    * DisplayObject in the display list.
    *
    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
    * that happens this property will contain values based on the previous frame. Be mindful of this if
    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
    *
    * @property {PIXI.Matrix} worldTransform
    * @readOnly
    */
    this.worldTransform = new PIXI.Matrix();

    /**
    * The coordinates, in pixels, of this DisplayObject within the world.
    *
    * This property contains the calculated total, based on the positions of all parents of this
    * DisplayObject in the display list.
    *
    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
    * that happens this property will contain values based on the previous frame. Be mindful of this if
    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
    *
    * @property {PIXI.Point} worldPosition
    * @readOnly
    */
    this.worldPosition = new PIXI.Point(0, 0);

    /**
    * The global scale of this DisplayObject.
    *
    * This property contains the calculated total, based on the scales of all parents of this
    * DisplayObject in the display list.
    *
    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
    * that happens this property will contain values based on the previous frame. Be mindful of this if
    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
    *
    * @property {PIXI.Point} worldScale
    * @readOnly
    */
    this.worldScale = new PIXI.Point(1, 1);

    /**
    * The rotation, in radians, of this DisplayObject.
    *
    * This property contains the calculated total, based on the rotations of all parents of this
    * DisplayObject in the display list.
    *
    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
    * that happens this property will contain values based on the previous frame. Be mindful of this if
    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
    *
    * @property {number} worldRotation
    * @readOnly
    */
    this.worldRotation = 0;

    /**
    * The rectangular area used by filters when rendering a shader for this DisplayObject.
    *
    * @property {PIXI.Rectangle} filterArea
    * @type Rectangle
    * @default
    */
    this.filterArea = null;

    /**
    * @property {number} _sr - Cached rotation value.
    * @private
    */
    this._sr = 0;

    /**
    * @property {number} _cr - Cached rotation value.
    * @private
    */
    this._cr = 1;

    /**
    * @property {PIXI.Rectangle} _bounds - The cached bounds of this object.
    * @private
    */
    this._bounds = new PIXI.Rectangle(0, 0, 0, 0);

    /**
    * @property {PIXI.Rectangle} _currentBounds - The most recently calculated bounds of this object.
    * @private
    */
    this._currentBounds = null;

    /**
    * @property {PIXI.Rectangle} _mask - The cached mask of this object.
    * @private
    */
    this._mask = null;

    /**
    * @property {boolean} _cacheAsBitmap - Internal cache as bitmap flag.
    * @private
    */
    this._cacheAsBitmap = false;

    /**
    * @property {boolean} _cacheIsDirty - Internal dirty cache flag.
    * @private
    */
    this._cacheIsDirty = false;

};

PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;

PIXI.DisplayObject.prototype = {

    /**
    * Destroy this DisplayObject.
    *
    * Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.
    *
    * Also iteratively calls `destroy` on any children.
    *
    * @method PIXI.DisplayObject#destroy
    */
    destroy: function () {

        if (this.children)
        {
            var i = this.children.length;

            while (i--)
            {
                this.children[i].destroy();
            }

            this.children = [];
        }

        this.hitArea = null;
        this.parent = null;
        this.worldTransform = null;
        this.filterArea = null;
        this.renderable = false;

        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;

        this._destroyCachedSprite();

    },

    /*
    * Updates the transform matrix this DisplayObject uses for rendering.
    *
    * If the object has no parent, and no parent parameter is provided, it will default to
    * Phaser.Game.World as the parent transform to use. If that is unavailable the transform fails to take place.
    *
    * The `parent` parameter has priority over the actual parent. Use it as a parent override.
    * Setting it does **not** change the actual parent of this DisplayObject.
    *
    * Calling this method updates the `worldTransform`, `worldAlpha`, `worldPosition`, `worldScale`
    * and `worldRotation` properties.
    *
    * If a `transformCallback` has been specified, it is called at the end of this method, and is passed
    * the new, updated, worldTransform property, along with the parent transform used.
    *
    * @method PIXI.DisplayObject#updateTransform
    * @param {PIXI.DisplayObjectContainer} [parent] - Optional parent to calculate this DisplayObjects transform from.
    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.
    */
    updateTransform: function (parent) {

        if (!parent && !this.parent && !this.game)
        {
            return this;
        }

        var p = this.parent;

        if (parent)
        {
            p = parent;
        }
        else if (!this.parent)
        {
            p = this.game.world;
        }

        // create some matrix refs for easy access
        var pt = p.worldTransform;
        var wt = this.worldTransform;

        // temporary matrix variables
        var a, b, c, d, tx, ty;

        // so if rotation is between 0 then we can simplify the multiplication process..
        if (this.rotation % Phaser.Math.PI2)
        {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            if (this.rotation !== this.rotationCache)
            {
                this.rotationCache = this.rotation;
                this._sr = Math.sin(this.rotation);
                this._cr = Math.cos(this.rotation);
            }

            // get the matrix values of the displayobject based on its transform properties..
            a  =  this._cr * this.scale.x;
            b  =  this._sr * this.scale.x;
            c  = -this._sr * this.scale.y;
            d  =  this._cr * this.scale.y;
            tx =  this.position.x;
            ty =  this.position.y;

            // check for pivot.. not often used so geared towards that fact!
            if (this.pivot.x || this.pivot.y)
            {
                tx -= this.pivot.x * a + this.pivot.y * c;
                ty -= this.pivot.x * b + this.pivot.y * d;
            }

            // concat the parent matrix with the objects transform.
            wt.a  = a  * pt.a + b  * pt.c;
            wt.b  = a  * pt.b + b  * pt.d;
            wt.c  = c  * pt.a + d  * pt.c;
            wt.d  = c  * pt.b + d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }
        else
        {
            // lets do the fast version as we know there is no rotation..
            a  = this.scale.x;
            d  = this.scale.y;

            tx = this.position.x - this.pivot.x * a;
            ty = this.position.y - this.pivot.y * d;

            wt.a  = a  * pt.a;
            wt.b  = a  * pt.b;
            wt.c  = d  * pt.c;
            wt.d  = d  * pt.d;
            wt.tx = tx * pt.a + ty * pt.c + pt.tx;
            wt.ty = tx * pt.b + ty * pt.d + pt.ty;
        }

        var determ = (a * d) - (b * c);
        var TAU = Math.PI * 0.5;

        if (a || b)
        {
            var r = Math.sqrt((a * a) + (b * b));

            this.worldRotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);
            this.worldScale.x = r;
            this.worldScale.y = determ / r;
        }
        else if (c || d)
        {
            var s = Math.sqrt((c * c) + (d * d));

            this.worldRotation = TAU - ((d > 0) ? Math.acos(-c / s) : -Math.acos(c / s));
            this.worldScale.x = determ / s;
            this.worldScale.y = s;
        }
        else
        {
            this.worldScale.x = 0;
            this.worldScale.y = 0;
        }

        //  Set the World values
        this.worldAlpha = this.alpha * p.worldAlpha;
        this.worldPosition.x = wt.tx;
        this.worldPosition.y = wt.ty;

        // reset the bounds each time this is called!
        this._currentBounds = null;

        //  Custom callback?
        if (this.transformCallback)
        {
            this.transformCallback.call(this.transformCallbackContext, wt, pt);
        }

        return this;

    },

    /**
    * To be overridden by classes that require it.
    *
    * @method PIXI.DisplayObject#preUpdate
    */
    preUpdate: function () {

    },

    /**
    * Generates a RenderTexture based on this DisplayObject, which can they be used to texture other Sprites.
    * This can be useful if your DisplayObject is static, or complicated, and needs to be reused multiple times.
    *
    * Please note that no garbage collection takes place on old textures. It is up to you to destroy old textures,
    * and references to them, so they don't linger in memory.
    *
    * @method PIXI.DisplayObject#generateTexture
    * @param {number} [resolution=1] - The resolution of the texture being generated.
    * @param {number} [scaleMode=PIXI.scaleModes.DEFAULT] - See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values.
    * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The renderer used to generate the texture.
    * @return {Phaser.RenderTexture} - A RenderTexture containing an image of this DisplayObject at the time it was invoked.
    */
    generateTexture: function (resolution, scaleMode, renderer) {

        var bounds = this.getLocalBounds();

        var renderTexture = new Phaser.RenderTexture(this.game, bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);

        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;
        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;

        renderTexture.render(this, PIXI.DisplayObject._tempMatrix);

        return renderTexture;

    },

    /**
    * If this DisplayObject has a cached Sprite, this method generates and updates it.
    *
    * @method PIXI.DisplayObject#updateCache
    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.
    */
    updateCache: function () {

        this._generateCachedSprite();

        return this;

    },

    /**
    * Calculates the global position of this DisplayObject, based on the position given.
    *
    * @method PIXI.DisplayObject#toGlobal
    * @param {PIXI.Point} position - The global position to calculate from.
    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.
    */
    toGlobal: function (position) {

        this.updateTransform();

        return this.worldTransform.apply(position);

    },

    /**
    * Calculates the local position of this DisplayObject, relative to another point.
    *
    * @method PIXI.DisplayObject#toLocal
    * @param {PIXI.Point} position - The world origin to calculate from.
    * @param {PIXI.DisplayObject} [from] - An optional DisplayObject to calculate the global position from.
    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.
    */
    toLocal: function (position, from) {

        if (from)
        {
            position = from.toGlobal(position);
        }

        this.updateTransform();

        return this.worldTransform.applyInverse(position);

    },

    /**
    * Internal method.
    *
    * @method PIXI.DisplayObject#_renderCachedSprite
    * @private
    * @param {Object} renderSession - The render session
    */
    _renderCachedSprite: function (renderSession) {

        this._cachedSprite.worldAlpha = this.worldAlpha;

        if (renderSession.gl)
        {
            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);
        }
        else
        {
            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);
        }

    },

    /**
    * Internal method.
    *
    * @method PIXI.DisplayObject#_generateCachedSprite
    * @private
    */
    _generateCachedSprite: function () {

        this._cacheAsBitmap = false;

        var bounds = this.getLocalBounds();

        //  Round it off and force non-zero dimensions
        bounds.width = Math.max(1, Math.ceil(bounds.width));
        bounds.height = Math.max(1, Math.ceil(bounds.height));

        this.updateTransform();

        if (!this._cachedSprite)
        {
            var textureUnit = 0;
            if (this.texture && this.texture.baseTexture && PIXI._enableMultiTextureToggle)
                textureUnit = this.texture.baseTexture.textureIndex;
            var renderTexture = new Phaser.RenderTexture(this.game, bounds.width, bounds.height, undefined, undefined, undefined, undefined, textureUnit);
            this._cachedSprite = new PIXI.Sprite(renderTexture);
            this._cachedSprite.worldTransform = this.worldTransform;
        }
        else
        {
            this._cachedSprite.texture.resize(bounds.width, bounds.height);
        }

        //  Remove filters
        var tempFilters = this._filters;

        this._filters = null;
        this._cachedSprite.filters = tempFilters;

        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;
        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;
        this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, true);
        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);
        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);

        this._filters = tempFilters;

        this._cacheAsBitmap = true;

    },

    /**
    * Destroys a cached Sprite.
    *
    * @method PIXI.DisplayObject#_destroyCachedSprite
    * @private
    */
    _destroyCachedSprite: function () {

        if (!this._cachedSprite)
        {
            return;
        }

        this._cachedSprite.texture.destroy(true);

        this._cachedSprite = null;

    }

};

//  Alias for updateTransform. As used in DisplayObject container, etc.
PIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;

Object.defineProperties(PIXI.DisplayObject.prototype, {

    /**
    * The horizontal position of the DisplayObject, in pixels, relative to its parent.
    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
    * @name PIXI.DisplayObject#x
    * @property {number} x - The horizontal position of the DisplayObject, in pixels, relative to its parent.
    */
    'x': {

        get: function () {

            return this.position.x;

        },

        set: function (value) {

            this.position.x = value;

        }

    },

    /**
    * The vertical position of the DisplayObject, in pixels, relative to its parent.
    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
    * @name PIXI.DisplayObject#y
    * @property {number} y - The vertical position of the DisplayObject, in pixels, relative to its parent.
    */
    'y': {

        get: function () {

            return this.position.y;

        },

        set: function (value) {

            this.position.y = value;

        }

    },

    /**
    * Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.
    * @name PIXI.DisplayObject#worldVisible
    * @property {boolean} worldVisible - Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.
    */
    'worldVisible': {

        get: function () {

            if (!this.visible)
            {
                return false;
            }
            else
            {
                var item = this.parent;

                if (!item)
                {
                    return this.visible;
                }
                else
                {
                    do
                    {
                        if (!item.visible)
                        {
                            return false;
                        }

                        item = item.parent;
                    }
                    while (item);

                }

                return true;
            }

        }

    },

    /**
    * Sets a mask for this DisplayObject. A mask is an instance of a Graphics object.
    * When applied it limits the visible area of this DisplayObject to the shape of the mask.
    * Under a Canvas renderer it uses shape clipping. Under a WebGL renderer it uses a Stencil Buffer.
    * To remove a mask, set this property to `null`.
    *
    * @name PIXI.DisplayObject#mask
    * @property {PIXI.Graphics} mask - The mask applied to this DisplayObject. Set to `null` to remove an existing mask.
    */
    'mask': {

        get: function () {

            return this._mask;

        },

        set: function (value) {

            if (this._mask)
            {
                this._mask.isMask = false;
            }

            this._mask = value;

            if (value)
            {
                this._mask.isMask = true;
            }

        }

    },

    /**
    * Sets the filters for this DisplayObject. This is a WebGL only feature, and is ignored by the Canvas
    * Renderer. A filter is a shader applied to this DisplayObject. You can modify the placement of the filter
    * using `DisplayObject.filterArea`.
    *
    * To remove filters, set this property to `null`.
    *
    * Note: You cannot have a filter set, and a MULTIPLY Blend Mode active, at the same time. Setting a
    * filter will reset this DisplayObjects blend mode to NORMAL.
    *
    * @name PIXI.DisplayObject#filters
    * @property {Array} filters - An Array of Phaser.Filter objects, or objects that extend them.
    */
    'filters': {

        get: function () {

            return this._filters;

        },

        set: function (value) {

            if (Array.isArray(value))
            {
                //  Put all the passes in one place.
                var passes = [];

                for (var i = 0; i < value.length; i++)
                {
                    var filterPasses = value[i].passes;

                    for (var j = 0; j < filterPasses.length; j++)
                    {
                        passes.push(filterPasses[j]);
                    }
                }

                //  Needed any more?
                this._filterBlock = { target: this, filterPasses: passes };
            }

            this._filters = value;

            if (this.blendMode && this.blendMode === PIXI.blendModes.MULTIPLY)
            {
                this.blendMode = PIXI.blendModes.NORMAL;
            }

        }

    },

    /**
    * Sets if this DisplayObject should be cached as a bitmap.
    *
    * When invoked it will take a snapshot of the DisplayObject, as it is at that moment, and store it
    * in a RenderTexture. This is then used whenever this DisplayObject is rendered. It can provide a
    * performance benefit for complex, but static, DisplayObjects. I.e. those with lots of children.
    *
    * Cached Bitmaps do not track their parents. If you update a property of this DisplayObject, it will not
    * re-generate the cached bitmap automatically. To do that you need to call `DisplayObject.updateCache`.
    *
    * To remove a cached bitmap, set this property to `null`.
    *
    * @name PIXI.DisplayObject#cacheAsBitmap
    * @property {boolean} cacheAsBitmap - Cache this DisplayObject as a Bitmap. Set to `null` to remove an existing cached bitmap.
    */
    'cacheAsBitmap': {

        get: function () {

            return this._cacheAsBitmap;

        },

        set: function (value) {

            if (this._cacheAsBitmap === value)
            {
                return;
            }

            if (value)
            {
                this._generateCachedSprite();
            }
            else
            {
                this._destroyCachedSprite();
            }

            this._cacheAsBitmap = value;

        }

    }

});

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A DisplayObjectContainer represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 * @class DisplayObjectContainer
 * @extends DisplayObject
 * @constructor
 */
PIXI.DisplayObjectContainer = function () {

    PIXI.DisplayObject.call(this);

    /**
     * [read-only] The array of children of this container.
     *
     * @property children
     * @type Array(DisplayObject)
     * @readOnly
     */
    this.children = [];

    /**
    * If `ignoreChildInput`  is `false` it will allow this objects _children_ to be considered as valid for Input events.
    * 
    * If this property is `true` then the children will _not_ be considered as valid for Input events.
    * 
    * Note that this property isn't recursive: only immediate children are influenced, it doesn't scan further down.
    * @property {boolean} ignoreChildInput
    * @default
    */
    this.ignoreChildInput = false;
    
};

PIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );
PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;

/**
 * Adds a child to the container.
 *
 * @method addChild
 * @param child {DisplayObject} The DisplayObject to add to the container
 * @return {DisplayObject} The child that was added.
 */
PIXI.DisplayObjectContainer.prototype.addChild = function (child) {

    return this.addChildAt(child, this.children.length);

};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @method addChildAt
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 * @return {DisplayObject} The child that was added.
 */
PIXI.DisplayObjectContainer.prototype.addChildAt = function (child, index) {

    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }

};

/**
 * Swaps the position of 2 Display Objects within this container.
 *
 * @method swapChildren
 * @param child {DisplayObject}
 * @param child2 {DisplayObject}
 */
PIXI.DisplayObjectContainer.prototype.swapChildren = function (child, child2) {

    if (child === child2)
    {
        return;
    }

    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);

    if (index1 < 0 || index2 < 0)
    {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;

};

/**
 * Returns the index position of a child DisplayObject instance
 *
 * @method getChildIndex
 * @param child {DisplayObject} The DisplayObject instance to identify
 * @return {Number} The index position of the child display object to identify
 */
PIXI.DisplayObjectContainer.prototype.getChildIndex = function (child) {

    var index = this.children.indexOf(child);

    if (index === -1)
    {
        throw new Error('The supplied DisplayObject must be a child of the caller');
    }

    return index;

};

/**
 * Changes the position of an existing child in the display object container
 *
 * @method setChildIndex
 * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number
 * @param index {Number} The resulting index number for the child display object
 */
PIXI.DisplayObjectContainer.prototype.setChildIndex = function (child, index) {

    if (index < 0 || index >= this.children.length)
    {
        throw new Error('The supplied index is out of bounds');
    }

    var currentIndex = this.getChildIndex(child);

    this.children.splice(currentIndex, 1); //remove from old position
    this.children.splice(index, 0, child); //add at new position

};

/**
 * Returns the child at the specified index
 *
 * @method getChildAt
 * @param index {Number} The index to get the child from
 * @return {DisplayObject} The child at the given index, if any.
 */
PIXI.DisplayObjectContainer.prototype.getChildAt = function (index) {

    if (index < 0 || index >= this.children.length)
    {
        throw new Error('getChildAt: Supplied index '+ index +' does not exist in the child list, or the supplied DisplayObject must be a child of the caller');
    }

    return this.children[index];
    
};

/**
 * Removes a child from the container.
 *
 * @method removeChild
 * @param child {DisplayObject} The DisplayObject to remove
 * @return {DisplayObject} The child that was removed.
 */
PIXI.DisplayObjectContainer.prototype.removeChild = function (child) {

    var index = this.children.indexOf(child);

    if (index === -1)
    {
        return;
    }
    
    return this.removeChildAt(index);

};

/**
 * Removes a child from the specified index position.
 *
 * @method removeChildAt
 * @param index {Number} The index to get the child from
 * @return {DisplayObject} The child that was removed.
 */
PIXI.DisplayObjectContainer.prototype.removeChildAt = function (index) {

    var child = this.getChildAt(index);

    if (child)
    {
        child.parent = undefined;

        this.children.splice(index, 1);
    }

    return child;

};

/**
* Removes all children from this container that are within the begin and end indexes.
*
* @method removeChildren
* @param beginIndex {Number} The beginning position. Default value is 0.
* @param endIndex {Number} The ending position. Default value is size of the container.
*/
PIXI.DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {

    if (beginIndex === undefined) { beginIndex = 0; }
    if (endIndex === undefined) { endIndex = this.children.length; }

    var range = endIndex - beginIndex;

    if (range > 0 && range <= endIndex)
    {
        var removed = this.children.splice(beginIndex, range);

        for (var i = 0; i < removed.length; i++)
        {
            var child = removed[i];
            child.parent = undefined;
        }

        return removed;
    }
    else if (range === 0 && this.children.length === 0)
    {
        return [];
    }
    else
    {
        throw new Error( 'removeChildren: Range Error, numeric values are outside the acceptable range' );
    }

};

/*
 * Updates the transform on all children of this container for rendering
 *
 * @method updateTransform
 * @private
 */
PIXI.DisplayObjectContainer.prototype.updateTransform = function () {

    if (!this.visible)
    {
        return;
    }

    this.displayObjectUpdateTransform();

    if (this._cacheAsBitmap)
    {
        return;
    }

    for (var i = 0; i < this.children.length; i++)
    {
        this.children[i].updateTransform();
    }

};

// performance increase to avoid using call.. (10x faster)
PIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform;

/**
 * Retrieves the global bounds of the displayObjectContainer as a rectangle. The bounds calculation takes all visible children into consideration.
 *
 * @method getBounds
 * @param {PIXI.DisplayObject|PIXI.Matrix} [targetCoordinateSpace] Returns a rectangle that defines the area of the display object relative to the coordinate system of the targetCoordinateSpace object.
 * @return {Rectangle} The rectangular bounding area
 */
PIXI.DisplayObjectContainer.prototype.getBounds = function (targetCoordinateSpace) {

    var isTargetCoordinateSpaceDisplayObject = (targetCoordinateSpace && targetCoordinateSpace instanceof PIXI.DisplayObject);
    var isTargetCoordinateSpaceThisOrParent = true;

    if (!isTargetCoordinateSpaceDisplayObject) 
	{
        targetCoordinateSpace = this;
    } 
	else if (targetCoordinateSpace instanceof PIXI.DisplayObjectContainer) 
	{
        isTargetCoordinateSpaceThisOrParent = targetCoordinateSpace.contains(this);
    } 
	else 
	{
        isTargetCoordinateSpaceThisOrParent = false;
    }

    var i;

    if (isTargetCoordinateSpaceDisplayObject)
    {
        var matrixCache = targetCoordinateSpace.worldTransform;

        targetCoordinateSpace.worldTransform = PIXI.identityMatrix;

        for (i = 0; i < targetCoordinateSpace.children.length; i++) 
		{
            targetCoordinateSpace.children[i].updateTransform();
        }
    }

    var minX = Infinity;
    var minY = Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var childBounds;
    var childMaxX;
    var childMaxY;

    var childVisible = false;

    for (i = 0; i < this.children.length; i++)
    {
        var child = this.children[i];

        if (!child.visible)
        {
            continue;
        }

        childVisible = true;

        childBounds = this.children[i].getBounds();

        minX = (minX < childBounds.x) ? minX : childBounds.x;
        minY = (minY < childBounds.y) ? minY : childBounds.y;

        childMaxX = childBounds.width + childBounds.x;
        childMaxY = childBounds.height + childBounds.y;

        maxX = (maxX > childMaxX) ? maxX : childMaxX;
        maxY = (maxY > childMaxY) ? maxY : childMaxY;
    }

    var bounds = this._bounds;

    if (!childVisible) 
	{
        bounds = new PIXI.Rectangle();

        var w0 = bounds.x;
        var w1 = bounds.width + bounds.x;

        var h0 = bounds.y;
        var h1 = bounds.height + bounds.y;

        var worldTransform = this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 = a * w1 + c * h0 + tx;
        var y4 = d * h0 + b * w1 + ty;

        maxX = x1;
        maxY = y1;

        minX = x1;
        minY = y1;

        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
    }

    bounds.x = minX;
    bounds.y = minY;
    bounds.width = maxX - minX;
    bounds.height = maxY - minY;

    if (isTargetCoordinateSpaceDisplayObject) 
	{
        targetCoordinateSpace.worldTransform = matrixCache;

        for (i = 0; i < targetCoordinateSpace.children.length; i++) 
		{
            targetCoordinateSpace.children[i].updateTransform();
        }
    }

    if (!isTargetCoordinateSpaceThisOrParent) 
	{
        var targetCoordinateSpaceBounds = targetCoordinateSpace.getBounds();

        bounds.x -= targetCoordinateSpaceBounds.x;
        bounds.y -= targetCoordinateSpaceBounds.y;
    }

    return bounds;

};

/**
 * Retrieves the non-global local bounds of the displayObjectContainer as a rectangle without any transformations. The calculation takes all visible children into consideration.
 *
 * @method getLocalBounds
 * @return {Rectangle} The rectangular bounding area
 */
PIXI.DisplayObjectContainer.prototype.getLocalBounds = function () {

    return this.getBounds(this);

};

/**
* Determines whether the specified display object is a child of the DisplayObjectContainer instance or the instance itself.
*
* @method contains
* @param {DisplayObject} child
* @returns {boolean}
*/
PIXI.DisplayObjectContainer.prototype.contains = function (child) {

    if (!child)
    {
        return false;
    }
    else if (child === this) 
	{
        return true;
    }
    else 
	{
        return this.contains(child.parent);
    }
};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderWebGL = function (renderSession) {

    if (!this.visible || this.alpha <= 0)
    {
        return;
    }
    
    if (this._cacheAsBitmap)
    {
        this._renderCachedSprite(renderSession);
        return;
    }
    
    var i;

    if (this._mask || this._filters)
    {
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters)
        {
            renderSession.spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if (this._mask)
        {
            renderSession.spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            renderSession.spriteBatch.start();
        }

        // simple render children!
        for (i = 0; i < this.children.length; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        renderSession.spriteBatch.stop();

        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
        if (this._filters) renderSession.filterManager.popFilter();
        
        renderSession.spriteBatch.start();
    }
    else
    {
        // simple render children!
        for (i = 0; i < this.children.length; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }
    }

};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession} 
* @private
*/
PIXI.DisplayObjectContainer.prototype._renderCanvas = function (renderSession) {

    if (this.visible === false || this.alpha === 0)
    {
        return;
    }

    if (this._cacheAsBitmap)
    {
        this._renderCachedSprite(renderSession);
        return;
    }

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession);
    }

    for (var i = 0; i < this.children.length; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession);
    }

};

/**
 * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {

    get: function() {
        return this.getLocalBounds().width * this.scale.x;
    },

    set: function(value) {
        
        var width = this.getLocalBounds().width;

        if (width !== 0)
        {
            this.scale.x = value / width;
        }
        else
        {
            this.scale.x = 1;
        }
        
        this._width = value;
    }
});

/**
 * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {

    get: function() {
        return this.getLocalBounds().height * this.scale.y;
    },

    set: function(value) {

        var height = this.getLocalBounds().height;

        if (height !== 0)
        {
            this.scale.y = value / height;
        }
        else
        {
            this.scale.y = 1;
        }

        this._height = value;
    }

});


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * @class Sprite
 * @extends DisplayObjectContainer
 * @constructor
 * @param texture {Texture} The texture for this sprite
 */
PIXI.Sprite = function (texture) {

    PIXI.DisplayObjectContainer.call(this);

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting than anchor to 0.5,0.5 means the textures origin is centered
     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
     *
     * @property anchor
     * @type Point
     */
    this.anchor = new PIXI.Point();

    /**
     * The texture that the sprite is using
     *
     * @property texture
     * @type Texture
     */
    this.texture = texture || PIXI.Texture.emptyTexture;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @property _width
     * @type Number
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @property _height
     * @type Number
     * @private
     */
    this._height = 0;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @property tint
     * @type Number
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @property cachedTint
     * @private
     * @type Number
     * @default -1
     */
    this.cachedTint = -1;

    /**
     * A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)
     *
     * @property tintedTexture
     * @type Canvas
     * @default null
     */
    this.tintedTexture = null;

    /**
     * The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.
     *
     * Warning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.
     *
     * @property blendMode
     * @type Number
     * @default PIXI.blendModes.NORMAL;
     */
    this.blendMode = PIXI.blendModes.NORMAL;

    /**
     * The shader that will be used to render this Sprite.
     * Set to null to remove a current shader.
     *
     * @property shader
     * @type Phaser.Filter
     * @default null
     */
    this.shader = null;

    /**
    * Controls if this Sprite is processed by the core Phaser game loops and Group loops.
    *
    * @property exists
    * @type Boolean
    * @default true
    */
    this.exists = true;

    if (this.texture.baseTexture.hasLoaded)
    {
        this.onTextureUpdate();
    }

    this.renderable = true;

};

// constructor
PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
PIXI.Sprite.prototype.constructor = PIXI.Sprite;

/**
 * The width of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property width
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'width', {

    get: function() {
        return this.scale.x * this.texture.frame.width;
    },

    set: function(value) {
        this.scale.x = value / this.texture.frame.width;
        this._width = value;
    }

});

/**
 * The height of the sprite, setting this will actually modify the scale to achieve the value set
 *
 * @property height
 * @type Number
 */
Object.defineProperty(PIXI.Sprite.prototype, 'height', {

    get: function() {
        return  this.scale.y * this.texture.frame.height;
    },

    set: function(value) {
        this.scale.y = value / this.texture.frame.height;
        this._height = value;
    }

});

/**
 * Sets the texture of the sprite. Be warned that this doesn't remove or destroy the previous
 * texture this Sprite was using.
 *
 * @method setTexture
 * @param texture {Texture} The PIXI texture that is displayed by the sprite
 * @param [destroy=false] {boolean} Call Texture.destroy on the current texture before replacing it with the new one?
 */
PIXI.Sprite.prototype.setTexture = function(texture, destroyBase)
{
    if (destroyBase !== undefined)
    {
        this.texture.baseTexture.destroy();
    }

    //  Over-ridden by loadTexture as needed
    this.texture.baseTexture.skipRender = false;
    this.texture = texture;
    this.texture.valid = true;
    this.cachedTint = -1;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @method onTextureUpdate
 * @param event
 * @private
 */
PIXI.Sprite.prototype.onTextureUpdate = function()
{
    // so if _width is 0 then width was not set..
    if (this._width) this.scale.x = this._width / this.texture.frame.width;
    if (this._height) this.scale.y = this._height / this.texture.frame.height;
};

/**
* Returns the bounds of the Sprite as a rectangle.
* The bounds calculation takes the worldTransform into account.
*
* It is important to note that the transform is not updated when you call this method.
* So if this Sprite is the child of a Display Object which has had its transform
* updated since the last render pass, those changes will not yet have been applied
* to this Sprites worldTransform. If you need to ensure that all parent transforms
* are factored into this getBounds operation then you should call `updateTransform`
* on the root most object in this Sprites display list first.
*
* @method getBounds
* @param matrix {Matrix} the transformation matrix of the sprite
* @return {Rectangle} the framing rectangle
*/
PIXI.Sprite.prototype.getBounds = function(matrix)
{
    var width = this.texture.frame.width;
    var height = this.texture.frame.height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = matrix || this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    if (b === 0 && c === 0)
    {
        // scale may be negative!
        if (a < 0)
        {
            a *= -1;
            var temp = w0;
            w0 = -w1;
            w1 = -temp; 
        }

        if (d < 0)
        {
            d *= -1;
            var temp = h0;
            h0 = -h1;
            h1 = -temp; 
        }

        // this means there is no rotation going on right? RIGHT?
        // if thats the case then we can avoid checking the bound values! yay         
        minX = a * w1 + tx;
        maxX = a * w0 + tx;
        minY = d * h1 + ty;
        maxY = d * h0 + ty;
    }
    else
    {
        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        minX = x1 < minX ? x1 : minX;
        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y1 < minY ? y1 : minY;
        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x1 > maxX ? x1 : maxX;
        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y1 > maxY ? y1 : maxY;
        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;
    }

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
 * Retrieves the non-global local bounds of the Sprite as a rectangle. The calculation takes all visible children into consideration.
 *
 * @method getLocalBounds
 * @return {Rectangle} The rectangular bounding area
 */
PIXI.Sprite.prototype.getLocalBounds = function () {

    var matrixCache = this.worldTransform;

    this.worldTransform = PIXI.identityMatrix;

    for (var i = 0; i < this.children.length; i++)
    {
        this.children[i].updateTransform();
    }

    var bounds = this.getBounds();

    this.worldTransform = matrixCache;

    for (i = 0; i < this.children.length; i++)
    {
        this.children[i].updateTransform();
    }

    return bounds;

};

/**
* Renders the object using the WebGL renderer
*
* @method _renderWebGL
* @param renderSession {RenderSession}
* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.
* @private
*/
PIXI.Sprite.prototype._renderWebGL = function(renderSession, matrix)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.alpha <= 0 || !this.renderable) return;

    //  They provided an alternative rendering matrix, so use it
    var wt = this.worldTransform;

    if (matrix)
    {
        wt = matrix;
    }

    //  A quick check to see if this element has a mask or a filter.
    if (this._mask || this._filters)
    {
        var spriteBatch = renderSession.spriteBatch;

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters)
        {
            spriteBatch.flush();
            renderSession.filterManager.pushFilter(this._filterBlock);
        }

        if (this._mask)
        {
            spriteBatch.stop();
            renderSession.maskManager.pushMask(this.mask, renderSession);
            spriteBatch.start();
        }

        // add this sprite to the batch
        spriteBatch.render(this);

        // now loop through the children and make sure they get rendered
        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i]._renderWebGL(renderSession);
        }

        // time to stop the sprite batch as either a mask element or a filter draw will happen next
        spriteBatch.stop();

        if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession);
        if (this._filters) renderSession.filterManager.popFilter();

        spriteBatch.start();
    }
    else
    {
        renderSession.spriteBatch.render(this);

        //  Render children!
        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i]._renderWebGL(renderSession, wt);
        }

    }
};

/**
* Renders the object using the Canvas renderer
*
* @method _renderCanvas
* @param renderSession {RenderSession}
* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.
* @private
*/
PIXI.Sprite.prototype._renderCanvas = function(renderSession, matrix)
{
    // If the sprite is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.alpha === 0 || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
    {
        return;
    }

    var wt = this.worldTransform;

    //  If they provided an alternative rendering matrix then use it
    if (matrix)
    {
        wt = matrix;
    }

    if (this.blendMode !== renderSession.currentBlendMode)
    {
        renderSession.currentBlendMode = this.blendMode;
        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];
    }

    if (this._mask)
    {
        renderSession.maskManager.pushMask(this._mask, renderSession);
    }

    //  Ignore null sources
    if (!this.texture.valid)
    {
        //  Update the children and leave
        for (var i = 0; i < this.children.length; i++)
        {
            this.children[i]._renderCanvas(renderSession);
        }

        if (this._mask)
        {
            renderSession.maskManager.popMask(renderSession);
        }

        return;
    }

    var resolution = this.texture.baseTexture.resolution / renderSession.resolution;

    renderSession.context.globalAlpha = this.worldAlpha;

    //  If smoothingEnabled is supported and we need to change the smoothing property for this texture
    if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)
    {
        renderSession.scaleMode = this.texture.baseTexture.scaleMode;
        renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);
    }

    //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions
    var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
    var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;

    var tx = (wt.tx * renderSession.resolution) + renderSession.shakeX;
    var ty = (wt.ty * renderSession.resolution) + renderSession.shakeY;

    var cw = this.texture.crop.width;
    var ch = this.texture.crop.height;

    if (this.texture.rotated)
    {
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var e = cw;
        
        // Offset before rotating
        tx = wt.c * ch + tx;
        ty = wt.d * ch + ty;
        
        // Rotate matrix by 90 degrees
        // We use precalculated values for sine and cosine of rad(90)
        wt.a = a * 6.123233995736766e-17 + -c;
        wt.b = b * 6.123233995736766e-17 + -d;
        wt.c = a + c * 6.123233995736766e-17;
        wt.d = b + d * 6.123233995736766e-17;

        // Update cropping dimensions.
        cw = ch;
        ch = e;
    }

    //  Allow for pixel rounding
    if (renderSession.roundPixels)
    {
        renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx | 0, ty | 0);
        dx |= 0;
        dy |= 0;
    }
    else
    {
        renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty);
    }

    dx /= resolution;
    dy /= resolution;

    if (this.tint !== 0xFFFFFF)
    {
        if (this.texture.requiresReTint || this.cachedTint !== this.tint)
        {
            this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);

            this.cachedTint = this.tint;
            this.texture.requiresReTint = false;
        }

        renderSession.context.drawImage(this.tintedTexture, 0, 0, cw, ch, dx, dy, cw / resolution, ch / resolution);
    }
    else
    {
        var cx = this.texture.crop.x;
        var cy = this.texture.crop.y;
        
        cw = Math.floor(cw)
        ch = Math.floor(ch)

        renderSession.context.drawImage(this.texture.baseTexture.source, cx, cy, cw, ch, dx, dy, cw / resolution, ch / resolution);
    }

    for (var i = 0; i < this.children.length; i++)
    {
        this.children[i]._renderCanvas(renderSession);
    }

    if (this._mask)
    {
        renderSession.maskManager.popMask(renderSession);
    }

};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @method initDefaultShaders
* @static
* @private
*/
PIXI.initDefaultShaders = function()
{
};

/**
* @method CompileVertexShader
* @static
* @param gl {WebGLContext} the current WebGL drawing context
* @param shaderSrc {Array}
* @return {Any}
*/
PIXI.CompileVertexShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);
};

/**
* @method CompileFragmentShader
* @static
* @param gl {WebGLContext} the current WebGL drawing context
* @param shaderSrc {Array}
* @return {Any}
*/
PIXI.CompileFragmentShader = function(gl, shaderSrc)
{
    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);
};

/**
* @method _CompileShader
* @static
* @private
* @param gl {WebGLContext} the current WebGL drawing context
* @param shaderSrc {Array}
* @param shaderType {Number}
* @return {Any}
*/
PIXI._CompileShader = function(gl, shaderSrc, shaderType)
{
    var src = shaderSrc;

    if (Array.isArray(shaderSrc))
    {
        src = shaderSrc.join("\n");
    }

    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        window.console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

/**
* @method compileProgram
* @static
* @param gl {WebGLContext} the current WebGL drawing context
* @param vertexSrc {Array}
* @param fragmentSrc {Array}
* @return {Any}
*/
PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)
{
    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);
    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);

    var shaderProgram = gl.createProgram();

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
    {
        window.console.log(gl.getProgramInfoLog(shaderProgram));
        window.console.log("Could not initialise shaders");
    }

    return shaderProgram;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * @author Richard Davey http://www.photonstorm.com @photonstorm
 */

/**
* @class PixiShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PixiShader = function(gl)
{
    /**
     * @property _UID
     * @type Number
     * @private
     */
    this._UID = Phaser._UID++;

    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * The WebGL program.
     * @property program
     * @type Any
     */
    this.program = null;

    /**
     * The fragment shader.
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = null;

    /**
     * A local texture counter for multi-texture shaders.
     * @property textureCount
     * @type Number
     */
    this.textureCount = 0;

    /**
     * A local flag
     * @property firstRun
     * @type Boolean
     * @private
     */
    this.firstRun = true;

    /**
     * A dirty flag
     * @property dirty
     * @type Boolean
     */
    this.dirty = true;

    /**
     * Uniform attributes cache.
     * @property attributes
     * @type Array
     * @private
     */
    this.attributes = [];

    this.init();
};

PIXI.PixiShader.prototype.constructor = PIXI.PixiShader;

PIXI.PixiShader.prototype.initMultitexShader = function () {
    var gl = this.gl;
    this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    var dynamicIfs = '\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n'
    for (var index = 1; index < this.MAX_TEXTURES; ++index)
    {
        dynamicIfs += '\telse if (vTextureIndex == ' + 
                    index + '.0) gl_FragColor = texture2D(uSamplerArray[' + 
                    index + '], vTextureCoord) * vColor;\n'
    }
    this.fragmentSrc = [
        '// PixiShader Fragment Shader.',
        'precision lowp float;',
        'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',
        'varying vec2 vTextureCoord;',
        'varying vec4 vColor;',
        'varying float vTextureIndex;',
        'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',
        // Blue color means that you are trying to bound
        // a texture out of the limits of the hardware.
        'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',
        // If you get a red color means you are out of memory
        // or in some way corrupted the vertex buffer.
        'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',
        'void main(void) {',
        dynamicIfs,
        '   else if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) gl_FragColor = BLUE;',
        '   else if(isnan(vTextureIndex)) gl_FragColor = RED;',
        '}'
    ];

    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);

    gl.useProgram(program);

    // get and store the uniforms for the shader
    //this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.uSamplerArray = gl.getUniformLocation(program, 'uSamplerArray[0]');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');

    var indices = [];
    // HACK: we bind an empty texture to avoid WebGL warning spam.
    var tempTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tempTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
    for (var i = 0; i < this.MAX_TEXTURES; ++i) {
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        indices.push(i);
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1iv(this.uSamplerArray, indices);

    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];

    // End worst hack eva //

    // add those custom shaders!
    for (var key in this.uniforms)
    {
        // get the uniform locations..
        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
    }

    this.initUniforms();

    this.program = program;
};

PIXI.PixiShader.prototype.initDefaultShader = function () {

    if (this.fragmentSrc === null) {
        this.fragmentSrc = [
            'precision lowp float;',
            'varying vec2 vTextureCoord;',
            'varying vec4 vColor;',
            'varying float vTextureIndex;',
            'uniform sampler2D uSampler;',
            'void main(void) {',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
            '}'
        ];
    }

    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);

    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = gl.getUniformLocation(program, 'uSampler');
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');


    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if(this.colorAttribute === -1)
    {
        this.colorAttribute = 2;
    }

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];

    // End worst hack eva //

    // add those custom shaders!
    for (var key in this.uniforms)
    {
        // get the uniform locations..
        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);
    }

    this.initUniforms();

    this.program = program;
};
/**
* Initialises the shader.
*
* @method init
*/
PIXI.PixiShader.prototype.init = function(usingFilter)
{
    if (PIXI._enableMultiTextureToggle && !usingFilter) {
        this.initMultitexShader();
    } else {
        this.initDefaultShader();
    }  
};

/**
* Initialises the shader uniform values.
*
* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/
* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
*
* @method initUniforms
*/
PIXI.PixiShader.prototype.initUniforms = function()
{
    this.textureCount = 1;
    var gl = this.gl;
    var uniform;

    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];

        var type = uniform.type;

        if (type === 'sampler2D')
        {
            uniform._init = false;

            if (uniform.value !== null)
            {
                this.initSampler2D(uniform);
            }
        }
        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')
        {
            //  These require special handling
            uniform.glMatrix = true;
            uniform.glValueLength = 1;

            if (type === 'mat2')
            {
                uniform.glFunc = gl.uniformMatrix2fv;
            }
            else if (type === 'mat3')
            {
                uniform.glFunc = gl.uniformMatrix3fv;
            }
            else if (type === 'mat4')
            {
                uniform.glFunc = gl.uniformMatrix4fv;
            }
        }
        else
        {
            //  GL function reference
            uniform.glFunc = gl['uniform' + type];

            if (type === '2f' || type === '2i')
            {
                uniform.glValueLength = 2;
            }
            else if (type === '3f' || type === '3i')
            {
                uniform.glValueLength = 3;
            }
            else if (type === '4f' || type === '4i')
            {
                uniform.glValueLength = 4;
            }
            else
            {
                uniform.glValueLength = 1;
            }
        }
    }

};

/**
* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
*
* @method initSampler2D
*/
PIXI.PixiShader.prototype.initSampler2D = function(uniform)
{
    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    // No need to do string manipulation for this.
    gl.activeTexture(gl.TEXTURE0 + this.textureCount);
    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);

    //  Extended texture data
    if (uniform.textureData)
    {
        var data = uniform.textureData;

        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;
        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;
        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;
        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;
        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;

        if (data.repeat)
        {
            wrapS = gl.REPEAT;
            wrapT = gl.REPEAT;
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);

        if (data.width)
        {
            var width = (data.width) ? data.width : 512;
            var height = (data.height) ? data.height : 2;
            var border = (data.border) ? data.border : 0;

            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);
        }
        else
        {
            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);
            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
    }

    gl.uniform1i(uniform.uniformLocation, this.textureCount);

    uniform._init = true;

    this.textureCount++;

};

/**
* Updates the shader uniform values.
*
* @method syncUniforms
*/
PIXI.PixiShader.prototype.syncUniforms = function()
{
    this.textureCount = 1;
    var uniform;
    var gl = this.gl;

    //  This would probably be faster in an array and it would guarantee key order
    for (var key in this.uniforms)
    {
        uniform = this.uniforms[key];
        if (uniform.glValueLength === 1)
        {
            if (uniform.glMatrix === true)
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);
            }
            else
            {
                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);
            }
        }
        else if (uniform.glValueLength === 2)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);
        }
        else if (uniform.glValueLength === 3)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);
        }
        else if (uniform.glValueLength === 4)
        {
            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);
        }
        else if (uniform.type === 'sampler2D')
        {
            if (uniform._init)
            {
                gl.activeTexture(gl['TEXTURE' + this.textureCount]);

                if(uniform.value.baseTexture._dirty[gl.id])
                {
                    PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture);
                }
                else
                {
                    // bind the current texture
                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);
                }

                //  gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));
                gl.uniform1i(uniform.uniformLocation, this.textureCount);
                this.textureCount++;
            }
            else
            {
                this.initSampler2D(uniform);
            }
        }
    }

};

/**
* Destroys the shader.
*
* @method destroy
*/
PIXI.PixiShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
* The Default Vertex shader source.
*
* @property defaultVertexSrc
* @type String
*/
PIXI.PixiShader.defaultVertexSrc = [
    '// PixiShader Vertex Shader',
    '// With multi-texture rendering',
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec4 aColor;',
    'attribute float aTextureIndex;',

    'uniform vec2 projectionVector;',
    'uniform vec2 offsetVector;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',
    'varying float vTextureIndex;',

    'const vec2 center = vec2(-1.0, 1.0);',

    'void main(void) {',
    '   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);',
    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
    '   vTextureIndex = aTextureIndex;',
    '}'
];
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @class PixiFastShader
 * @constructor
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.PixiFastShader = function (gl) {
    /**
     * @property _UID
     * @type Number
     * @private
     */
    this._UID = Phaser._UID++;

    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * The WebGL program.
     * @property program
     * @type Any
     */
    this.program = null;

    if (PIXI._enableMultiTextureToggle) {
        var gl = this.gl;
        this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var dynamicIfs = '\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n'
        for (var index = 1; index < this.MAX_TEXTURES; ++index)
        {
            dynamicIfs += '\telse if (vTextureIndex == ' + 
                        index + '.0) gl_FragColor = texture2D(uSamplerArray[' + 
                        index + '], vTextureCoord) * vColor;\n'
        }

        /**
         * The fragment shader.
         * @property fragmentSrc
         * @type Array
         */
        this.fragmentSrc = [
            '// PixiFastShader Fragment Shader.',
            'precision lowp float;',
            'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',
            'varying vec2 vTextureCoord;',
            'varying float vColor;',
            'varying float vTextureIndex;',
            'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',
            // Blue color means that you are trying to bound
            // a texture out of the limits of the hardware.
            'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',
            // If you get a red color means you are out of memory
            // or in some way corrupted the vertex buffer.
            'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',
            'void main(void) {',
            dynamicIfs,
            '   else if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) gl_FragColor = BLUE;',
            '   else if(isnan(vTextureIndex)) gl_FragColor = RED;',       
            '}'
        ];
    } else {
        this.fragmentSrc = [
            '// PixiFastShader Fragment Shader.',
            'precision lowp float;',
            'varying vec2 vTextureCoord;',
            'varying float vColor;',
            'varying float vTextureIndex;',
            'uniform sampler2D uSampler;',
            'void main(void) {',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;',
            '}'
        ];
    }    

    /**
     * The vertex shader.
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc = [
        '// PixiFastShader Vertex Shader.',
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aPositionCoord;',
        'attribute vec2 aScale;',
        'attribute float aRotation;',
        'attribute vec2 aTextureCoord;',
        'attribute float aColor;',
        'attribute float aTextureIndex;',

        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform mat3 uMatrix;',

        'varying vec2 vTextureCoord;',
        'varying float vColor;',
        'varying float vTextureIndex;',

        'const vec2 center = vec2(-1.0, 1.0);',

        'void main(void) {',
        '   vec2 v;',
        '   vec2 sv = aVertexPosition * aScale;',
        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',
        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',
        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',
        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
        '   vTextureIndex = aTextureIndex;',
        //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',
        '   vColor = aColor;',
        '}'
    ];

    /**
     * A local texture counter for multi-texture shaders.
     * @property textureCount
     * @type Number
     */
    this.textureCount = 0;

    this.init();
};

PIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader;

/**
 * Initialises the shader.
 * 
 * @method init
 */
PIXI.PixiFastShader.prototype.init = function () {

    var gl = this.gl;
    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);

    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = PIXI._enableMultiTextureToggle ?
                         gl.getUniformLocation(program, 'uSamplerArray[0]') :
                         gl.getUniformLocation(program, 'uSampler');

    if (PIXI._enableMultiTextureToggle) {
        var indices = [];
        // HACK: we bind an empty texture to avoid WebGL warning spam.
        var tempTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        for (var i = 0; i < this.MAX_TEXTURES; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            indices.push(i);
        }
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1iv(this.uSampler, indices);
    }
    
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.dimensions = gl.getUniformLocation(program, 'dimensions');
    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');

    this.aScale = gl.getAttribLocation(program, 'aScale');
    this.aRotation = gl.getAttribLocation(program, 'aRotation');

    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');

    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its somthing to do with the current state of the gl context.
    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    if (this.colorAttribute === -1) {
        this.colorAttribute = 2;
    }

    this.attributes = [
        this.aVertexPosition,
        this.aPositionCoord,
        this.aScale,
        this.aRotation,
        this.aTextureCoord,
        this.colorAttribute,
        this.aTextureIndex
    ];

    // End worst hack eva //

    this.program = program;
};

/**
 * Destroys the shader.
 * 
 * @method destroy
 */
PIXI.PixiFastShader.prototype.destroy = function () {
    this.gl.deleteProgram(this.program);
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class StripShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.StripShader = function(gl)
{
    /**
     * @property _UID
     * @type Number
     * @private
     */
    this._UID = Phaser._UID++;
    
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * The WebGL program.
     * @property program
     * @type Any
     */
    this.program = null;

    if (PIXI._enableMultiTextureToggle) {
        var gl = this.gl;
        this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var dynamicIfs = '\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);\n'
        for (var index = 1; index < this.MAX_TEXTURES; ++index)
        {
            dynamicIfs += '\telse if (vTextureIndex == ' + 
                        index + '.0) gl_FragColor = texture2D(uSamplerArray[' + 
                        index + '], vTextureCoord) ;\n'
        }


        /**
         * The fragment shader.
         * @property fragmentSrc
         * @type Array
         */
        this.fragmentSrc = [
            '//StripShader Fragment Shader.',
            'precision mediump float;',
            'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',
            'varying vec2 vTextureCoord;',
            'varying float vTextureIndex;',
         //   'varying float vColor;',
            'uniform float alpha;',
            'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',
            // Blue color means that you are trying to bound
            // a texture out of the limits of the hardware.
            'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',
            // If you get a red color means you are out of memory
            // or in some way corrupted the vertex buffer.
            'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',
            'void main(void) {',
            dynamicIfs,
            '   else if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) gl_FragColor = BLUE;',
            '   else if(isnan(vTextureIndex)) gl_FragColor = RED;',
            '}'
        ];    
    } else {
        /**
         * The fragment shader.
         * @property fragmentSrc
         * @type Array
         */
        this.fragmentSrc = [
            '//StripShader Fragment Shader.',
            'precision mediump float;',
            'varying vec2 vTextureCoord;',
            'varying float vTextureIndex;',
         //   'varying float vColor;',
            'uniform float alpha;',
            'uniform sampler2D uSampler;',
            'void main(void) {',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord);',
            '}'
        ]; 
    }

    /**
     * The vertex shader.
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        '//StripShader Vertex Shader.',
        'attribute vec2 aVertexPosition;',
        'attribute vec2 aTextureCoord;',
        'attribute float aTextureIndex;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
      //  'uniform float alpha;',
       // 'uniform vec3 tint;',
        'varying vec2 vTextureCoord;',
        'varying float vTextureIndex;',
      //  'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',
        '   vTextureCoord = aTextureCoord;',
        '   vTextureIndex = aTextureIndex;',
       // '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

PIXI.StripShader.prototype.constructor = PIXI.StripShader;

/**
* Initialises the shader.
* 
* @method init
*/
PIXI.StripShader.prototype.init = function()
{
    var gl = this.gl;
    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.uSampler = PIXI._enableMultiTextureToggle ?
                         gl.getUniformLocation(program, 'uSamplerArray[0]') : 
                         gl.getUniformLocation(program, 'uSampler');


    if (PIXI._enableMultiTextureToggle) {
        var indices = [];
        // HACK: we bind an empty texture to avoid WebGL warning spam.
        var tempTexture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        for (var i = 0; i < this.MAX_TEXTURES; ++i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            indices.push(i);
        }
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1iv(this.uSampler, indices); 
    }                         
   
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');
    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');
    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');

    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader.
* 
* @method destroy
*/
PIXI.StripShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class PrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.PrimitiveShader = function(gl)
{
    /**
     * @property _UID
     * @type Number
     * @private
     */
    this._UID = Phaser._UID++;
 
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * The WebGL program.
     * @property program
     * @type Any
     */
    this.program = null;

    /**
     * The fragment shader.
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [
        'precision mediump float;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * The vertex shader.
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        'uniform float alpha;',
        'uniform float flipY;',
        'uniform vec3 tint;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',
        '   vColor = aColor * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

PIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader;

/**
* Initialises the shader.
* 
* @method init
*/
PIXI.PrimitiveShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');
    this.flipY = gl.getUniformLocation(program, 'flipY');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
    this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader.
* 
* @method destroy
*/
PIXI.PrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attributes = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class ComplexPrimitiveShader
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.ComplexPrimitiveShader = function(gl)
{
    /**
     * @property _UID
     * @type Number
     * @private
     */
    this._UID = Phaser._UID++;

    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;

    /**
     * The WebGL program.
     * @property program
     * @type Any
     */
    this.program = null;

    /**
     * The fragment shader.
     * @property fragmentSrc
     * @type Array
     */
    this.fragmentSrc = [

        'precision mediump float;',

        'varying vec4 vColor;',

        'void main(void) {',
        '   gl_FragColor = vColor;',
        '}'
    ];

    /**
     * The vertex shader.
     * @property vertexSrc
     * @type Array
     */
    this.vertexSrc  = [
        'attribute vec2 aVertexPosition;',
        //'attribute vec4 aColor;',
        'uniform mat3 translationMatrix;',
        'uniform vec2 projectionVector;',
        'uniform vec2 offsetVector;',
        
        'uniform vec3 tint;',
        'uniform float alpha;',
        'uniform vec3 color;',
        'uniform float flipY;',
        'varying vec4 vColor;',

        'void main(void) {',
        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',
        '   v -= offsetVector.xyx;',
        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',
        '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
        '}'
    ];

    this.init();
};

PIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader;

/**
* Initialises the shader.
* 
* @method init
*/
PIXI.ComplexPrimitiveShader.prototype.init = function()
{
    var gl = this.gl;

    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
    gl.useProgram(program);

    // get and store the uniforms for the shader
    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');
    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');
    this.tintColor = gl.getUniformLocation(program, 'tint');
    this.color = gl.getUniformLocation(program, 'color');
    this.flipY = gl.getUniformLocation(program, 'flipY');

    // get and store the attributes
    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
   // this.colorAttribute = gl.getAttribLocation(program, 'aColor');

    this.attributes = [this.aVertexPosition, this.colorAttribute];

    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');
    this.alpha = gl.getUniformLocation(program, 'alpha');

    this.program = program;
};

/**
* Destroys the shader.
* 
* @method destroy
*/
PIXI.ComplexPrimitiveShader.prototype.destroy = function()
{
    this.gl.deleteProgram( this.program );
    this.uniforms = null;
    this.gl = null;

    this.attribute = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

PIXI.glContexts = []; // this is where we store the webGL contexts for easy access.
PIXI.instances = [];
PIXI._enableMultiTextureToggle = false;

/**
 * The WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class WebGLRenderer
 * @constructor
 * @param game {Phaser.Game} A reference to the Phaser Game instance
 */
PIXI.WebGLRenderer = function(game) {

    /**
    * @property {Phaser.Game} game - A reference to the Phaser Game instance.
    */
    this.game = game;

    if (!PIXI.defaultRenderer)
    {
        PIXI.defaultRenderer = this;
    }

    this.extensions = {};

    /**
     * @property type
     * @type Number
     */
    this.type = Phaser.WEBGL;

    /**
     * The resolution of the renderer
     *
     * @property resolution
     * @type Number
     * @default 1
     */
    this.resolution = game.resolution;

    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = game.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @property autoResize
     * @type Boolean
     */
    this.autoResize = false;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @property preserveDrawingBuffer
     * @type Boolean
     */
    this.preserveDrawingBuffer = game.preserveDrawingBuffer;

    /**
     * This sets if the WebGLRenderer will clear the context texture or not before the new render pass. If true:
     * If the Stage is NOT transparent, Pixi will clear to alpha (0, 0, 0, 0).
     * If the Stage is transparent, Pixi will clear to the target Stage's background color.
     * Disable this by setting this to false. For example: if your game has a canvas filling background image, you often don't need this set.
     *
     * @property clearBeforeRender
     * @type Boolean
     * @default
     */
    this.clearBeforeRender = game.clearBeforeRender;

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     */
    this.width = game.width;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     */
    this.height = game.height;

    /**
     * The canvas element that everything is drawn to
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = game.canvas;

    /**
     * @property _contextOptions
     * @type Object
     * @private
     */
    this._contextOptions = {
        alpha: this.transparent,
        antialias: game.antialias,
        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
        stencil: true,
        preserveDrawingBuffer: this.preserveDrawingBuffer
    };

    /**
     * @property projection
     * @type Point
     */
    this.projection = new PIXI.Point();

    /**
     * @property offset
     * @type Point
     */
    this.offset = new PIXI.Point();

    // time to create the render managers! each one focuses on managing a state in webGL

    /**
     * Deals with managing the shader programs and their attribs
     * @property shaderManager
     * @type WebGLShaderManager
     */
    this.shaderManager = new PIXI.WebGLShaderManager();

    /**
     * Manages the rendering of sprites
     * @property spriteBatch
     * @type WebGLSpriteBatch
     */
    this.spriteBatch = new PIXI.WebGLSpriteBatch(game);

    /**
     * Manages the masks using the stencil buffer
     * @property maskManager
     * @type WebGLMaskManager
     */
    this.maskManager = new PIXI.WebGLMaskManager();

    /**
     * Manages the filters
     * @property filterManager
     * @type WebGLFilterManager
     */
    this.filterManager = new PIXI.WebGLFilterManager();

    /**
     * Manages the stencil buffer
     * @property stencilManager
     * @type WebGLStencilManager
     */
    this.stencilManager = new PIXI.WebGLStencilManager();

    /**
     * Manages the blendModes
     * @property blendModeManager
     * @type WebGLBlendModeManager
     */
    this.blendModeManager = new PIXI.WebGLBlendModeManager();

    /**
     * @property renderSession
     * @type Object
     */
    this.renderSession = {};

    /**
     * @property currentBatchedTextures
     * @type Array
     */
    this.currentBatchedTextures = [];

    //  Needed?
    this.renderSession.game = this.game;
    this.renderSession.gl = this.gl;
    this.renderSession.drawCount = 0;
    this.renderSession.shaderManager = this.shaderManager;
    this.renderSession.maskManager = this.maskManager;
    this.renderSession.filterManager = this.filterManager;
    this.renderSession.blendModeManager = this.blendModeManager;
    this.renderSession.spriteBatch = this.spriteBatch;
    this.renderSession.stencilManager = this.stencilManager;
    this.renderSession.renderer = this;
    this.renderSession.resolution = this.resolution;

    // time init the context..
    this.initContext();

    // map some webGL blend modes..
    this.mapBlendModes();

};

// constructor
PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;

/**
* @method initContext
*/
PIXI.WebGLRenderer.prototype.initContext = function()
{
    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);

    this.gl = gl;

    if (!gl) {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;

    PIXI.glContexts[this.glContextId] = gl;

    PIXI.instances[this.glContextId] = this;

    // set up the default pixi settings..
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);

    // need to set the context for all the managers...
    this.shaderManager.setContext(gl);
    this.spriteBatch.setContext(gl);
    this.maskManager.setContext(gl);
    this.filterManager.setContext(gl);
    this.blendModeManager.setContext(gl);
    this.stencilManager.setContext(gl);

    this.renderSession.gl = this.gl;

    // now resize and we are good to go!
    this.resize(this.width, this.height);

    // Load WebGL extension
    this.extensions.compression = {};

    etc1 = gl.getExtension('WEBGL_compressed_texture_etc1') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');
    pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
    s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');

    if (etc1) this.extensions.compression.ETC1 = etc1;
    if (pvrtc) this.extensions.compression.PVRTC = pvrtc;
    if (s3tc) this.extensions.compression.S3TC = s3tc;
};

/**
* If Multi Texture support has been enabled, then calling this method will enable batching on the given
* textures. The texture collection is an array of keys, that map to Phaser.Cache image entries.
*
* The number of textures that can be batched is dependent on hardware. If you provide more textures
* than can be batched by the GPU, then only those at the start of the array will be used. Generally
* you shouldn't provide more than 16 textures to this method. You can check the hardware limit via the
* `maxTextures` property.
*
* You can also check the property `currentBatchedTextures` at any time, to see which textures are currently
* being batched.
*
* To stop all textures from being batched, call this method again with an empty array.
*
* To change the textures being batched, call this method with a new array of image keys. The old ones
* will all be purged out and no-longer batched, and the new ones enabled.
* 
* Note: Throws a warning if you haven't enabled Multiple Texture batching support in the Phaser Game config.
* 
* @method setTexturePriority
* @param textureNameCollection {Array} An Array of Texture Cache keys to use for multi-texture batching.
* @return {Array} An array containing the texture keys that were enabled for batching.
*/
PIXI.WebGLRenderer.prototype.setTexturePriority = function (textureNameCollection) {

    if (!PIXI._enableMultiTextureToggle)
    {
        console.warn('setTexturePriority error: Multi Texture support hasn\'t been enabled in the Phaser Game Config.');
        return;
    }
    var clampPot = function (potSize) {
        --potSize;
        potSize |= potSize >> 1;
        potSize |= potSize >> 2;
        potSize |= potSize >> 4;
        potSize |= potSize >> 8;
        potSize |= potSize >> 16;
        return ++potSize;
    };
    var gl = this.gl;
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    var imageCache = this.game.cache._cache.image;
    var imageName = null;

    //  Clear out all previously batched textures and reset their flags.
    //  If the array has been modified, then the developer will have to
    //  deal with that in their own way.
    for (var i = 0; i < this.currentBatchedTextures.length; i++)
    {
        imageName = textureNameCollection[index];

        if (!(imageName in imageCache))
        {
            continue;
        }
        
        imageCache[imageName].base.textureIndex = 0;
    }
    var maxTextureAvailableSpace = (maxTextureSize) - clampPot(Math.max(this.width, this.height));
    this.currentBatchedTextures.length = 0;
    // We start from 1 because framebuffer texture uses unit 0.
    for (var index = 0; index < textureNameCollection.length; ++index)
    {
        imageName = textureNameCollection[index];

        if (!(imageName in imageCache))
        {
            continue;
        }
        // Unit 0 is reserved for Pixi's framebuffer
        var base = imageCache[imageName].base;
        maxTextureAvailableSpace -= clampPot(Math.max(base.width, base.height));
        if (maxTextureAvailableSpace <= 0) {
            base.textureIndex = 0;
        } else {
            base.textureIndex = (1 + (index % (maxTextures - 1)));
        }
        this.currentBatchedTextures.push(imageName);
    }

    return this.currentBatchedTextures;

};

/**
 * Renders the stage to its webGL view
 *
 * @method render
 * @param stage {Stage} the Stage element to be rendered
 */
PIXI.WebGLRenderer.prototype.render = function(stage)
{
    // no point rendering if our context has been blown up!
    if (this.contextLost)
    {
        return;
    }

    var gl = this.gl;

    // -- Does this need to be set every frame? -- //
    gl.viewport(0, 0, this.width, this.height);

    // make sure we are bound to the main frame buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if (this.game.clearBeforeRender)
    {
        gl.clearColor(stage._bgColor.r, stage._bgColor.g, stage._bgColor.b, stage._bgColor.a);

        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    this.offset.x = this.game.camera._shake.x;
    this.offset.y = this.game.camera._shake.y;

    this.renderDisplayObject(stage, this.projection);
};

/**
 * Renders a Display Object.
 *
 * @method renderDisplayObject
 * @param displayObject {DisplayObject} The DisplayObject to render
 * @param projection {Point} The projection
 * @param buffer {Array} a standard WebGL buffer
 */
PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer, matrix)
{
    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);

    // reset the render session data..
    this.renderSession.drawCount = 0;

    // make sure to flip the Y if using a render texture..
    this.renderSession.flipY = buffer ? -1 : 1;

    // set the default projection
    this.renderSession.projection = projection;

    //set the default offset
    this.renderSession.offset = this.offset;

    // start the sprite batch
    this.spriteBatch.begin(this.renderSession);

    // start the filter manager
    this.filterManager.begin(this.renderSession, buffer);

    // render the scene!
    displayObject._renderWebGL(this.renderSession, matrix);

    // finish the sprite batch
    this.spriteBatch.end();
};

/**
 * Resizes the webGL view to the specified width and height.
 *
 * @method resize
 * @param width {Number} the new width of the webGL view
 * @param height {Number} the new height of the webGL view
 */
PIXI.WebGLRenderer.prototype.resize = function(width, height)
{
    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize) {
        this.view.style.width = this.width / this.resolution + 'px';
        this.view.style.height = this.height / this.resolution + 'px';
    }

    this.gl.viewport(0, 0, this.width, this.height);

    this.projection.x =  this.width / 2 / this.resolution;
    this.projection.y =  -this.height / 2 / this.resolution;
};

/**
 * Updates and creates a WebGL compressed texture for the renderers context.
 *
 * @method updateCompressedTexture
 * @param texture {Texture} the texture to update
 * @return {boolean} True if the texture was successfully bound, otherwise false.
 */
PIXI.WebGLRenderer.prototype.updateCompressedTexture = function (texture) {
    if (!texture.hasLoaded)
    {
        return false;
    }
    var gl = this.gl;
    var textureMetaData = texture.source;

    if (!texture._glTextures[gl.id])
    {
        texture._glTextures[gl.id] = gl.createTexture();
    }
    gl.activeTexture(gl.TEXTURE0 + texture.textureIndex);

    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

    gl.compressedTexImage2D(
        gl.TEXTURE_2D, 
        0, 
        textureMetaData.glExtensionFormat, 
        textureMetaData.width, 
        textureMetaData.height, 
        0, 
        textureMetaData.textureData
    );

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

    if (texture.mipmap && Phaser.Math.isPowerOfTwo(texture.width, texture.height))
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    }

    if (!texture._powerOf2)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }
    texture._dirty[gl.id] = false;
    return true;
};

/**
 * Updates and Creates a WebGL texture for the renderers context.
 *
 * @method updateTexture
 * @param texture {Texture} the texture to update
 * @return {boolean} True if the texture was successfully bound, otherwise false.
 */
PIXI.WebGLRenderer.prototype.updateTexture = function(texture)
{
    if (!texture.hasLoaded)
    {
        return false;
    }
    if (texture.source.compressionAlgorithm) {
        return this.updateCompressedTexture(texture);
    }

    var gl = this.gl;

    if (!texture._glTextures[gl.id])
    {
        texture._glTextures[gl.id] = gl.createTexture();
    }
    gl.activeTexture(gl.TEXTURE0 + texture.textureIndex);

    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);

    if (texture.mipmap && Phaser.Math.isPowerOfTwo(texture.width, texture.height))
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    }

    if (!texture._powerOf2)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }

    texture._dirty[gl.id] = false;

    // return texture._glTextures[gl.id];
    return true;

};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @method destroy
 */
PIXI.WebGLRenderer.prototype.destroy = function()
{
    PIXI.glContexts[this.glContextId] = null;

    this.projection = null;
    this.offset = null;

    this.shaderManager.destroy();
    this.spriteBatch.destroy();
    this.maskManager.destroy();
    this.filterManager.destroy();

    this.shaderManager = null;
    this.spriteBatch = null;
    this.maskManager = null;
    this.filterManager = null;

    this.gl = null;
    this.renderSession = null;

    Phaser.CanvasPool.remove(this);

    PIXI.instances[this.glContextId] = null;

    PIXI.WebGLRenderer.glContextId--;
};

/**
 * Maps Pixi blend modes to WebGL blend modes.
 *
 * @method mapBlendModes
 */
PIXI.WebGLRenderer.prototype.mapBlendModes = function()
{
    var gl = this.gl;

    if (!PIXI.blendModesWebGL)
    {
        var b = [];
        var modes = PIXI.blendModes;

        b[modes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        b[modes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        b[modes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        b[modes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        b[modes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];

        PIXI.blendModesWebGL = b;
    }
};

PIXI.WebGLRenderer.prototype.getMaxTextureUnit = function() {
    var gl = this.gl;
    return gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
};

PIXI.enableMultiTexture = function() {
    PIXI._enableMultiTextureToggle = true;
};

PIXI.WebGLRenderer.glContextId = 0;
PIXI.WebGLRenderer.textureArray = [];
/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLBlendModeManager
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLBlendModeManager = function()
{
    /**
     * @property currentBlendMode
     * @type Number
     */
    this.currentBlendMode = 99999;
};

PIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager;

/**
 * Sets the WebGL Context.
 *
 * @method setContext
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLBlendModeManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Sets-up the given blendMode from WebGL's point of view.
* 
* @method setBlendMode 
* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD
*/
PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode)
{
    if(this.currentBlendMode === blendMode)return false;

    this.currentBlendMode = blendMode;
    
    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];

    if (blendModeWebGL)
    {
        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
    }
    
    return true;
};

/**
* Destroys this object.
* 
* @method destroy
*/
PIXI.WebGLBlendModeManager.prototype.destroy = function()
{
    this.gl = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLMaskManager
* @constructor
* @private
*/
PIXI.WebGLMaskManager = function()
{
};

PIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager;

/**
* Sets the drawing context to the one given in parameter.
* 
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLMaskManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack.
* 
* @method pushMask
* @param maskData {Array}
* @param renderSession {Object}
*/
PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)
{
    var gl = renderSession.gl;

    if (maskData.dirty)
    {
        PIXI.WebGLGraphics.updateGraphics(maskData, gl);
    }

    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)
    {
        return;
    }

    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);
};

/**
* Removes the last filter from the filter stack and doesn't return it.
* 
* @method popMask
* @param maskData {Array}
* @param renderSession {Object} an object containing all the useful parameters
*/
PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession)
{
    var gl = this.gl;

    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)
    {
        return;
    }

    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);

};

/**
* Destroys the mask stack.
* 
* @method destroy
*/
PIXI.WebGLMaskManager.prototype.destroy = function()
{
    this.gl = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLStencilManager
* @constructor
* @private
*/
PIXI.WebGLStencilManager = function()
{
    this.stencilStack = [];
    this.reverse = true;
    this.count = 0;
};

/**
* Sets the drawing context to the one given in parameter.
* 
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLStencilManager.prototype.setContext = function(gl)
{
    this.gl = gl;
};

/**
* Applies the Mask and adds it to the current filter stack.
* 
* @method pushMask
* @param graphics {Graphics}
* @param webGLData {Array}
* @param renderSession {Object}
*/
PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession)
{
    var gl = this.gl;
    this.bindGraphics(graphics, webGLData, renderSession);

    if(this.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        this.reverse = true;
        this.count = 0;
    }

    this.stencilStack.push(webGLData);

    var level = this.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if(webGLData.mode === 1)
    {
        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
       
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
               
        if(this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        this.reverse = !this.reverse;
    }
    else
    {
        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if(!this.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    this.count++;
};

/**
 * TODO this does not belong here!
 * 
 * @method bindGraphics
 * @param graphics {Graphics}
 * @param webGLData {Array}
 * @param renderSession {Object}
 */
PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession)
{
    //if(this._currentGraphics === graphics)return;
    this._currentGraphics = graphics;

    var gl = this.gl;

     // bind the graphics object..
    var projection = renderSession.projection,
        offset = renderSession.offset,
        shader;// = renderSession.shaderManager.primitiveShader;

    if(webGLData.mode === 1)
    {
        shader = renderSession.shaderManager.complexPrimitiveShader;

        renderSession.shaderManager.setShader( shader );

        gl.uniform1f(shader.flipY, renderSession.flipY);
       
        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, Phaser.Color.hexToRGBArray(graphics.tint));
        gl.uniform3fv(shader.color, webGLData.color);

        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //renderSession.shaderManager.activatePrimitiveShader();
        shader = renderSession.shaderManager.primitiveShader;
        renderSession.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));

        gl.uniform1f(shader.flipY, renderSession.flipY);
        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);
        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);

        gl.uniform3fv(shader.tintColor, Phaser.Color.hexToRGBArray(graphics.tint));

        gl.uniform1f(shader.alpha, graphics.worldAlpha);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

/**
 * @method popStencil
 * @param graphics {Graphics}
 * @param webGLData {Array}
 * @param renderSession {Object}
 */
PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession)
{
	var gl = this.gl;
    this.stencilStack.pop();
   
    this.count--;

    if(this.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = this.count;

        this.bindGraphics(graphics, webGLData, renderSession);

        gl.colorMask(false, false, false, false);
    
        if(webGLData.mode === 1)
        {
            this.reverse = !this.reverse;

            if(this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );
            
            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );
           
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            if(!this.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }
};

/**
* Destroys the mask stack.
* 
* @method destroy
*/
PIXI.WebGLStencilManager.prototype.destroy = function()
{
    this.stencilStack = null;
    this.gl = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLShaderManager
* @constructor
* @private
*/
PIXI.WebGLShaderManager = function()
{
    /**
     * @property maxAttibs
     * @type Number
     */
    this.maxAttibs = 10;

    /**
     * @property attribState
     * @type Array
     */
    this.attribState = [];

    /**
     * @property tempAttribState
     * @type Array
     */
    this.tempAttribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    /**
     * @property stack
     * @type Array
     */
    this.stack = [];

};

PIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager;

/**
* Initialises the context and the properties.
* 
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLShaderManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    
    // the next one is used for rendering primitives
    this.primitiveShader = new PIXI.PrimitiveShader(gl);

    // the next one is used for rendering triangle strips
    this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);

    // this shader is used for the default sprite rendering
    this.defaultShader = new PIXI.PixiShader(gl);

    // this shader is used for the fast sprite rendering
    this.fastShader = new PIXI.PixiFastShader(gl);

    // the next one is used for rendering triangle strips
    this.stripShader = new PIXI.StripShader(gl);

    this.setShader(this.defaultShader);
};

/**
* Takes the attributes given in parameters.
* 
* @method setAttribs
* @param attribs {Array} attribs 
*/
PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)
{
    // reset temp state
    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (i = 0; i < attribs.length; i++)
    {
        var attribId = attribs[i];
        this.tempAttribState[attribId] = true;
    }

    var gl = this.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if(this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if(this.tempAttribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

/**
* Sets the current shader.
* 
* @method setShader
* @param shader {Any}
*/
PIXI.WebGLShaderManager.prototype.setShader = function(shader)
{
    if(this._currentId === shader._UID)return false;
    
    this._currentId = shader._UID;

    this.currentShader = shader;

    this.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
* Destroys this object.
* 
* @method destroy
*/
PIXI.WebGLShaderManager.prototype.destroy = function()
{
    this.attribState = null;

    this.tempAttribState = null;

    this.primitiveShader.destroy();

    this.complexPrimitiveShader.destroy();

    this.defaultShader.destroy();

    this.fastShader.destroy();

    this.stripShader.destroy();

    this.gl = null;
};

/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 * 
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

/**
 *
 * @class WebGLSpriteBatch
 * @private
 * @constructor
 */
PIXI.WebGLSpriteBatch = function (game) {

    /**
    * @property {Phaser.Game} game - A reference to the currently running game.
    */
    this.game = game;

    /**
     * @property vertSize
     * @type Number
     */
    this.vertSize = 5;

    /**
     * The number of images in the SpriteBatch before it flushes
     * @property size
     * @type Number
     */
    this.size = 2000; //Math.pow(2, 16) /  this.vertSize;

    //the total number of bytes in our batch
    // Including texture index:
    // position + uv + color + textureIndex
    // vec2 + vec2 + (char * 4) + float
    this.vertexSize = (4 * 2) + (4 * 2) + (4) + (4);
    var numVerts = this.vertexSize * this.size * 4;
    //this.size * 4 * 4 * this.vertSize;
    //the total number of indices in our batch
    var numIndices = this.size * 6;

    /**
     * Holds the vertices
     *
     * @property vertices
     * @type ArrayBuffer
     */
    this.vertices = new ArrayBuffer(numVerts);

    /**
     * View on the vertices as a Float32Array
     *
     * @property positions
     * @type Float32Array
     */
    this.positions = new Float32Array(this.vertices);

    /**
     * View on the vertices as a Uint32Array
     *
     * @property colors
     * @type Uint32Array
     */
    this.colors = new Uint32Array(this.vertices);

    /**
     * Holds the indices
     *
     * @property indices
     * @type Uint16Array
     */
    this.indices = new Uint16Array(numIndices);

    /**
     * @property lastIndexCount
     * @type Number
     */
    this.lastIndexCount = 0;

    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * @property drawing
     * @type Boolean
     */
    this.drawing = false;

    /**
     * @property currentBatchSize
     * @type Number
     */
    this.currentBatchSize = 0;

    /**
     * @property currentBaseTexture
     * @type BaseTexture
     */
    this.currentBaseTexture = null;

    /**
     * @property dirty
     * @type Boolean
     */
    this.dirty = true;

    /**
     * @property textures
     * @type Array
     */
    this.textures = [];

    /**
     * @property blendModes
     * @type Array
     */
    this.blendModes = [];

    /**
     * @property shaders
     * @type Array
     */
    this.shaders = [];

    /**
     * @property sprites
     * @type Array
     */
    this.sprites = [];

    /**
     * @property defaultShader
     * @type Phaser.Filter
     */
    this.defaultShader = null;
};

/**
 * @method setContext
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLSpriteBatch.prototype.setContext = function (gl) {
    this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.gl = gl;
    if (PIXI._enableMultiTextureToggle) {
        var dynamicIfs = '\tif (vTextureIndex == 0.0) gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;\n'
        for (var index = 1; index < this.MAX_TEXTURES; ++index) {
            dynamicIfs += '\telse if (vTextureIndex == ' +
                index + '.0) gl_FragColor = texture2D(uSamplerArray[' +
                index + '], vTextureCoord) * vColor;\n'
        }
        this.defaultShader = new Phaser.Filter(
            this.game,
            undefined,
            [
                '//WebGLSpriteBatch Fragment Shader.',
                'precision lowp float;',
                'varying vec2 vTextureCoord;',
                'varying vec4 vColor;',
                'varying float vTextureIndex;',
                'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',
                'void main(void) {',
                    dynamicIfs,
                    '\telse gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;',
                '}'
            ]);
    }
    else
    {
        this.defaultShader = new Phaser.Filter(
            this.game,
            undefined,
            [
                '//WebGLSpriteBatch Fragment Shader.',
                'precision lowp float;',
                'varying vec2 vTextureCoord;',
                'varying vec4 vColor;',
                'varying float vTextureIndex;',
                'uniform sampler2D uSampler;',
                'void main(void) {',
                '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;',
                '}'
            ]);
    }

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;

    var shader = new PIXI.PixiShader(gl);

    shader.fragmentSrc = this.defaultShader.fragmentSrc;
    shader.uniforms = {};
    shader.init();

    this.defaultShader.shaders[gl.id] = shader;
};

/**
 * @method begin
 * @param renderSession {Object} The RenderSession object
 */
PIXI.WebGLSpriteBatch.prototype.begin = function (renderSession) {
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.defaultShader;

    this.start();
};

/**
 * @method end
 */
PIXI.WebGLSpriteBatch.prototype.end = function () {
    this.flush();
};

/**
 * @method render
 * @param sprite {Sprite} the sprite to render when using this spritebatch
 * @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.
 */
PIXI.WebGLSpriteBatch.prototype.render = function (sprite, matrix) {
    var texture = sprite.texture;
    var baseTexture = texture.baseTexture;
    var gl = this.gl;
    if (PIXI.WebGLRenderer.textureArray[baseTexture.textureIndex] != baseTexture) {
        this.flush();
        gl.activeTexture(gl.TEXTURE0 + baseTexture.textureIndex);
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
        PIXI.WebGLRenderer.textureArray[baseTexture.textureIndex] = baseTexture;
    }

    //  They provided an alternative rendering matrix, so use it
    var wt = sprite.worldTransform;

    if (matrix) {
        wt = matrix;
    }

    // check texture..
    if (this.currentBatchSize >= this.size) {
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

    // get the uvs for the texture
    var uvs = texture._uvs;

    // if the uvs have not updated then no point rendering just yet!
    if (!uvs) {
        return;
    }

    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;

    if (texture.trim) {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords.
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;
    } else {
        w0 = (texture.frame.width) * (1 - aX);
        w1 = (texture.frame.width) * -aX;

        h0 = texture.frame.height * (1 - aY);
        h1 = texture.frame.height * -aY;
    }

    var i = this.currentBatchSize * this.vertexSize; //4 * this.vertSize;
    var tiOffset = this.currentBatchSize * 4;
    var resolution = texture.baseTexture.resolution;
    var textureIndex = texture.baseTexture.textureIndex;

    var a = wt.a / resolution;
    var b = wt.b / resolution;
    var c = wt.c / resolution;
    var d = wt.d / resolution;
    var tx = wt.tx;
    var ty = wt.ty;

    var cw = texture.crop.width;
    var ch = texture.crop.height;

    if (texture.rotated)
    {
        var a0 = wt.a;
        var b0 = wt.b;
        var c0 = wt.c;
        var d0 = wt.d;
        var _w1 = w1;
        var _w0 = w0;

        // Offset before rotating
        tx = wt.c * ch + tx;
        ty = wt.d * ch + ty;
        
        // Rotate matrix by 90 degrees
        // We use precalculated values for sine and cosine of rad(90)
        a = a0 * 6.123233995736766e-17 + -c0;
        b = b0 * 6.123233995736766e-17 + -d0;
        c = a0 + c0 * 6.123233995736766e-17;
        d = b0 + d0 * 6.123233995736766e-17;

        // Update UV coordinates
        texture._updateUvsInverted();

        // Rotate dimensions
        w0 = h0;
        w1 = h1;
        h0 = _w0;
        h1 = _w1;   
    }

    var colors = this.colors;
    var positions = this.positions;
    var tint = sprite.tint;
    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);

    if (this.renderSession.roundPixels) {
        positions[i++] = a * w1 + c * h1 + tx | 0;
        positions[i++] = d * h1 + b * w1 + ty | 0;
        positions[i++] = uvs.x0;
        positions[i++] = uvs.y0;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w0 + c * h1 + tx | 0;
        positions[i++] = d * h1 + b * w0 + ty | 0;
        positions[i++] = uvs.x1;
        positions[i++] = uvs.y1;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w0 + c * h0 + tx | 0;
        positions[i++] = d * h0 + b * w0 + ty | 0;
        positions[i++] = uvs.x2;
        positions[i++] = uvs.y2;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w1 + c * h0 + tx | 0;
        positions[i++] = d * h0 + b * w1 + ty | 0;
        positions[i++] = uvs.x3;
        positions[i++] = uvs.y3;
        colors[i++] = color;
        positions[i++] = textureIndex;
    } else {
        positions[i++] = a * w1 + c * h1 + tx;
        positions[i++] = d * h1 + b * w1 + ty;
        positions[i++] = uvs.x0;
        positions[i++] = uvs.y0;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w0 + c * h1 + tx;
        positions[i++] = d * h1 + b * w0 + ty;
        positions[i++] = uvs.x1;
        positions[i++] = uvs.y1;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w0 + c * h0 + tx;
        positions[i++] = d * h0 + b * w0 + ty;
        positions[i++] = uvs.x2;
        positions[i++] = uvs.y2;
        colors[i++] = color;
        positions[i++] = textureIndex;

        positions[i++] = a * w1 + c * h0 + tx;
        positions[i++] = d * h0 + b * w1 + ty;
        positions[i++] = uvs.x3;
        positions[i++] = uvs.y3;
        colors[i++] = color;
        positions[i++] = textureIndex;
    }
    // increment the batchsize
    this.sprites[this.currentBatchSize++] = sprite;
};

/**
 * Renders a TilingSprite using the spriteBatch.
 * 
 * @method renderTilingSprite
 * @param sprite {TilingSprite} the sprite to render
 */
PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function (sprite) {
    var texture = sprite.tilingTexture;
    var baseTexture = texture.baseTexture;
    var gl = this.gl;
    var textureIndex = sprite.texture.baseTexture.textureIndex;
    if (PIXI.WebGLRenderer.textureArray[textureIndex] != baseTexture) {
        this.flush();
        gl.activeTexture(gl.TEXTURE0 + textureIndex);
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
        PIXI.WebGLRenderer.textureArray[textureIndex] = baseTexture;
    }

    // check texture..
    if (this.currentBatchSize >= this.size) {
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

    // set the textures uvs temporarily
    if (!sprite._uvs) {
        sprite._uvs = new PIXI.TextureUvs();
    }

    var uvs = sprite._uvs;

    var w = texture.baseTexture.width;
    var h = texture.baseTexture.height;

    // var w = sprite._frame.sourceSizeW;
    // var h = sprite._frame.sourceSizeH;

    // w = 16;
    // h = 16;

    sprite.tilePosition.x %= w * sprite.tileScaleOffset.x;
    sprite.tilePosition.y %= h * sprite.tileScaleOffset.y;

    var offsetX = sprite.tilePosition.x / (w * sprite.tileScaleOffset.x);
    var offsetY = sprite.tilePosition.y / (h * sprite.tileScaleOffset.y);

    var scaleX = (sprite.width / w) / (sprite.tileScale.x * sprite.tileScaleOffset.x);
    var scaleY = (sprite.height / h) / (sprite.tileScale.y * sprite.tileScaleOffset.y);

    uvs.x0 = 0 - offsetX;
    uvs.y0 = 0 - offsetY;

    uvs.x1 = (1 * scaleX) - offsetX;
    uvs.y1 = 0 - offsetY;

    uvs.x2 = (1 * scaleX) - offsetX;
    uvs.y2 = (1 * scaleY) - offsetY;

    uvs.x3 = 0 - offsetX;
    uvs.y3 = (1 * scaleY) - offsetY;

    //  Get the sprites current alpha and tint and combine them into a single color
    var tint = sprite.tint;
    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);

    var positions = this.positions;
    var colors = this.colors;

    var width = sprite.width;
    var height = sprite.height;

    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;
    var w0 = width * (1 - aX);
    var w1 = width * -aX;

    var h0 = height * (1 - aY);
    var h1 = height * -aY;

    var i = this.currentBatchSize * this.vertexSize; //4 * this.vertSize;

    var resolution = texture.baseTexture.resolution;

    var wt = sprite.worldTransform;

    var a = wt.a / resolution;
    var b = wt.b / resolution;
    var c = wt.c / resolution;
    var d = wt.d / resolution;
    var tx = wt.tx;
    var ty = wt.ty;
    // xy
    positions[i++] = a * w1 + c * h1 + tx;
    positions[i++] = d * h1 + b * w1 + ty;
    // uv
    positions[i++] = uvs.x0;
    positions[i++] = uvs.y0;
    // color
    colors[i++] = color;
    // texture index
    positions[i++] = textureIndex;

    // xy
    positions[i++] = (a * w0 + c * h1 + tx);
    positions[i++] = d * h1 + b * w0 + ty;
    // uv
    positions[i++] = uvs.x1;
    positions[i++] = uvs.y1;
    // color
    colors[i++] = color;
    // texture index
    positions[i++] = textureIndex;

    // xy
    positions[i++] = a * w0 + c * h0 + tx;
    positions[i++] = d * h0 + b * w0 + ty;
    // uv
    positions[i++] = uvs.x2;
    positions[i++] = uvs.y2;
    // color
    colors[i++] = color;
    // texture index
    positions[i++] = textureIndex;

    // xy
    positions[i++] = a * w1 + c * h0 + tx;
    positions[i++] = d * h0 + b * w1 + ty;
    // uv
    positions[i++] = uvs.x3;
    positions[i++] = uvs.y3;
    // color
    colors[i++] = color;
    // texture index
    positions[i++] = textureIndex;

    // increment the batchsize
    this.sprites[this.currentBatchSize++] = sprite;
};

/**
 * Renders the content and empties the current batch.
 *
 * @method flush
 */
PIXI.WebGLSpriteBatch.prototype.flush = function () {
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize === 0) {
        return;
    }

    var gl = this.gl;
    var shader;

    if (this.dirty) {
        this.dirty = false;

        shader = this.defaultShader.shaders[gl.id];

        // bind the main texture
        gl.activeTexture(gl.TEXTURE0);

        // bind the buffers
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        // this is the same for each shader?
        var stride = this.vertexSize; //this.vertSize * 4;
        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 8);

        // color attributes will be interpreted as unsigned bytes and normalized
        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, true, stride, 16);

        // Texture index
        gl.vertexAttribPointer(shader.aTextureIndex, 1, gl.FLOAT, false, stride, 20);
    }

    // upload the verts to the buffer  
    if (this.currentBatchSize > (this.size * 0.5)) {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    } else {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        var view = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode, nextShader;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;
    var currentShader = null;

    var blendSwap = false;
    var shaderSwap = false;
    var sprite;
    var textureIndex = 0;

    for (var i = 0, j = this.currentBatchSize; i < j; i++) {

        sprite = this.sprites[i];

        if (sprite.tilingTexture) {
            nextTexture = sprite.tilingTexture.baseTexture;
        } else {
            nextTexture = sprite.texture.baseTexture;
        }

        nextBlendMode = sprite.blendMode;
        nextShader = sprite.shader || this.defaultShader;

        blendSwap = currentBlendMode !== nextBlendMode;
        shaderSwap = currentShader !== nextShader; // should I use _UIDS???

        var skip = nextTexture.skipRender;

        if (skip && sprite.children.length > 0) {
            skip = false;
        }
        //
        if (/*(currentBaseTexture != nextTexture && !skip) ||*/
            blendSwap ||
            shaderSwap) {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;

            if (blendSwap) {
                currentBlendMode = nextBlendMode;
                this.renderSession.blendModeManager.setBlendMode(currentBlendMode);
            }

            if (shaderSwap) {
                currentShader = nextShader;

                shader = currentShader.shaders[gl.id];

                if (!shader) {
                    shader = new PIXI.PixiShader(gl);

                    shader.fragmentSrc = currentShader.fragmentSrc;
                    shader.uniforms = currentShader.uniforms;
                    shader.init();

                    currentShader.shaders[gl.id] = shader;
                }

                // set shader function???
                this.renderSession.shaderManager.setShader(shader);

                if (shader.dirty) {
                    shader.syncUniforms();
                }

                // both these only need to be set if they are changing..
                // set the projection
                var projection = this.renderSession.projection;
                gl.uniform2f(shader.projectionVector, projection.x, projection.y);

                // TODO - this is temporary!
                var offsetVector = this.renderSession.offset;
                gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);

                // set the pointers
            }
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

/**
 * @method renderBatch
 * @param texture {Texture}
 * @param size {Number}
 * @param startIndex {Number}
 */
PIXI.WebGLSpriteBatch.prototype.renderBatch = function (texture, size, startIndex) {
    if (size === 0) {
        return;
    }

    var gl = this.gl;

    // check if a texture is dirty..
    if (texture._dirty[gl.id]) {
        if (!this.renderSession.renderer.updateTexture(texture)) {
            //  If updateTexture returns false then we cannot render it, so bail out now
            return;
        }
    }
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);
    // increment the draw count
    this.renderSession.drawCount++;
};

/**
 * @method stop
 */
PIXI.WebGLSpriteBatch.prototype.stop = function () {
    this.flush();
    this.dirty = true;
};

/**
 * @method start
 */
PIXI.WebGLSpriteBatch.prototype.start = function () {
    this.dirty = true;
};

/**
 * Destroys the SpriteBatch.
 * 
 * @method destroy
 */
PIXI.WebGLSpriteBatch.prototype.destroy = function () {
    this.vertices = null;
    this.indices = null;

    this.gl.deleteBuffer(this.vertexBuffer);
    this.gl.deleteBuffer(this.indexBuffer);

    this.currentBaseTexture = null;

    this.gl = null;
};
/**
 * @author Mat Groves
 * 
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 *
 * Heavily inspired by LibGDX's WebGLSpriteBatch:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java
 */

/**
* @class WebGLFastSpriteBatch
* @constructor
*/
PIXI.WebGLFastSpriteBatch = function(gl)
{

    /**
     * @property vertSize
     * @type Number
     */
    this.vertSize = 11;

    /**
     * @property maxSize
     * @type Number
     */
    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;

    /**
     * @property size
     * @type Number
     */
    this.size = this.maxSize;

    //the total number of floats in our batch
    var numVerts = this.size * 4 *  this.vertSize;

    //the total number of indices in our batch
    var numIndices = this.maxSize * 6;

    /**
     * Vertex data
     * @property vertices
     * @type Float32Array
     */
    this.vertices = new Float32Array(numVerts);

    /**
     * Index data
     * @property indices
     * @type Uint16Array
     */
    this.indices = new Uint16Array(numIndices);
    
    /**
     * @property vertexBuffer
     * @type Object
     */
    this.vertexBuffer = null;

    /**
     * @property indexBuffer
     * @type Object
     */
    this.indexBuffer = null;

    /**
     * @property lastIndexCount
     * @type Number
     */
    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * @property drawing
     * @type Boolean
     */
    this.drawing = false;

    /**
     * @property currentBatchSize
     * @type Number
     */
    this.currentBatchSize = 0;

    /**
     * @property currentBaseTexture
     * @type BaseTexture
     */
    this.currentBaseTexture = null;
   
    /**
     * @property currentBlendMode
     * @type Number
     */
    this.currentBlendMode = 0;

    /**
     * @property renderSession
     * @type Object
     */
    this.renderSession = null;
    
    /**
     * @property shader
     * @type Object
     */
    this.shader = null;

    /**
     * @property matrix
     * @type Matrix
     */
    this.matrix = null;

    this.setContext(gl);
};

PIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch;

/**
 * Sets the WebGL Context.
 *
 * @method setContext
 * @param gl {WebGLContext} the current WebGL drawing context
 */
PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)
{
    this.gl = gl;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
};

/**
 * @method begin
 * @param spriteBatch {WebGLSpriteBatch}
 * @param renderSession {Object}
 */
PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)
{
    this.renderSession = renderSession;
    this.shader = this.renderSession.shaderManager.fastShader;

    this.matrix = spriteBatch.worldTransform.toArray(true);

    this.start();
};

/**
 * @method end
 */
PIXI.WebGLFastSpriteBatch.prototype.end = function()
{
    this.flush();
};

/**
 * @method render
 * @param spriteBatch {WebGLSpriteBatch}
 */
PIXI.WebGLFastSpriteBatch.prototype.render = function (spriteBatch)
{
    var children = spriteBatch.children;
    var sprite = children[0];

    // if the uvs have not updated then no point rendering just yet!
    
    // check texture.
    if(!sprite.texture._uvs)return;
   
    this.currentBaseTexture = sprite.texture.baseTexture;

    // check blend mode
    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)
    {
        this.flush();
        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);
    }
    
    for(var i=0,j= children.length; i<j; i++)
    {
        this.renderSprite(children[i]);
    }

    this.flush();
};

/**
 * @method renderSprite
 * @param sprite {Sprite}
 */
PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)
{
    var texture = sprite.texture;
    var baseTexture = texture.baseTexture;
    var gl = this.gl;
    var textureIndex = sprite.texture.baseTexture.textureIndex;
    
    if (PIXI.WebGLRenderer.textureArray[textureIndex] != baseTexture &&
        baseTexture._glTextures[gl.id] && !sprite.texture.baseTexture.skipRender) {
        this.flush();
        gl.activeTexture(gl.TEXTURE0 + textureIndex);
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
        PIXI.WebGLRenderer.textureArray[textureIndex] = baseTexture;
        if(!sprite.texture._uvs)return;

    }
    //sprite = children[i];
    if(!sprite.visible)return;
    
    var uvs, vertices = this.vertices, width, height, w0, w1, h0, h1, index;

    uvs = sprite.texture._uvs;

    width = sprite.texture.frame.width;
    height = sprite.texture.frame.height;

    if (sprite.texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = sprite.texture.trim;

        w1 = trim.x - sprite.anchor.x * trim.width;
        w0 = w1 + sprite.texture.crop.width;

        h1 = trim.y - sprite.anchor.y * trim.height;
        h0 = h1 + sprite.texture.crop.height;
    }
    else
    {
        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);
        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;

        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);
        h1 = sprite.texture.frame.height * -sprite.anchor.y;
    }

    index = this.currentBatchSize * 4 * this.vertSize;
    // xy
    vertices[index++] = w1;
    vertices[index++] = h1;

    vertices[index++] = sprite.position.x;
    vertices[index++] = sprite.position.y;

    //scale
    vertices[index++] = sprite.scale.x;
    vertices[index++] = sprite.scale.y;

    //rotation
    vertices[index++] = sprite.rotation;

    // uv
    vertices[index++] = uvs.x0;
    vertices[index++] = uvs.y1;
    // color
    vertices[index++] = sprite.alpha;
    // texture Index
    vertices[index++] = textureIndex;
 

    // xy
    vertices[index++] = w0;
    vertices[index++] = h1;

    vertices[index++] = sprite.position.x;
    vertices[index++] = sprite.position.y;

    //scale
    vertices[index++] = sprite.scale.x;
    vertices[index++] = sprite.scale.y;

     //rotation
    vertices[index++] = sprite.rotation;

    // uv
    vertices[index++] = uvs.x1;
    vertices[index++] = uvs.y1;
    // color
    vertices[index++] = sprite.alpha;
    // texture Index
    vertices[index++] = textureIndex;

    // xy
    vertices[index++] = w0;
    vertices[index++] = h0;

    vertices[index++] = sprite.position.x;
    vertices[index++] = sprite.position.y;

    //scale
    vertices[index++] = sprite.scale.x;
    vertices[index++] = sprite.scale.y;

     //rotation
    vertices[index++] = sprite.rotation;

    // uv
    vertices[index++] = uvs.x2;
    vertices[index++] = uvs.y2;
    // color
    vertices[index++] = sprite.alpha;
    // texture Index
    vertices[index++] = textureIndex;



    // xy
    vertices[index++] = w1;
    vertices[index++] = h0;

    vertices[index++] = sprite.position.x;
    vertices[index++] = sprite.position.y;

    //scale
    vertices[index++] = sprite.scale.x;
    vertices[index++] = sprite.scale.y;

     //rotation
    vertices[index++] = sprite.rotation;

    // uv
    vertices[index++] = uvs.x3;
    vertices[index++] = uvs.y3;
    // color
    vertices[index++] = sprite.alpha;
    // texture Index
    vertices[index++] = textureIndex;

    // increment the batchs
    this.currentBatchSize++;

    if(this.currentBatchSize >= this.size)
    {
        this.flush();
    }
};

/**
 * @method flush
 */
PIXI.WebGLFastSpriteBatch.prototype.flush = function()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize===0)return;

    var gl = this.gl;
    
    // bind the current texture

    if(!this.currentBaseTexture._glTextures[gl.id]) {
        this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl);
        return;
    }

    //gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);

    // upload the verts to the buffer
   
    if(this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }
    
    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);
   
    // then reset the batch!
    this.currentBatchSize = 0;

    // increment the draw count
    this.renderSession.drawCount++;
};


/**
 * @method stop
 */
PIXI.WebGLFastSpriteBatch.prototype.stop = function()
{
    this.flush();
};

/**
 * @method start
 */
PIXI.WebGLFastSpriteBatch.prototype.start = function()
{
    var gl = this.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // set the projection
    var projection = this.renderSession.projection;
    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);

    // set the matrix
    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);

    // set the pointers
    var stride =  this.vertSize * 4;

    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);
    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);
    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);
    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);
    gl.vertexAttribPointer(this.shader.aTextureIndex, 1, gl.FLOAT, false, stride, 10 * 4);
    
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
* @class WebGLFilterManager
* @constructor
*/
PIXI.WebGLFilterManager = function()
{
    /**
     * @property filterStack
     * @type Array
     */
    this.filterStack = [];
    
    /**
     * @property offsetX
     * @type Number
     */
    this.offsetX = 0;

    /**
     * @property offsetY
     * @type Number
     */
    this.offsetY = 0;
};

PIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager;

/**
* Initialises the context and the properties.
* 
* @method setContext 
* @param gl {WebGLContext} the current WebGL drawing context
*/
PIXI.WebGLFilterManager.prototype.setContext = function(gl)
{
    this.gl = gl;
    this.texturePool = [];

    this.initShaderBuffers();
};

/**
* @method begin
* @param renderSession {RenderSession} 
* @param buffer {ArrayBuffer} 
*/
PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)
{
    this.renderSession = renderSession;
    this.defaultShader = renderSession.shaderManager.defaultShader;

    var projection = this.renderSession.projection;
    this.width = projection.x * 2;
    this.height = -projection.y * 2;
    this.buffer = buffer;
};

/**
* Applies the filter and adds it to the current filter stack.
* 
* @method pushFilter
* @param filterBlock {Object} the filter that will be pushed to the current filter stack
*/
PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)
{
    var gl = this.gl;

    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();
    
    // >>> modify by nextht
    filterBlock._previous_stencil_mgr = this.renderSession.stencilManager;
    this.renderSession.stencilManager = new PIXI.WebGLStencilManager();
    this.renderSession.stencilManager.setContext(gl);
    gl.disable(gl.STENCIL_TEST);
    // <<<  modify by nextht 
   
    // filter program
    // OPTIMISATION - the first filter is free if its a simple color change?
    this.filterStack.push(filterBlock);

    var filter = filterBlock.filterPasses[0];

    this.offsetX += filterBlock._filterArea.x;
    this.offsetY += filterBlock._filterArea.y;

    var texture = this.texturePool.pop();
    if(!texture)
    {
        texture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
    }
    else
    {
        texture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
    }

    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);

    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;

    var padding = filter.padding;
    filterArea.x -= padding;
    filterArea.y -= padding;
    filterArea.width += padding * 2;
    filterArea.height += padding * 2;

    // cap filter to screen size..
    if(filterArea.x < 0)filterArea.x = 0;
    if(filterArea.width > this.width)filterArea.width = this.width;
    if(filterArea.y < 0)filterArea.y = 0;
    if(filterArea.height > this.height)filterArea.height = this.height;

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);

    // set view port
    gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);

    projection.x = filterArea.width/2;
    projection.y = -filterArea.height/2;

    offset.x = -filterArea.x;
    offset.y = -filterArea.y;

    // update projection
    // now restore the regular shader..
    // this.renderSession.shaderManager.setShader(this.defaultShader);
    //gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);
    //gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);

    gl.colorMask(true, true, true, true);
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    filterBlock._glFilterTexture = texture;

};

/**
* Removes the last filter from the filter stack and doesn't return it.
* 
* @method popFilter
*/
PIXI.WebGLFilterManager.prototype.popFilter = function()
{
    var gl = this.gl;
    var filterBlock = this.filterStack.pop();
    var filterArea = filterBlock._filterArea;
    var texture = filterBlock._glFilterTexture;
    var projection = this.renderSession.projection;
    var offset = this.renderSession.offset;

    if(filterBlock.filterPasses.length > 1)
    {
        gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        this.vertexArray[0] = 0;
        this.vertexArray[1] = filterArea.height;

        this.vertexArray[2] = filterArea.width;
        this.vertexArray[3] = filterArea.height;

        this.vertexArray[4] = 0;
        this.vertexArray[5] = 0;

        this.vertexArray[6] = filterArea.width;
        this.vertexArray[7] = 0;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        // now set the uvs..
        this.uvArray[2] = filterArea.width/this.width;
        this.uvArray[5] = filterArea.height/this.height;
        this.uvArray[6] = filterArea.width/this.width;
        this.uvArray[7] = filterArea.height/this.height;

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

        var inputTexture = texture;
        var outputTexture = this.texturePool.pop();
        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
        outputTexture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);

        // need to clear this FBO as it may have some left over elements from a previous filter.
        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.disable(gl.BLEND);

        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)
        {
            var filterPass = filterBlock.filterPasses[i];

            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );

            // set texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

            // draw texture..
            //filterPass.applyFilterPass(filterArea.width, filterArea.height);
            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);

            // swap the textures..
            var temp = inputTexture;
            inputTexture = outputTexture;
            outputTexture = temp;
        }

        gl.enable(gl.BLEND);

        texture = inputTexture;
        this.texturePool.push(outputTexture);
    }

    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];

    this.offsetX -= filterArea.x;
    this.offsetY -= filterArea.y;

    var sizeX = this.width;
    var sizeY = this.height;

    var offsetX = 0;
    var offsetY = 0;

    var buffer = this.buffer;

    // time to render the filters texture to the previous scene
    if(this.filterStack.length === 0)
    {
        gl.colorMask(true, true, true, true);//this.transparent);
    }
    else
    {
        var currentFilter = this.filterStack[this.filterStack.length-1];
        filterArea = currentFilter._filterArea;

        sizeX = filterArea.width;
        sizeY = filterArea.height;

        offsetX = filterArea.x;
        offsetY = filterArea.y;

        buffer =  currentFilter._glFilterTexture.frameBuffer;
    }

    // TODO need to remove these global elements..
    projection.x = sizeX/2;
    projection.y = -sizeY/2;

    offset.x = offsetX;
    offset.y = offsetY;

    filterArea = filterBlock._filterArea;

    var x = filterArea.x-offsetX;
    var y = filterArea.y-offsetY;

    // update the buffers..
    // make sure to flip the y!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    this.vertexArray[0] = x;
    this.vertexArray[1] = y + filterArea.height;

    this.vertexArray[2] = x + filterArea.width;
    this.vertexArray[3] = y + filterArea.height;

    this.vertexArray[4] = x;
    this.vertexArray[5] = y;

    this.vertexArray[6] = x + filterArea.width;
    this.vertexArray[7] = y;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

    this.uvArray[2] = filterArea.width/this.width;
    this.uvArray[5] = filterArea.height/this.height;
    this.uvArray[6] = filterArea.width/this.width;
    this.uvArray[7] = filterArea.height/this.height;

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);

    gl.viewport(0, 0, sizeX * this.renderSession.resolution, sizeY * this.renderSession.resolution);

    // bind the buffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );

    // set the blend mode! 
    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)

    // set texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture.texture);

    // >>> modify by nextht
    if (this.renderSession.stencilManager) {
        this.renderSession.stencilManager.destroy();
    }
    this.renderSession.stencilManager = filterBlock._previous_stencil_mgr;
    filterBlock._previous_stencil_mgr = null;
    if (this.renderSession.stencilManager.count > 0) {
        gl.enable(gl.STENCIL_TEST);
    }
    else {
        gl.disable(gl.STENCIL_TEST);
    }    
    // <<< modify by nextht

    // apply!
    this.applyFilterPass(filter, filterArea, sizeX, sizeY);

    // now restore the regular shader.. should happen automatically now..
    // this.renderSession.shaderManager.setShader(this.defaultShader);
    // gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);
    // gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);

    // return the texture to the pool
    this.texturePool.push(texture);
    filterBlock._glFilterTexture = null;
};


/**
* Applies the filter to the specified area.
* 
* @method applyFilterPass
* @param filter {Phaser.Filter} the filter that needs to be applied
* @param filterArea {Texture} TODO - might need an update
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
*/
PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)
{
    // use program
    var gl = this.gl;
    var shader = filter.shaders[gl.id];

    if(!shader)
    {
        shader = new PIXI.PixiShader(gl);

        shader.fragmentSrc = filter.fragmentSrc;
        shader.uniforms = filter.uniforms;
        shader.init(true);

        filter.shaders[gl.id] = shader;
    }

    // set the shader
    this.renderSession.shaderManager.setShader(shader);

//    gl.useProgram(shader.program);

    gl.uniform2f(shader.projectionVector, width/2, -height/2);
    gl.uniform2f(shader.offsetVector, 0,0);

    if(filter.uniforms.dimensions)
    {
        filter.uniforms.dimensions.value[0] = this.width;//width;
        filter.uniforms.dimensions.value[1] = this.height;//height;
        filter.uniforms.dimensions.value[2] = this.vertexArray[0];
        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;
    }

    shader.syncUniforms();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // draw the filter...
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    this.renderSession.drawCount++;
};

/**
* Initialises the shader buffers.
* 
* @method initShaderBuffers
*/
PIXI.WebGLFilterManager.prototype.initShaderBuffers = function()
{
    var gl = this.gl;

    // create some buffers
    this.vertexBuffer = gl.createBuffer();
    this.uvBuffer = gl.createBuffer();
    this.colorBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // bind and upload the vertexs..
    // keep a reference to the vertexFloatData..
    this.vertexArray = new Float32Array([0.0, 0.0,
                                         1.0, 0.0,
                                         0.0, 1.0,
                                         1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);

    // bind and upload the uv buffer
    this.uvArray = new Float32Array([0.0, 0.0,
                                     1.0, 0.0,
                                     0.0, 1.0,
                                     1.0, 1.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);

    this.colorArray = new Float32Array([1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF,
                                        1.0, 0xFFFFFF]);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);

    // bind and upload the index
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), gl.STATIC_DRAW);

};

/**
* Destroys the filter and removes it from the filter stack.
* 
* @method destroy
*/
PIXI.WebGLFilterManager.prototype.destroy = function()
{
    var gl = this.gl;

    this.filterStack = null;
    
    this.offsetX = 0;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++) {
        this.texturePool[i].destroy();
    }
    
    this.texturePool = null;

    //destroy buffers..
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.uvBuffer);
    gl.deleteBuffer(this.colorBuffer);
    gl.deleteBuffer(this.indexBuffer);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

function _CreateEmptyTexture(gl, width, height, scaleMode) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    return texture;
}

var _fbErrors = {
    36054: 'Incomplete attachment',
    36055: 'Missing attachment',
    36057: 'Incomplete dimensions',
    36061: 'Framebuffer unsupported'
};

function _CreateFramebuffer(gl, width, height, scaleMode, textureUnit) {
    var framebuffer = gl.createFramebuffer();
    var depthStencilBuffer = gl.createRenderbuffer();
    var colorBuffer = null;   
    var fbStatus = 0;
    
    gl.activeTexture(gl.TEXTURE0 + textureUnit);
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
    colorBuffer = _CreateEmptyTexture(gl, width, height, scaleMode);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer, 0);        
    fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if(fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
        console.error('Incomplete GL framebuffer. ', _fbErrors[fbStatus]);
    }
    framebuffer.width = width;
    framebuffer.height = height;
    framebuffer.targetTexture = colorBuffer;
    framebuffer.renderBuffer = depthStencilBuffer;
    return framebuffer;
}

/**
* @class FilterTexture
* @constructor
* @param gl {WebGLContext} the current WebGL drawing context
* @param width {Number} the horizontal range of the filter
* @param height {Number} the vertical range of the filter
* @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values
*/
PIXI.FilterTexture = function(gl, width, height, scaleMode, textureUnit)
{
    textureUnit = typeof textureUnit === 'number' ? textureUnit : 0;
    /**
     * @property gl
     * @type WebGLContext
     */
    this.gl = gl;
    // next time to create a frame buffer and texture

    /**
     * @property frameBuffer
     * @type Any
     */
     this.frameBuffer = _CreateFramebuffer(gl, width, height, scaleMode || PIXI.scaleModes.DEFAULT, textureUnit);
    /**
     * @property texture
     * @type Any
     */
     this.texture = this.frameBuffer.targetTexture;
     this.width = width;
     this.height = height;
     this.renderBuffer = this.frameBuffer.renderBuffer;
};

PIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture;

/**
* Clears the filter texture.
* 
* @method clear
*/
PIXI.FilterTexture.prototype.clear = function()
{
    var gl = this.gl;
    
    gl.clearColor(0,0,0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
 * Resizes the texture to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
PIXI.FilterTexture.prototype.resize = function(width, height)
{
    if(this.width === width && this.height === height) return;

    this.width = width;
    this.height = height;

    var gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D,  this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width , height , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    // update the stencil buffer width and height
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width , height );
};

/**
* Destroys the filter texture.
* 
* @method destroy
*/
PIXI.FilterTexture.prototype.destroy = function()
{
    var gl = this.gl;
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * Creates a Canvas element of the given size.
 *
 * @class CanvasBuffer
 * @constructor
 * @param width {Number} the width for the newly created canvas
 * @param height {Number} the height for the newly created canvas
 */
PIXI.CanvasBuffer = function(width, height)
{
    /**
     * The width of the Canvas in pixels.
     *
     * @property width
     * @type Number
     */
    this.width = width;

    /**
     * The height of the Canvas in pixels.
     *
     * @property height
     * @type Number
     */
    this.height = height;

    /**
     * The Canvas object that belongs to this CanvasBuffer.
     *
     * @property canvas
     * @type HTMLCanvasElement
     */
    this.canvas = Phaser.CanvasPool.create(this, this.width, this.height);

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.context = this.canvas.getContext("2d");

    this.canvas.width = width;
    this.canvas.height = height;
};

PIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer;

/**
 * Clears the canvas that was created by the CanvasBuffer class.
 *
 * @method clear
 * @private
 */
PIXI.CanvasBuffer.prototype.clear = function()
{
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0,0, this.width, this.height);
};

/**
 * Resizes the canvas to the specified width and height.
 *
 * @method resize
 * @param width {Number} the new width of the canvas
 * @param height {Number} the new height of the canvas
 */
PIXI.CanvasBuffer.prototype.resize = function(width, height)
{
    this.width = this.canvas.width = width;
    this.height = this.canvas.height = height;
};

/**
 * Frees the canvas up for use again.
 *
 * @method destroy
 */
PIXI.CanvasBuffer.prototype.destroy = function()
{
    Phaser.CanvasPool.remove(this);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A set of functions used to handle masking.
 *
 * @class CanvasMaskManager
 * @constructor
 */
PIXI.CanvasMaskManager = function()
{
};

PIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager;

/**
 * This method adds it to the current stack of masks.
 *
 * @method pushMask
 * @param maskData {Object} the maskData that will be pushed
 * @param renderSession {Object} The renderSession whose context will be used for this mask manager.
 */
PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession) {

	var context = renderSession.context;

    context.save();
    
    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;

    var resolution = renderSession.resolution;

    context.setTransform(transform.a * resolution,
                         transform.b * resolution,
                         transform.c * resolution,
                         transform.d * resolution,
                         transform.tx * resolution,
                         transform.ty * resolution);

    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);

    context.clip();

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied.
 *
 * @method popMask
 * @param renderSession {Object} The renderSession whose context will be used for this mask manager.
 */
PIXI.CanvasMaskManager.prototype.popMask = function(renderSession)
{
    renderSession.context.restore();
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * Utility methods for Sprite/Texture tinting.
 *
 * @class CanvasTinter
 * @static
 */
PIXI.CanvasTinter = function() {};

/**
 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
 * 
 * @method getTintedTexture 
 * @static
 * @param sprite {Sprite} the sprite to tint
 * @param color {Number} the color to use to tint the sprite with
 * @return {HTMLCanvasElement} The tinted canvas
 */
PIXI.CanvasTinter.getTintedTexture = function(sprite, color)
{
    var canvas = sprite.tintedTexture || Phaser.CanvasPool.create(this);
    
    PIXI.CanvasTinter.tintMethod(sprite.texture, color, canvas);

    return canvas;
};

/**
 * Tint a texture using the "multiply" operation.
 * 
 * @method tintWithMultiply
 * @static
 * @param texture {Texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)
{
    var context = canvas.getContext("2d");

    var crop = texture.crop;
    var w = crop.width;
    var h = crop.height;

    if (texture.rotated)
    {
        w = h;
        h = crop.width;
    }

    if (canvas.width !== w || canvas.height !== h)
    {
        canvas.width = w;
        canvas.height = h;
    }

    context.clearRect(0, 0, w, h);

    context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, w, h);

    context.globalCompositeOperation = "multiply";
    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);

    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);

};

/**
 * Tint a texture pixel per pixel.
 * 
 * @method tintPerPixel
 * @static
 * @param texture {Texture} the texture to tint
 * @param color {Number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */ 
PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)
{
    var context = canvas.getContext("2d");

    var crop = texture.crop;
    var w = crop.width;
    var h = crop.height;

    if (texture.rotated)
    {
        w = h;
        h = crop.width;
    }

    if (canvas.width !== w || canvas.height !== h)
    {
        canvas.width = w;
        canvas.height = h;
    }
  
    context.globalCompositeOperation = "copy";

    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);

    var rgbValues = Phaser.Color.hexToRGBArray(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, w, h);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i + 0] *= r;
        pixels[i + 1] *= g;
        pixels[i + 2] *= b;

        if (!PIXI.CanvasTinter.canHandleAlpha)
        {
            var alpha = pixels[i + 3];

            pixels[i + 0] /= 255 / alpha;
            pixels[i + 1] /= 255 / alpha;
            pixels[i + 2] /= 255 / alpha;
        }
    }

    context.putImageData(pixelData, 0, 0);
};


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * The CanvasRenderer draws the Stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class CanvasRenderer
 * @constructor
 * @param game {Phaser.Game} A reference to the Phaser Game instance
 */
PIXI.CanvasRenderer = function (game) {

    /**
    * @property {Phaser.Game} game - A reference to the Phaser Game instance.
    */
    this.game = game;

    if (!PIXI.defaultRenderer)
    {
        PIXI.defaultRenderer = this;
    }

    /**
     * The renderer type.
     *
     * @property type
     * @type Number
     */
    this.type = Phaser.CANVAS;

    /**
     * The resolution of the canvas.
     *
     * @property resolution
     * @type Number
     */
    this.resolution = game.resolution;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @property clearBeforeRender
     * @type Boolean
     * @default
     */
    this.clearBeforeRender = game.clearBeforeRender;

    /**
     * Whether the render view is transparent
     *
     * @property transparent
     * @type Boolean
     */
    this.transparent = game.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @property autoResize
     * @type Boolean
     */
    this.autoResize = false;

    /**
     * The width of the canvas view
     *
     * @property width
     * @type Number
     * @default 800
     */
    this.width = game.width * this.resolution;

    /**
     * The height of the canvas view
     *
     * @property height
     * @type Number
     * @default 600
     */
    this.height = game.height * this.resolution;

    /**
     * The canvas element that everything is drawn to.
     *
     * @property view
     * @type HTMLCanvasElement
     */
    this.view = game.canvas;

    /**
     * The canvas 2d context that everything is drawn with
     * @property context
     * @type CanvasRenderingContext2D
     */
    this.context = this.view.getContext("2d", { alpha: this.transparent } );

    /**
     * Boolean flag controlling canvas refresh.
     *
     * @property refresh
     * @type Boolean
     */
    this.refresh = true;

    /**
     * Internal var.
     *
     * @property count
     * @type Number
     */
    this.count = 0;

    /**
     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer
     * @property CanvasMaskManager
     * @type CanvasMaskManager
     */
    this.maskManager = new PIXI.CanvasMaskManager();

    /**
     * The render session is just a bunch of parameter used for rendering
     * @property renderSession
     * @type Object
     */
    this.renderSession = {
        context: this.context,
        maskManager: this.maskManager,
        scaleMode: null,
        smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),

        /**
         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Handy for crisp pixel art and speed on legacy devices.
         */
        roundPixels: false
    };

    this.mapBlendModes();
    
    this.resize(this.width, this.height);

};

// constructor
PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;

/**
 * Renders the DisplayObjectContainer, usually the Phaser.Stage, to this canvas view.
 *
 * @method render
 * @param root {Phaser.Stage|PIXI.DisplayObjectContainer} The root element to be rendered.
 */
PIXI.CanvasRenderer.prototype.render = function (root) {

    this.context.setTransform(1, 0, 0, 1, 0, 0);

    this.context.globalAlpha = 1;

    this.renderSession.currentBlendMode = 0;
    this.renderSession.shakeX = this.game.camera._shake.x;
    this.renderSession.shakeY = this.game.camera._shake.y;

    this.context.globalCompositeOperation = 'source-over';

    if (navigator.isCocoonJS && this.view.screencanvas)
    {
        this.context.fillStyle = "black";
        this.context.clear();
    }
    
    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        else if (root._bgColor)
        {
            this.context.fillStyle = root._bgColor.rgba;
            this.context.fillRect(0, 0, this.width , this.height);
        }
    }
    
    this.renderDisplayObject(root);

};

PIXI.CanvasRenderer.prototype.setTexturePriority = function (textureNameCollection) {

    //  Does nothing on Canvas, but here to allow you to simply set
    //  `game.renderer.setTexturePriority()` without having to worry about
    //  running in WebGL or not.

};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @method destroy
 * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.
 */
PIXI.CanvasRenderer.prototype.destroy = function (removeView) {

    if (removeView === undefined) { removeView = true; }

    if (removeView && this.view.parent)
    {
        this.view.parent.removeChild(this.view);
    }

    this.view = null;
    this.context = null;
    this.maskManager = null;
    this.renderSession = null;

};

/**
 * Resizes the canvas view to the specified width and height
 *
 * @method resize
 * @param width {Number} the new width of the canvas view
 * @param height {Number} the new height of the canvas view
 */
PIXI.CanvasRenderer.prototype.resize = function (width, height) {

    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize)
    {
        this.view.style.width = this.width / this.resolution + "px";
        this.view.style.height = this.height / this.resolution + "px";
    }

    if (this.renderSession.smoothProperty)
    {
        this.context[this.renderSession.smoothProperty] = (this.renderSession.scaleMode === PIXI.scaleModes.LINEAR);
    }

};

/**
 * Renders a display object
 *
 * @method renderDisplayObject
 * @param displayObject {DisplayObject} The displayObject to render
 * @param context {CanvasRenderingContext2D} the context 2d method of the canvas
 * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.
 * @private
 */
PIXI.CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context, matrix) {

    this.renderSession.context = context || this.context;
    this.renderSession.resolution = this.resolution;
    displayObject._renderCanvas(this.renderSession, matrix);

};

/**
 * Maps Pixi blend modes to canvas blend modes.
 *
 * @method mapBlendModes
 * @private
 */
PIXI.CanvasRenderer.prototype.mapBlendModes = function () {

    if (!PIXI.blendModesCanvas)
    {
        var b = [];
        var modes = PIXI.blendModes;
        var useNew = this.game.device.canUseMultiply;

        b[modes.NORMAL] = 'source-over';
        b[modes.ADD] = 'lighter';
        b[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';
        b[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';
        b[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';
        b[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';
        b[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';
        b[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';
        b[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';
        b[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';
        b[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';
        b[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';
        b[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';
        b[modes.HUE] = (useNew) ? 'hue' : 'source-over';
        b[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';
        b[modes.COLOR] = (useNew) ? 'color' : 'source-over';
        b[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';

        PIXI.blendModesCanvas = b;
    }

};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class BaseTexture
 * @constructor
 * @param source {String|Canvas} the source object (image or canvas)
 * @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values
 * @param [resolution] {Number} the resolution of the texture (for HiDPI displays)
 */
PIXI.BaseTexture = function(source, scaleMode, resolution)
{
    /**
     * The Resolution of the texture. 
     *
     * @property resolution
     * @type Number
     */
    this.resolution = resolution || 1;
    
    /**
     * [read-only] The width of the base texture set when the image has loaded
     *
     * @property width
     * @type Number
     * @readOnly
     */
    this.width = 100;

    /**
     * [read-only] The height of the base texture set when the image has loaded
     *
     * @property height
     * @type Number
     * @readOnly
     */
    this.height = 100;

    /**
     * The scale mode to apply when scaling this texture
     * 
     * @property scaleMode
     * @type {Number}
     * @default PIXI.scaleModes.LINEAR
     */
    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;

    /**
     * [read-only] Set to true once the base texture has loaded
     *
     * @property hasLoaded
     * @type Boolean
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * The image source that is used to create the texture.
     *
     * @property source
     * @type Image
     */
    this.source = source;

    /**
     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
     *
     * @property premultipliedAlpha
     * @type Boolean
     * @default true
     */
    this.premultipliedAlpha = true;

    // used for webGL

    /**
     * @property _glTextures
     * @type Array
     * @private
     */
    this._glTextures = [];

    /**
     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
     * Also the texture must be a power of two size to work
     * 
     * @property mipmap
     * @type {Boolean}
     */
    this.mipmap = false;

     /**
     * The multi texture batching index number.
     * @property textureIndex
     * @type Number
     */
    this.textureIndex = 0;

    /**
     * @property _dirty
     * @type Array
     * @private
     */
    this._dirty = [true, true, true, true];

    if (!source)
    {
        return;
    }

    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this.hasLoaded = true;
        this.width = this.source.naturalWidth || this.source.width;
        this.height = this.source.naturalHeight || this.source.height;
        this.dirty();
    }

    /**
     * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.
     * 
     * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)
     * that has children that you do want to render, without causing a batch flush in the process.
     * 
     * @property skipRender
     * @type Boolean
     */
    this.skipRender = false;

    /**
     * @property _powerOf2
     * @type Boolean
     * @private
     */
    this._powerOf2 = false;

};

PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;

/**
 * Forces this BaseTexture to be set as loaded, with the given width and height.
 * Then calls BaseTexture.dirty.
 * Important for when you don't want to modify the source object by forcing in `complete` or dimension properties it may not have.
 *
 * @method forceLoaded
 * @param {number} width - The new width to force the BaseTexture to be.
 * @param {number} height - The new height to force the BaseTexture to be.
 */
PIXI.BaseTexture.prototype.forceLoaded = function(width, height)
{
    this.hasLoaded = true;
    this.width = width;
    this.height = height;
    this.dirty();
};

/**
 * Destroys this base texture
 *
 * @method destroy
 */
PIXI.BaseTexture.prototype.destroy = function()
{
    if (this.source)
    {
        Phaser.CanvasPool.removeByCanvas(this.source);
    }

    this.source = null;

    this.unloadFromGPU();
};

/**
 * Changes the source image of the texture
 *
 * @method updateSourceImage
 * @param newSrc {String} the path of the image
 * @deprecated This method is deprecated. Please use Phaser.Sprite.loadTexture instead.
 */
PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)
{
    console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.");
};

/**
 * Sets all glTextures to be dirty.
 *
 * @method dirty
 */
PIXI.BaseTexture.prototype.dirty = function()
{
    for (var i = 0; i < this._glTextures.length; i++)
    {
        this._dirty[i] = true;
    }
};

/**
 * Removes the base texture from the GPU, useful for managing resources on the GPU.
 * Atexture is still 100% usable and will simply be reuploaded if there is a sprite on screen that is using it.
 *
 * @method unloadFromGPU
 */
PIXI.BaseTexture.prototype.unloadFromGPU = function()
{
    this.dirty();

    // delete the webGL textures if any.
    for (var i = this._glTextures.length - 1; i >= 0; i--)
    {
        var glTexture = this._glTextures[i];
        var gl = PIXI.glContexts[i];

        if(gl && glTexture)
        {
            gl.deleteTexture(glTexture);
        }
        
    }

    this._glTextures.length = 0;

    this.dirty();
};

/**
 * Helper function that creates a base texture from the given canvas element.
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values
 * @param [resolution] {Number} the resolution of the texture (for HiDPI displays)
 * @return {BaseTexture}
 */
PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode, resolution)
{
    if (canvas.width === 0)
    {
        canvas.width = 1;
    }

    if (canvas.height === 0)
    {
        canvas.height = 1;
    }

    resolution = resolution || 1;

    return new PIXI.BaseTexture(canvas, scaleMode, resolution);
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * TextureSilentFail is a boolean that defaults to `false`. 
 * If `true` then `PIXI.Texture.setFrame` will no longer throw an error if the texture dimensions are incorrect. 
 * Instead `Texture.valid` will be set to `false` (#1556)
 *
 * @type {boolean}
 */
PIXI.TextureSilentFail = false;

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a PIXI.Sprite. If no frame is provided then the whole image is used.
 *
 * @class Texture
 * @constructor
 * @param baseTexture {BaseTexture} The base texture source to create the texture from
 * @param frame {Rectangle} The rectangle frame of the texture to show
 * @param [crop] {Rectangle} The area of original texture 
 * @param [trim] {Rectangle} Trimmed texture rectangle
 */
PIXI.Texture = function(baseTexture, frame, crop, trim)
{
    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @property noFrame
     * @type Boolean
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new PIXI.Rectangle(0,0,1,1);
    }

    if (baseTexture instanceof PIXI.Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

    /**
     * The base texture that this texture uses.
     *
     * @property baseTexture
     * @type BaseTexture
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @property frame
     * @type Rectangle
     */
    this.frame = frame;

    /**
     * The texture trim data.
     *
     * @property trim
     * @type Rectangle
     */
    this.trim = trim;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @property valid
     * @type Boolean
     */
    this.valid = false;

    /**
     * Is this a tiling texture? As used by the likes of a TilingSprite.
     *
     * @property isTiling
     * @type Boolean
     */
    this.isTiling = false;

    /**
     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
     *
     * @property requiresUpdate
     * @type Boolean
     */
    this.requiresUpdate = false;

    /**
     * This will let a renderer know that a tinted parent has updated its texture.
     *
     * @property requiresReTint
     * @type Boolean
     */
    this.requiresReTint = false;

    /**
     * The WebGL UV data cache.
     *
     * @property _uvs
     * @type Object
     * @private
     */
    this._uvs = null;

    /**
     * The width of the Texture in pixels.
     *
     * @property width
     * @type Number
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @property height
     * @type Number
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @property crop
     * @type Rectangle
     */
    this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1);

    /**
     * A flag that controls if this frame is rotated or not.
     * Rotation allows you to use rotated frames in texture atlas packing, it has nothing to do with
     * Sprite rotation.
     *
     * @property rotated
     * @type Boolean
     */
    this.rotated = false;

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        this.setFrame(frame);
    }

};

PIXI.Texture.prototype.constructor = PIXI.Texture;

/**
 * Called when the base texture is loaded
 *
 * @method onBaseTextureLoaded
 * @private
 */
PIXI.Texture.prototype.onBaseTextureLoaded = function()
{
    var baseTexture = this.baseTexture;

    if (this.noFrame)
    {
        this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    }

    this.setFrame(this.frame);
};

/**
 * Destroys this texture
 *
 * @method destroy
 * @param destroyBase {Boolean} Whether to destroy the base texture as well
 */
PIXI.Texture.prototype.destroy = function(destroyBase)
{
    if (destroyBase) this.baseTexture.destroy();

    this.valid = false;
};

/**
 * Specifies the region of the baseTexture that this texture will use.
 *
 * @method setFrame
 * @param frame {Rectangle} The frame of the texture to set it to
 */
PIXI.Texture.prototype.setFrame = function(frame)
{
    this.noFrame = false;

    this.frame = frame;
    this.width = frame.width;
    this.height = frame.height;

    this.crop.x = frame.x;
    this.crop.y = frame.y;
    this.crop.width = frame.width;
    this.crop.height = frame.height;

    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
    {
        if (!PIXI.TextureSilentFail)
        {
            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
        }

        this.valid = false;
        return;
    }

    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;

    if (this.trim)
    {
        this.width = this.trim.width;
        this.height = this.trim.height;
        this.frame.width = this.trim.width;
        this.frame.height = this.trim.height;
    }
    
    if (this.valid) this._updateUvs();

};

/**
 * Updates the internal WebGL UV cache.
 *
 * @method _updateUvs
 * @private
 */
PIXI.Texture.prototype._updateUvs = function()
{
    if(!this._uvs)this._uvs = new PIXI.TextureUvs();

    var frame = this.crop;
    var tw = this.baseTexture.width;
    var th = this.baseTexture.height;
    
    this._uvs.x0 = frame.x / tw;
    this._uvs.y0 = frame.y / th;

    this._uvs.x1 = (frame.x + frame.width) / tw;
    this._uvs.y1 = frame.y / th;

    this._uvs.x2 = (frame.x + frame.width) / tw;
    this._uvs.y2 = (frame.y + frame.height) / th;

    this._uvs.x3 = frame.x / tw;
    this._uvs.y3 = (frame.y + frame.height) / th;
};

/**
 * Updates the internal WebGL UV cache.
 *
 * @method _updateUvsInverted
 * @private
 */
PIXI.Texture.prototype._updateUvsInverted = function () {

    if (!this._uvs) { this._uvs = new PIXI.TextureUvs(); }

    var frame = this.crop;
    var tw = this.baseTexture.width;
    var th = this.baseTexture.height;
    
    this._uvs.x0 = frame.x / tw;
    this._uvs.y0 = frame.y / th;

    this._uvs.x1 = (frame.x + frame.height) / tw;
    this._uvs.y1 = frame.y / th;

    this._uvs.x2 = (frame.x + frame.height) / tw;
    this._uvs.y2 = (frame.y + frame.width) / th;

    this._uvs.x3 = frame.x / tw;
    this._uvs.y3 = (frame.y + frame.width) / th;

};

/**
 * Helper function that creates a new a Texture based on the given canvas element.
 *
 * @static
 * @method fromCanvas
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {Number} See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values
 * @return {Texture}
 */
PIXI.Texture.fromCanvas = function(canvas, scaleMode)
{
    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);

    return new PIXI.Texture(baseTexture);
};

PIXI.TextureUvs = function()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;
};

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = PIXI;
        }
        exports.PIXI = PIXI;
    } else if (typeof define !== 'undefined' && define.amd) {
        define('PIXI', (function() { return root.PIXI = PIXI; })() );
    } else {
        root.PIXI = PIXI;
    }

    return PIXI;
}).call(this);
},{}]},{},[2,1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcGhhc2VyLWNlL2J1aWxkL3AyLmpzIiwibm9kZV9tb2R1bGVzL3BoYXNlci1jZS9idWlsZC9waXhpLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3IwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgcDIuanMgYXV0aG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmZhbHNlKWRlZmluZShlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5wMj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTY2FsYXIgPSBfZGVyZXFfKCcuL1NjYWxhcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKlxuICogQ29udGFpbmVyIGZvciBsaW5lLXJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgTGluZVxuICovXG5mdW5jdGlvbiBMaW5lKCl7fTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d28gbGluZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxpbmVJbnRcbiAqIEBwYXJhbSAge0FycmF5fSAgbDEgICAgICAgICAgTGluZSB2ZWN0b3IgMVxuICogQHBhcmFtICB7QXJyYXl9ICBsMiAgICAgICAgICBMaW5lIHZlY3RvciAyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKi9cbkxpbmUubGluZUludCA9IGZ1bmN0aW9uKGwxLGwyLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgdmFyIGkgPSBbMCwwXTsgLy8gcG9pbnRcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXG4gICAgYTEgPSBsMVsxXVsxXSAtIGwxWzBdWzFdO1xuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xuICAgIGEyID0gbDJbMV1bMV0gLSBsMlswXVsxXTtcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcbiAgICBkZXQgPSBhMSAqIGIyIC0gYTIqYjE7XG4gICAgaWYgKCFTY2FsYXIuZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcbiAgICAgICAgaVswXSA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHEyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbkxpbmUuc2VnbWVudHNJbnRlcnNlY3QgPSBmdW5jdGlvbihwMSwgcDIsIHExLCBxMil7XG4gICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XG4gICB2YXIgZGIgPSBxMlsxXSAtIHExWzFdO1xuXG4gICAvLyBzZWdtZW50cyBhcmUgcGFyYWxsZWxcbiAgIGlmKGRhKmR5IC0gZGIqZHggPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgdmFyIHMgPSAoZHggKiAocTFbMV0gLSBwMVsxXSkgKyBkeSAqIChwMVswXSAtIHExWzBdKSkgLyAoZGEgKiBkeSAtIGRiICogZHgpXG4gICB2YXIgdCA9IChkYSAqIChwMVsxXSAtIHExWzFdKSArIGRiICogKHExWzBdIC0gcDFbMF0pKSAvIChkYiAqIGR4IC0gZGEgKiBkeSlcblxuICAgcmV0dXJuIChzPj0wICYmIHM8PTEgJiYgdD49MCAmJiB0PD0xKTtcbn07XG5cblxufSx7XCIuL1NjYWxhclwiOjR9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKlxuICogUG9pbnQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBjbGFzcyBQb2ludFxuICovXG5mdW5jdGlvbiBQb2ludCgpe307XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFyZWFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUG9pbnQuYXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcbn07XG5cblBvaW50LmxlZnQgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSxiLGMpID4gMDtcbn07XG5cblBvaW50LmxlZnRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPj0gMDtcbn07XG5cblBvaW50LnJpZ2h0ID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8IDA7XG59O1xuXG5Qb2ludC5yaWdodE9uID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8PSAwO1xufTtcblxudmFyIHRtcFBvaW50MSA9IFtdLFxuICAgIHRtcFBvaW50MiA9IFtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHBhcmFtICB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9MF0gVGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGNvbXBhcmluZyB0aGUgdmVjdG9ycy4gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHJlc3VsdGluZyB2ZWN0b3JzIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLiBVc2UgemVybyBmb3IgbWF4IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvaW50LmNvbGxpbmVhciA9IGZ1bmN0aW9uKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XG4gICAgaWYoIXRocmVzaG9sZEFuZ2xlKVxuICAgICAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA9PSAwO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWIgPSB0bXBQb2ludDEsXG4gICAgICAgICAgICBiYyA9IHRtcFBvaW50MjtcblxuICAgICAgICBhYlswXSA9IGJbMF0tYVswXTtcbiAgICAgICAgYWJbMV0gPSBiWzFdLWFbMV07XG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xuICAgICAgICBiY1sxXSA9IGNbMV0tYlsxXTtcblxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcbiAgICAgICAgICAgIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0qYWJbMF0gKyBhYlsxXSphYlsxXSksXG4gICAgICAgICAgICBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdKmJjWzBdICsgYmNbMV0qYmNbMV0pLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XG4gICAgfVxufTtcblxuUG9pbnQuc3FkaXN0ID0gZnVuY3Rpb24oYSxiKXtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBMaW5lID0gX2RlcmVxXyhcIi4vTGluZVwiKVxuLCAgIFBvaW50ID0gX2RlcmVxXyhcIi4vUG9pbnRcIilcbiwgICBTY2FsYXIgPSBfZGVyZXFfKFwiLi9TY2FsYXJcIilcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKipcbiAqIFBvbHlnb24gY2xhc3MuXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvbHlnb24oKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIHRoYXQgdGhpcyBwb2x5Z29uIGNvbnNpc3RzIG9mLiBBbiBhcnJheSBvZiBhcnJheSBvZiBudW1iZXJzLCBleGFtcGxlOiBbWzAsMF0sWzEsMF0sLi5dXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpe1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcyA9IHYubGVuZ3RoO1xuICAgIHJldHVybiB2W2kgPCAwID8gaSAlIHMgKyBzIDogaSAlIHNdO1xufTtcblxuLyoqXG4gKiBHZXQgZmlyc3QgdmVydGV4XG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzWzBdO1xufTtcblxuLyoqXG4gKiBHZXQgbGFzdCB2ZXJ0ZXhcbiAqIEBtZXRob2QgbGFzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXMubGVuZ3RoLTFdO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudmVydGljZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQXBwZW5kIHBvaW50cyBcImZyb21cIiB0byBcInRvXCItMSBmcm9tIGFuIG90aGVyIHBvbHlnb24gXCJwb2x5XCIgb250byB0aGlzIG9uZS5cbiAqIEBtZXRob2QgYXBwZW5kXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBmcm9tIFRoZSB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHBvbHksZnJvbSx0byl7XG4gICAgaWYodHlwZW9mKGZyb20pID09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIkZyb20gaXMgbm90IGdpdmVuIVwiKTtcbiAgICBpZih0eXBlb2YodG8pID09IFwidW5kZWZpbmVkXCIpICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gaXMgbm90IGdpdmVuIVwiKTtcblxuICAgIGlmKHRvLTEgPCBmcm9tKSAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sMVwiKTtcbiAgICBpZih0byA+IHBvbHkudmVydGljZXMubGVuZ3RoKSAgIHRocm93IG5ldyBFcnJvcihcImxvbDJcIik7XG4gICAgaWYoZnJvbSA8IDApICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wzXCIpO1xuXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICogQG1ldGhvZCBtYWtlQ0NXXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLm1ha2VDQ1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiciA9IDAsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFQb2ludC5sZWZ0KHRoaXMuYXQoYnIgLSAxKSwgdGhpcy5hdChiciksIHRoaXMuYXQoYnIgKyAxKSkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGk9MCwgTj10aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHRoaXMudmVydGljZXMucG9wKCkpO1xuICAgIH1cbiAgICB0aGlzLnZlcnRpY2VzID0gdG1wO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1JlZmxleCA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiBQb2ludC5yaWdodCh0aGlzLmF0KGkgLSAxKSwgdGhpcy5hdChpKSwgdGhpcy5hdChpICsgMSkpO1xufTtcblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2FuU2VlID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhICsgMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhIC0gMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXG4gICAgICAgIGlmICgoaSArIDEpICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKFBvaW50LmxlZnRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkgKyAxKSkgJiYgUG9pbnQucmlnaHRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSB0aGlzLmF0KGEpO1xuICAgICAgICAgICAgbDFbMV0gPSB0aGlzLmF0KGIpO1xuICAgICAgICAgICAgbDJbMF0gPSB0aGlzLmF0KGkpO1xuICAgICAgICAgICAgbDJbMV0gPSB0aGlzLmF0KGkgKyAxKTtcbiAgICAgICAgICAgIHAgPSBMaW5lLmxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCBwKSA8IGRpc3QpIHsgLy8gaWYgZWRnZSBpcyBibG9ja2luZyB2aXNpYmlsaXR5IHRvIGJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1BvbHlnb259ICAgICAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgY29weS5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgbmV3IFBvbHlnb24oKTtcbiAgICBwLmNsZWFyKCk7XG4gICAgaWYgKGkgPCBqKSB7XG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxuICAgICAgICBmb3IodmFyIGs9MDsgazw9ajsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxuICAgICAgICBmb3IodmFyIGs9aTsgazx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZ2V0Q3V0RWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gbmV3IFBvbHlnb24oKTtcbiAgICB2YXIgbkRpYWdzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VlKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSB0aGlzLmNvcHkoaSwgaiwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IHRoaXMuY29weShqLCBpLCB0bXBQb2x5KS5nZXRDdXRFZGdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbdGhpcy5hdChpKSwgdGhpcy5hdChqKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZGVjb21wID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEN1dEVkZ2VzKCk7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoZWRnZXMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICogQG1ldGhvZCBzbGljZVxuICogQHBhcmFtIHtBcnJheX0gY3V0RWRnZXMgQSBsaXN0IG9mIGVkZ2VzLCBhcyByZXR1cm5lZCBieSAuZ2V0Q3V0RWRnZXMoKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PSAwKSByZXR1cm4gW3RoaXNdO1xuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFt0aGlzXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHkuc2xpY2UoY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT0gLTEgJiYgaiAhPSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuY29weShpLGopLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHkoaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWV0aG9kIGlzU2ltcGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gU2hvdWxkIGl0IGNoZWNrIGFsbCBzZWdtZW50cyB3aXRoIGFsbCBvdGhlcnM/XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aCA9IHRoaXMudmVydGljZXM7XG4gICAgLy8gQ2hlY2tcbiAgICBmb3IodmFyIGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihMaW5lLnNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKHZhciBpPTE7IGk8cGF0aC5sZW5ndGgtMjsgaSsrKXtcbiAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICAgdmFyIGExID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBiMSA9IHAxWzBdIC0gcDJbMF07XG4gICB2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG4gICB2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuICAgdmFyIGIyID0gcTFbMF0gLSBxMlswXTtcbiAgIHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcbiAgIHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cbiAgIGlmKCFTY2FsYXIuZXEoZGV0LDAsZGVsdGEpKVxuICAgICAgcmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdXG4gICBlbHNlXG4gICAgICByZXR1cm4gWzAsMF1cbn1cblxuLyoqXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnF1aWNrRGVjb21wID0gZnVuY3Rpb24ocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XG4gICAgcmVmbGV4VmVydGljZXMgPSByZWZsZXhWZXJ0aWNlcyB8fCBbXTtcbiAgICBzdGVpbmVyUG9pbnRzID0gc3RlaW5lclBvaW50cyB8fCBbXTtcblxuICAgIHZhciB1cHBlckludD1bMCwwXSwgbG93ZXJJbnQ9WzAsMF0sIHA9WzAsMF07IC8vIFBvaW50c1xuICAgIHZhciB1cHBlckRpc3Q9MCwgbG93ZXJEaXN0PTAsIGQ9MCwgY2xvc2VzdERpc3Q9MDsgLy8gc2NhbGFyc1xuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXG4gICAgdmFyIGxvd2VyUG9seT1uZXcgUG9seWdvbigpLCB1cHBlclBvbHk9bmV3IFBvbHlnb24oKTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHRoaXMsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgbGV2ZWwrKztcbiAgICBpZihsZXZlbCA+IG1heGxldmVsKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seS5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5yaWdodChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSwgcG9seS5hdChqICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS52ZXJ0aWNlc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IHVwcGVyRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT0gKHVwcGVySW5kZXggKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrdGhpcy52ZXJ0aWNlcy5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwgaSwgdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxwb2x5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksbG93ZXJJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVxcblwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgICAgICBpZih1cHBlckluZGV4IDwgbG93ZXJJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxvd2VySW5kZXg7IGogPD0gdXBwZXJJbmRleDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0T24ocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS5hdChpKSwgcG9seS5hdChqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5LnZlcnRpY2VzLmxlbmd0aCA8IHVwcGVyUG9seS52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb3dlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaCh0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucmVtb3ZlQ29sbGluZWFyUG9pbnRzID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IodmFyIGk9dGhpcy52ZXJ0aWNlcy5sZW5ndGgtMTsgdGhpcy52ZXJ0aWNlcy5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xuICAgICAgICBpZihQb2ludC5jb2xsaW5lYXIodGhpcy5hdChpLTEpLHRoaXMuYXQoaSksdGhpcy5hdChpKzEpLHByZWNpc2lvbikpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc3BsaWNlKGkldGhpcy52ZXJ0aWNlcy5sZW5ndGgsMSk7XG4gICAgICAgICAgICBpLS07IC8vIEp1bXAgb25lIHBvaW50IGZvcndhcmQuIE90aGVyd2lzZSB3ZSBtYXkgZ2V0IGEgY2hhaW4gcmVtb3ZhbFxuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn07XG5cbn0se1wiLi9MaW5lXCI6MSxcIi4vUG9pbnRcIjoyLFwiLi9TY2FsYXJcIjo0fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxhcjtcblxuLyoqXG4gKiBTY2FsYXIgZnVuY3Rpb25zXG4gKiBAY2xhc3MgU2NhbGFyXG4gKi9cbmZ1bmN0aW9uIFNjYWxhcigpe31cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXFcbiAqIEBwYXJhbSAge051bWJlcn0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBiXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TY2FsYXIuZXEgPSBmdW5jdGlvbihhLGIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUG9seWdvbiA6IF9kZXJlcV8oXCIuL1BvbHlnb25cIiksXG4gICAgUG9pbnQgOiBfZGVyZXFfKFwiLi9Qb2ludFwiKSxcbn07XG5cbn0se1wiLi9Qb2ludFwiOjIsXCIuL1BvbHlnb25cIjozfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInAyXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuNy4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIEphdmFTY3JpcHQgMkQgcGh5c2ljcyBlbmdpbmUuXCIsXG4gIFwiYXV0aG9yXCI6IFwiU3RlZmFuIEhlZG1hbiA8c2NodGVwcGVAZ21haWwuY29tPiAoaHR0cDovL3N0ZWZmZS5zZSlcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJwMi5qc1wiLFxuICAgIFwicDJcIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiMmRcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL3NyYy9wMi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzLmdpdFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMvaXNzdWVzXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcbiAgICB9XG4gIF0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIl4wLjExLjJcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJeMC40LjFcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXdhdGNoXCI6IFwifjAuNS4wXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjIuMC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbmNhdFwiOiBcIl4wLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInBvbHktZGVjb21wXCI6IFwiMC4xLjFcIlxuICB9XG59XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLCB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGFuZ2xlLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxuICogQHBhcmFtIHtBcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplIFNvbWUgbWFyZ2luIHRvIGJlIGFkZGVkIHRvIHRoZSBBQUJCLlxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcblxuICAgIGlmKHR5cGVvZihhbmdsZSkgIT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgcG9pbnRzWzBdLCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KGwsIHBvaW50c1swXSk7XG4gICAgfVxuICAgIHZlYzIuY29weSh1LCBsKTtcblxuICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgIHRtcFswXSA9IGNvc0FuZ2xlICogeCAtc2luQW5nbGUgKiB5O1xuICAgICAgICAgICAgdG1wWzFdID0gc2luQW5nbGUgKiB4ICtjb3NBbmdsZSAqIHk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcbiAgICAgICAgICAgIGlmKHBbal0gPiB1W2pdKXtcbiAgICAgICAgICAgICAgICB1W2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBbal0gPCBsW2pdKXtcbiAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMubG93ZXJCb3VuZCwgdGhpcy5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMudXBwZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMF0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFsxXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzBdICs9IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMV0gKz0gc2tpblNpemU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMubG93ZXJCb3VuZFtpXSA+IGwpe1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kW2ldID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwcGVyXG4gICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLnVwcGVyQm91bmRbaV0gPCB1KXtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFtpXSA9IHU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgcmV0dXJuICgobDJbMF0gPD0gdTFbMF0gJiYgdTFbMF0gPD0gdTJbMF0pIHx8IChsMVswXSA8PSB1MlswXSAmJiB1MlswXSA8PSB1MVswXSkpICYmXG4gICAgICAgICAgICgobDJbMV0gPD0gdTFbMV0gJiYgdTFbMV0gPD0gdTJbMV0pIHx8IChsMVsxXSA8PSB1MlsxXSAmJiB1MlsxXSA8PSB1MVsxXSkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnRhaW5zUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBwb2ludFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQUFCQi5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHBvaW50KXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICByZXR1cm4gbFswXSA8PSBwb2ludFswXSAmJiBwb2ludFswXSA8PSB1WzBdICYmIGxbMV0gPD0gcG9pbnRbMV0gJiYgcG9pbnRbMV0gPD0gdVsxXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIEFBQkIgaXMgaGl0IGJ5IGEgcmF5LlxuICogQG1ldGhvZCBvdmVybGFwc1JheVxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEByZXR1cm4ge251bWJlcn0gLTEgaWYgbm8gaGl0LCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaWYgaGl0LlxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwc1JheSA9IGZ1bmN0aW9uKHJheSl7XG4gICAgdmFyIHQgPSAwO1xuXG4gICAgLy8gcmF5LmRpcmVjdGlvbiBpcyB1bml0IGRpcmVjdGlvbiB2ZWN0b3Igb2YgcmF5XG4gICAgdmFyIGRpckZyYWNYID0gMSAvIHJheS5kaXJlY3Rpb25bMF07XG4gICAgdmFyIGRpckZyYWNZID0gMSAvIHJheS5kaXJlY3Rpb25bMV07XG5cbiAgICAvLyB0aGlzLmxvd2VyQm91bmQgaXMgdGhlIGNvcm5lciBvZiBBQUJCIHdpdGggbWluaW1hbCBjb29yZGluYXRlcyAtIGxlZnQgYm90dG9tLCBydCBpcyBtYXhpbWFsIGNvcm5lclxuICAgIHZhciB0MSA9ICh0aGlzLmxvd2VyQm91bmRbMF0gLSByYXkuZnJvbVswXSkgKiBkaXJGcmFjWDtcbiAgICB2YXIgdDIgPSAodGhpcy51cHBlckJvdW5kWzBdIC0gcmF5LmZyb21bMF0pICogZGlyRnJhY1g7XG4gICAgdmFyIHQzID0gKHRoaXMubG93ZXJCb3VuZFsxXSAtIHJheS5mcm9tWzFdKSAqIGRpckZyYWNZO1xuICAgIHZhciB0NCA9ICh0aGlzLnVwcGVyQm91bmRbMV0gLSByYXkuZnJvbVsxXSkgKiBkaXJGcmFjWTtcblxuICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSkpO1xuICAgIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSkpO1xuXG4gICAgLy8gaWYgdG1heCA8IDAsIHJheSAobGluZSkgaXMgaW50ZXJzZWN0aW5nIEFBQkIsIGJ1dCB3aG9sZSBBQUJCIGlzIGJlaGluZyB1c1xuICAgIGlmICh0bWF4IDwgMCl7XG4gICAgICAgIC8vdCA9IHRtYXg7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcbiAgICBpZiAodG1pbiA+IHRtYXgpe1xuICAgICAgICAvL3QgPSB0bWF4O1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRtaW47XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLiBTaG91bGQgYmUgc2V0IHRvIEJyb2FkcGhhc2UuQUFCQiBvciBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdWb2x1bWVUeXBlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUgPSBCcm9hZHBoYXNlLkFBQkI7XG59XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFBQkJcbiAqL1xuQnJvYWRwaGFzZS5BQUJCID0gMTtcblxuLyoqXG4gKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcbiAqL1xuQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xuXG4vKipcbiAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe307XG5cbnZhciBkaXN0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZlYzIuc3ViKGRpc3QsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgdmFyIGQyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpLFxuICAgICAgICByID0gYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cztcbiAgICByZXR1cm4gZDIgPD0gcipyO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmFhYmJDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgcmV0dXJuIGJvZHlBLmdldEFBQkIoKS5vdmVybGFwcyhib2R5Qi5nZXRBQUJCKCkpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgc3dpdGNoKHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlKXtcbiAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxuICAgICAgICByZXN1bHQgPSAgQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XG4gICAgICAgIHJlc3VsdCA9IEJyb2FkcGhhc2UuYWFiYkNoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZGluZyB2b2x1bWUgdHlwZSBub3QgcmVjb2duaXplZDogJyt0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgYWxsb3dlZCB0byBjb2xsaWRlIGF0IGFsbC5cbiAqIEBtZXRob2QgIGNhbkNvbGxpZGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5jYW5Db2xsaWRlID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgS0lORU1BVElDID0gQm9keS5LSU5FTUFUSUM7XG4gICAgdmFyIFNUQVRJQyA9IEJvZHkuU1RBVElDO1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IFNUQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIHZzIGtpbmVtYXRpYyBib2RpZXNcbiAgICBpZiggKGJvZHlBLnR5cGUgPT09IEtJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpIHx8XG4gICAgICAgIChib2R5QS50eXBlID09PSBTVEFUSUMgICAgJiYgYm9keUIudHlwZSA9PT0gS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gS0lORU1BVElDICYmIGJvZHlCLnR5cGUgPT09IEtJTkVNQVRJQyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xuICAgIGlmKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBpZiBvbmUgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgc2xlZXBpbmdcbiAgICBpZiggKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIudHlwZSA9PT0gU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBTVEFUSUMpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQnJvYWRwaGFzZS5OQUlWRSA9IDE7XG5Ccm9hZHBoYXNlLlNBUCA9IDI7XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMX1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKSxcbiAgICBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpLFxuICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyksXG4gICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIE5haXZlIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb24uIERvZXMgTl4yIHRlc3RzLlxuICpcbiAqIEBjbGFzcyBOYWl2ZUJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmNhbGwodGhpcywgQnJvYWRwaGFzZS5OQUlWRSk7XG59XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIGZvcih2YXIgaT0wLCBOY29sbGlkaW5nPWJvZGllcy5sZW5ndGg7IGkhPT1OY29sbGlkaW5nOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aTsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3NoYXBlcy9DaXJjbGVcIjozOSxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQzLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDQsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBzdWIgPSB2ZWMyLnN1YlxuLCAgIGFkZCA9IHZlYzIuYWRkXG4sICAgZG90ID0gdmVjMi5kb3RcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBDb250YWN0RXF1YXRpb25Qb29sID0gX2RlcmVxXygnLi4vdXRpbHMvQ29udGFjdEVxdWF0aW9uUG9vbCcpXG4sICAgRnJpY3Rpb25FcXVhdGlvblBvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbCcpXG4sICAgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRnJpY3Rpb25FcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJylcbiwgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICBDb252ZXggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpXG4sICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG4vLyBUZW1wIHRoaW5nc1xudmFyIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbnZhciB0bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXA5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE4ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlLiBDcmVhdGVzIGNvbnRhY3RzIGFuZCBmcmljdGlvbiBnaXZlbiBzaGFwZXMgYW5kIHRyYW5zZm9ybXMuXG4gKiBAY2xhc3MgTmFycm93cGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSgpe1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25FcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGZyaWN0aW9uIGVxdWF0aW9ucyBpbiB0aGUgdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZUZyaWN0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZXF1YXRpb25zIGVuYWJsZWQgaW4gdXBjb21pbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IGVuYWJsZWRFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWRFcXVhdGlvbnMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIHNsaXAgZm9yY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBzbGlwRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xpcEZvcmNlID0gMTAuMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIHVwY29taW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25Db2VmZmljaWVudFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSB0aGUgLnJlbGF0aXZlVmVsb2NpdHkgaW4gZWFjaCBwcm9kdWNlZCBGcmljdGlvbkVxdWF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdXJmYWNlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYWxsb2NhdGVkIENvbnRhY3RFcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb25Qb29sfSBjb250YWN0RXF1YXRpb25Qb29sXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIC8vIEFsbG9jYXRlIGEgZmV3IGVxdWF0aW9ucyBiZWZvcmUgc3RhcnRpbmcgdGhlIHNpbXVsYXRpb24uXG4gICAgICogICAgIC8vIFRoaXMgd2F5LCBubyBjb250YWN0IG9iamVjdHMgbmVlZCB0byBiZSBjcmVhdGVkIG9uIHRoZSBmbHkgaW4gdGhlIGdhbWUgbG9vcC5cbiAgICAgKiAgICAgd29ybGQubmFycm93cGhhc2UuY29udGFjdEVxdWF0aW9uUG9vbC5yZXNpemUoMTAyNCk7XG4gICAgICogICAgIHdvcmxkLm5hcnJvd3BoYXNlLmZyaWN0aW9uRXF1YXRpb25Qb29sLnJlc2l6ZSgxMDI0KTtcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wgPSBuZXcgQ29udGFjdEVxdWF0aW9uUG9vbCh7IHNpemU6IDMyIH0pO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFsbG9jYXRlZCBDb250YWN0RXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7RnJpY3Rpb25FcXVhdGlvblBvb2x9IGZyaWN0aW9uRXF1YXRpb25Qb29sXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IG5ldyBGcmljdGlvbkVxdWF0aW9uUG9vbCh7IHNpemU6IDY0IH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF4YXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSByZWR1Y3Rpb24gb2YgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBkaXNhYmxlZCwgYSBib3ggb24gYSBwbGFuZSB3aWxsIGdlbmVyYXRlIDIgY29udGFjdCBlcXVhdGlvbnMgYW5kIDIgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBlbmFibGVkLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGZyaWN0aW9uIGVxdWF0aW9uLiBTYW1lIGtpbmQgb2Ygc2ltcGxpZmljYXRpb25zIGFyZSBtYWRlICBmb3IgYWxsIGNvbGxpc2lvbiB0eXBlcy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGZlYXR1cmUgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY29sbGlkaW5nIGJvZGllcyBsYXN0IHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXBcbiAgICAgKiBAdHlwZSB7VHVwbGVEaWN0aW9uYXJ5fVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0IHNraW4gc2l6ZSB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDE7XG59XG5cbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BID0gdmVjMi5jcmVhdGUoKTtcbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGJvZGllc092ZXJsYXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIHNoYXBlIHdvcmxkIHRyYW5zZm9ybXMgYXJlIHdyb25nXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib2RpZXNPdmVybGFwID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkEgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BO1xuICAgIHZhciBzaGFwZVBvc2l0aW9uQiA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkI7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHNoYXBlcyBvZiBib2R5QVxuICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1ib2R5QS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgIHZhciBzaGFwZUEgPSBib2R5QS5zaGFwZXNba107XG5cbiAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBzaGFwZUEucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1ib2R5Qi5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdO1xuXG4gICAgICAgICAgICBib2R5Qi50b1dvcmxkRnJhbWUoc2hhcGVQb3NpdGlvbkIsIHNoYXBlQi5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmKHRoaXNbc2hhcGVBLnR5cGUgfCBzaGFwZUIudHlwZV0oXG4gICAgICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICAgICAgc2hhcGVBLFxuICAgICAgICAgICAgICAgIHNoYXBlUG9zaXRpb25BLFxuICAgICAgICAgICAgICAgIHNoYXBlQS5hbmdsZSArIGJvZHlBLmFuZ2xlLFxuICAgICAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgICAgIHNoYXBlQixcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQixcbiAgICAgICAgICAgICAgICBzaGFwZUIuYW5nbGUgKyBib2R5Qi5hbmdsZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZGllcyB3ZXJlIGluIGNvbnRhY3Qgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgY29sbGlkZWRMYXN0U3RlcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29sbGlkZWRMYXN0U3RlcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGlkMSA9IGJvZHlBLmlkfDAsXG4gICAgICAgIGlkMiA9IGJvZHlCLmlkfDA7XG4gICAgcmV0dXJuICEhdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5nZXQoaWQxLCBpZDIpO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYXdheSB0aGUgb2xkIGVxdWF0aW9ucyBhbmQgZ2V0cyByZWFkeSB0byBjcmVhdGUgbmV3XG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5yZXNldCgpO1xuXG4gICAgdmFyIGVxcyA9IHRoaXMuY29udGFjdEVxdWF0aW9ucztcbiAgICB2YXIgbCA9IGVxcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2xdLFxuICAgICAgICAgICAgaWQxID0gZXEuYm9keUEuaWQsXG4gICAgICAgICAgICBpZDIgPSBlcS5ib2R5Qi5pZDtcbiAgICAgICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5zZXQoaWQxLCBpZDIsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucyxcbiAgICAgICAgZmUgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGNlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25Qb29sLnJlbGVhc2UoY2VbaV0pO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxmZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wucmVsZWFzZShmZVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29udGFjdEVxdWF0aW9uLCBlaXRoZXIgYnkgcmV1c2luZyBhbiBleGlzdGluZyBvYmplY3Qgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxuICogQG1ldGhvZCBjcmVhdGVDb250YWN0RXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wuZ2V0KCk7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnJlc3RpdHV0aW9uID0gdGhpcy5yZXN0aXR1dGlvbjtcbiAgICBjLmZpcnN0SW1wYWN0ID0gIXRoaXMuY29sbGlkZWRMYXN0U3RlcChib2R5QSxib2R5Qik7XG4gICAgYy5zdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLnJlbGF4YXRpb247XG4gICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMub2Zmc2V0ID0gdGhpcy5jb250YWN0U2tpblNpemU7XG5cbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24gPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgYyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wuZ2V0KCk7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnNldFNsaXBGb3JjZSh0aGlzLnNsaXBGb3JjZSk7XG4gICAgYy5mcmljdGlvbkNvZWZmaWNpZW50ID0gdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50O1xuICAgIGMucmVsYXRpdmVWZWxvY2l0eSA9IHRoaXMuc3VyZmFjZVZlbG9jaXR5O1xuICAgIGMuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZEVxdWF0aW9ucztcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgYy5yZWxheGF0aW9uID0gdGhpcy5mcmljdGlvblJlbGF4YXRpb247XG4gICAgYy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBGcmljdGlvbkVxdWF0aW9uIGdpdmVuIHRoZSBkYXRhIGluIHRoZSBDb250YWN0RXF1YXRpb24uIFVzZXMgc2FtZSBvZmZzZXQgdmVjdG9ycyByaSBhbmQgcmosIGJ1dCB0aGUgdGFuZ2VudCB2ZWN0b3Igd2lsbCBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb2xsaXNpb24gbm9ybWFsLlxuICogQG1ldGhvZCBjcmVhdGVGcmljdGlvbkZyb21Db250YWN0XG4gKiBAcGFyYW0gIHtDb250YWN0RXF1YXRpb259IGNvbnRhY3RFcXVhdGlvblxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QgPSBmdW5jdGlvbihjKXtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgYy5ub3JtYWxBKTtcbiAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLy8gVGFrZSB0aGUgYXZlcmFnZSBOIGxhdGVzdCBjb250YWN0IHBvaW50IG9uIHRoZSBwbGFuZS5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlID0gZnVuY3Rpb24obnVtQ29udGFjdHMpe1xuICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IGMuYm9keUI7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QSwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QiwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEudCwgMCwgMCk7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBpZihjLmJvZHlBID09PSBib2R5QSl7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMyLnN1YihlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgIH1cbiAgICAgICAgZXEuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuICAgIH1cblxuICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEvbnVtQ29udGFjdHM7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5ub3JtYWxpemUoZXEudCwgZXEudCk7XG4gICAgdmVjMi5yb3RhdGU5MGN3KGVxLnQsIGVxLnQpO1xuICAgIHJldHVybiBlcTtcbn07XG5cbi8qKlxuICogQ29udmV4L2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY29udmV4TGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtIHtib29sZWFufSAgICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhMaW5lID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpbmUvYm94IG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVCb3hcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm94Qm9keVxuICogQHBhcmFtICB7Qm94fSAgYm94U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGJveE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYm94QW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIGp1c3RUZXN0XG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUJveCA9IGZ1bmN0aW9uKFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBib3hCb2R5LFxuICAgIGJveFNoYXBlLFxuICAgIGJveE9mZnNldCxcbiAgICBib3hBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUoY29udmV4U2hhcGUsIGNhcHN1bGVTaGFwZSl7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMF0sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMV0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMl0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbM10sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG59XG5cbnZhciBjb252ZXhDYXBzdWxlX3RlbXBSZWN0ID0gbmV3IEJveCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSksXG4gICAgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb252ZXgvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4UG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhQb3NpdGlvbixcbiAgICBjb252ZXhBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIGlmKGp1c3RUZXN0ICYmIChyZXN1bHQxIHx8IHJlc3VsdDIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcbiAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocixjYXBzdWxlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSxyLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIHJldHVybiByZXN1bHQgKyByZXN1bHQxICsgcmVzdWx0Mjtcbn07XG5cbi8qKlxuICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZVBvc2l0aW9uLFxuICAgIGxpbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxID0gbmV3IEJveCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSk7XG5cbi8qKlxuICogQ2Fwc3VsZS9jYXBzdWxlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNhcHN1bGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2Fwc3VsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvc2kgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSxcbiAgICAgICAgY2lyY2xlUG9zaiA9IGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyO1xuXG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuXG4gICAgLy8gTmVlZCA0IGNpcmNsZSBjaGVja3MsIGJldHdlZW4gYWxsXG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcblxuICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NpLChpPT09MD8tMToxKSpzaS5sZW5ndGgvMiwwKTtcbiAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLGFpKTtcbiAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaSxjaXJjbGVQb3NpLHhpKTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajwyOyBqKyspe1xuXG4gICAgICAgICAgICB2ZWMyLnNldChjaXJjbGVQb3NqLChqPT09MD8tMToxKSpzai5sZW5ndGgvMiwgMCk7XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3NqLGNpcmNsZVBvc2osYWopO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2lyY2xlUG9zaixjaXJjbGVQb3NqLHhqKTtcblxuICAgICAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNpcmNsZUNpcmNsZShiaSxzaSxjaXJjbGVQb3NpLGFpLCBiaixzaixjaXJjbGVQb3NqLGFqLCBqdXN0VGVzdCwgc2kucmFkaXVzLCBzai5yYWRpdXMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjaXJjbGVzIGFnYWluc3QgdGhlIGNlbnRlciBib3hzXG4gICAgdmFyIHJlY3QgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDE7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaSk7XG4gICAgdmFyIHJlc3VsdDEgPSB0aGlzLmNvbnZleENhcHN1bGUoYmkscmVjdCx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0MSl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQxO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNqKTtcbiAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaixyZWN0LHhqLGFqLCBiaSxzaSx4aSxhaSwganVzdFRlc3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQyKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDI7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG4vKipcbiAqIExpbmUvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBsaW5lTGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUFcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25BXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlCXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVCXG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVMaW5lID0gZnVuY3Rpb24oXG4gICAgYm9keUEsXG4gICAgc2hhcGVBLFxuICAgIHBvc2l0aW9uQSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIHBvc2l0aW9uQixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGxhbmUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gIHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lTGluZSA9IGZ1bmN0aW9uKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJvZHksICBsaW5lU2hhcGUsICBsaW5lT2Zmc2V0LCAgbGluZUFuZ2xlLCBqdXN0VGVzdCl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAzLFxuICAgICAgICB3b3JsZFZlcnRleDExID0gdG1wNCxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDYsXG4gICAgICAgIGRpc3QgPSB0bXA3LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDksXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICAvLyBDaGVjayBsaW5lIGVuZHNcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgc3ViKGRpc3QsIHYsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LHdvcmxkTm9ybWFsKTtcblxuICAgICAgICBpZihkIDwgMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksbGluZUJvZHkscGxhbmVTaGFwZSxsaW5lU2hhcGUpO1xuICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIC8vIGRpc3RhbmNlIHZlY3RvciBhbG9uZyBwbGFuZSBub3JtYWxcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgd29ybGROb3JtYWwsIGQpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdiwgZGlzdCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIC8vIEZyb20gbGluZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgICAgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVQb3NpdGlvbixcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUocGFydGljbGVCb2R5LHBhcnRpY2xlU2hhcGUscGFydGljbGVQb3NpdGlvbixwYXJ0aWNsZUFuZ2xlLCBjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2Fwc3VsZVBvc2l0aW9uLGNhcHN1bGVBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMsIDApO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvbGluZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3QgSWYgc2V0IHRvIHRydWUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCAoaW50ZXJzZWN0aW9uIG9yIG5vdCkgd2l0aG91dCBhZGRpbmcgZXF1YXRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVSYWRpdXMgUmFkaXVzIHRvIGFkZCB0byB0aGUgbGluZS4gQ2FuIGJlIHVzZWQgdG8gdGVzdCBDYXBzdWxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjaXJjbGVSYWRpdXMgSWYgc2V0LCB0aGlzIHZhbHVlIG92ZXJyaWRlcyB0aGUgY2lyY2xlIHNoYXBlIHJhZGl1cy5cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVMaW5lID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGxpbmVSYWRpdXMsXG4gICAgY2lyY2xlUmFkaXVzXG4pe1xuICAgIHZhciBsaW5lUmFkaXVzID0gbGluZVJhZGl1cyB8fCAwLFxuICAgICAgICBjaXJjbGVSYWRpdXMgPSB0eXBlb2YoY2lyY2xlUmFkaXVzKSE9PVwidW5kZWZpbmVkXCIgPyBjaXJjbGVSYWRpdXMgOiBjaXJjbGVTaGFwZS5yYWRpdXMsXG5cbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wMSxcbiAgICAgICAgbGluZVRvQ2lyY2xlT3J0aG9Vbml0ID0gdG1wMixcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXAzLFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNixcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDcsXG4gICAgICAgIHdvcmxkVmVydGV4MCA9IHRtcDgsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDksXG4gICAgICAgIHdvcmxkVmVydGV4MDEgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDExLFxuICAgICAgICBkaXN0ID0gdG1wMTIsXG4gICAgICAgIGxpbmVUb0NpcmNsZSA9IHRtcDEzLFxuICAgICAgICBsaW5lRW5kVG9MaW5lUmFkaXVzID0gdG1wMTQsXG5cbiAgICAgICAgdmVydHMgPSB0bXBBcnJheTtcblxuICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgxLCAgbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcblxuICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lQW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZUFuZ2xlKTtcblxuICAgIGFkZCh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAxLCBsaW5lT2Zmc2V0KTtcbiAgICBhZGQod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxMSwgbGluZU9mZnNldCk7XG5cbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgwLHdvcmxkVmVydGV4MDEpO1xuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDEsd29ybGRWZXJ0ZXgxMSk7XG5cbiAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXG4gICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cbiAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIHBsYW5lIHNwYW5uZWQgYnkgdGhlIGVkZ2UgdnMgdGhlIGNpcmNsZVxuICAgIHN1YihkaXN0LCBjaXJjbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTsgLy8gRGlzdGFuY2UgZnJvbSBjZW50ZXIgb2YgbGluZSB0byBjaXJjbGUgY2VudGVyXG4gICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgbGluZU9mZnNldCk7XG5cbiAgICBzdWIobGluZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmFyIHJhZGl1c1N1bSA9IGNpcmNsZVJhZGl1cyArIGxpbmVSYWRpdXM7XG5cbiAgICBpZihNYXRoLmFicyhkKSA8IHJhZGl1c1N1bSl7XG5cbiAgICAgICAgLy8gTm93IHByb2plY3QgdGhlIGNpcmNsZSBvbnRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUob3J0aG9EaXN0LCB3b3JsZFRhbmdlbnQsIGQpO1xuICAgICAgICBzdWIocHJvamVjdGVkUG9pbnQsIGNpcmNsZU9mZnNldCwgb3J0aG9EaXN0KTtcblxuICAgICAgICAvLyBBZGQgdGhlIG1pc3NpbmcgbGluZSByYWRpdXNcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIHdvcmxkVGFuZ2VudCwgZG90KHdvcmxkVGFuZ2VudCwgbGluZVRvQ2lyY2xlKSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuICAgICAgICB2ZWMyLnNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lUmFkaXVzKTtcbiAgICAgICAgYWRkKHByb2plY3RlZFBvaW50LHByb2plY3RlZFBvaW50LGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgZWRnZSBzcGFuXG4gICAgICAgIHZhciBwb3MgPSAgZG90KHdvcmxkRWRnZVVuaXQsIHByb2plY3RlZFBvaW50KTtcbiAgICAgICAgdmFyIHBvczAgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIHBvczEgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgxKTtcblxuICAgICAgICBpZihwb3MgPiBwb3MwICYmIHBvcyA8IHBvczEpe1xuICAgICAgICAgICAgLy8gV2UgZ290IGNvbnRhY3QhXG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGxpbmVCb2R5LGNpcmNsZVNoYXBlLGxpbmVTaGFwZSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBvcnRob0Rpc3QsIC0xKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgcHJvamVjdGVkUG9pbnQsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvcm5lclxuICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xuICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1c1N1bSwgMikpe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGxpbmVFbmRUb0xpbmVSYWRpdXMsIGMubm9ybWFsQSwgLWxpbmVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lRW5kVG9MaW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2Fwc3VsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGJqXG4gKiBAcGFyYW0gIHtMaW5lfSAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3Qpe1xuICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUoYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgc2oucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NvbnZleCBOYXJyb3dwaGFzZS5cbiAqIEBtZXRob2QgY2lyY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVSYWRpdXNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0LFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cyk9PT1cIm51bWJlclwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDMsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA0LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb0NpcmNsZSA9IHRtcDcsXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDgsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wOSxcbiAgICAgICAgZGlzdCA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleCA9IHRtcDExLFxuXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIGNhbmRpZGF0ZSA9IHRtcDE0LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IHRtcDE2LFxuXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG5cbiAgICAvLyBOZXcgYWxnb3JpdGhtOlxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgcG9seWdvbi4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXG4gICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxuICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxuICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cblxuICAgIHZhciB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGVkZ2VzIGZpcnN0XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuXG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGROb3JtYWwsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIHBvbHlnb25cbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgICAgIGFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZU9mZnNldCk7XG5cbiAgICAgICAgaWYocG9pbnRJbkNvbnZleChjYW5kaWRhdGUsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKSl7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkTm9ybWFsKSk7XG5cbiAgICAgICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShtaW5DYW5kaWRhdGUsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZE5vcm1hbCxjYW5kaWRhdGVEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuXG4gICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGNvbnZleEJvZHksY2lyY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuICAgICAgICB2ZWMyLnN1YihjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCAgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGlmKGNpcmNsZVJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgbG9jYWxWZXJ0ZXggPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCBsb2NhbFZlcnRleCwgY29udmV4QW5nbGUpO1xuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3coY2lyY2xlUmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG52YXIgcGljX3dvcmxkVmVydGV4MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3dvcmxkVmVydGV4MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfcjEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpcyBpbiBhIHBvbHlnb25cbiAqL1xuZnVuY3Rpb24gcG9pbnRJbkNvbnZleCh3b3JsZFBvaW50LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSl7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHBpY193b3JsZFZlcnRleDAsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHBpY193b3JsZFZlcnRleDEsXG4gICAgICAgIHIwID0gcGljX3IwLFxuICAgICAgICByMSA9IHBpY19yMSxcbiAgICAgICAgcG9pbnQgPSB3b3JsZFBvaW50LFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzLFxuICAgICAgICBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgLy8gQHRvZG8gVGhlIHBvaW50IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCB0byBsb2NhbCBjb29yZGluYXRlcyBpbiB0aGUgY29udmV4LCBubyBuZWVkIHRvIHRyYW5zZm9ybSBlYWNoIHZlcnRleFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKHIwLCB3b3JsZFZlcnRleDAsIHBvaW50KTtcbiAgICAgICAgc3ViKHIxLCB3b3JsZFZlcnRleDEsIHBvaW50KTtcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMi5jcm9zc0xlbmd0aChyMCxyMSk7XG5cbiAgICAgICAgaWYobGFzdENyb3NzPT09bnVsbCl7XG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCBhIGRpZmZlcmVudCBzaWduIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3IsIHRoZSBwb2ludCBpcyBvdXQgb2YgdGhlIHBvbHlnb25cbiAgICAgICAgaWYoY3Jvc3MqbGFzdENyb3NzIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJ0aWNsZS9jb252ZXggTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGFydGljbGVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAdG9kbyB1c2UgcG9pbnRJbkNvbnZleCBhbmQgY29kZSBtb3JlIHNpbWlsYXIgdG8gY2lyY2xlQ29udmV4XG4gKiBAdG9kbyBkb24ndCB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXgsIGJ1dCB0cmFuc2Zvcm0gdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHRvIGNvbnZleC1sb2NhbCBpbnN0ZWFkXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wNSxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDYsXG4gICAgICAgIGNvbnZleFRvcGFydGljbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcbiAgICAgICAgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgY2xvc2VzdEVkZ2VEaXN0YW5jZSA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3RFZGdlT3J0aG9EaXN0ID0gdG1wMTIsXG4gICAgICAgIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQgPSB0bXAxMyxcbiAgICAgICAgcjAgPSB0bXAxNCwgLy8gdmVjdG9yIGZyb20gcGFydGljbGUgdG8gdmVydGV4MFxuICAgICAgICByMSA9IHRtcDE1LFxuICAgICAgICBsb2NhbFBvaW50ID0gdG1wMTYsXG4gICAgICAgIGNhbmRpZGF0ZURpc3QgPSB0bXAxNyxcbiAgICAgICAgbWluRWRnZU5vcm1hbCA9IHRtcDE4LFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBhcnRpY2xlIGlzIGluIHRoZSBwb2x5Z29uIGF0IGFsbFxuICAgIGlmKCFwb2ludEluQ29udmV4KHBhcnRpY2xlT2Zmc2V0LGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGVkZ2VzIGZpcnN0XG4gICAgdmFyIGxhc3RDcm9zcyA9IG51bGw7XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgaW5maW5pdGUgbGluZSAoc3Bhbm5lZCBieSB0aGUgZWRnZSkgdG8gdGhlIHBhcnRpY2xlXG4gICAgICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTtcbiAgICAgICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIoY29udmV4VG9wYXJ0aWNsZSwgcGFydGljbGVPZmZzZXQsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgdmVjMi5zdWIoY2FuZGlkYXRlRGlzdCx3b3JsZFZlcnRleDAscGFydGljbGVPZmZzZXQpO1xuICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyh2ZWMyLmRvdChjYW5kaWRhdGVEaXN0LHdvcmxkVGFuZ2VudCkpO1xuXG4gICAgICAgIGlmKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2Upe1xuICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCx3b3JsZFRhbmdlbnQsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgdmVjMi5hZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHZlYzIuY29weShtaW5FZGdlTm9ybWFsLHdvcmxkVGFuZ2VudCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGFydGljbGVCb2R5LGNvbnZleEJvZHkscGFydGljbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgdmVjMi5zY2FsZShjLm5vcm1hbEEsIG1pbkVkZ2VOb3JtYWwsIC0xKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgIC8vIFBhcnRpY2xlIGhhcyBubyBleHRlbnQgdG8gdGhlIGNvbnRhY3QgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoYy5jb250YWN0UG9pbnRBLCAgMCwgMCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gRnJvbSBjb252ZXggY2VudGVyIHRvIHBvaW50XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cblxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY2lyY2xlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUNpcmNsZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVBXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQlxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEJcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVCXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0FdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQVxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNCXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUJcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBvZmZzZXRBLFxuICAgIGFuZ2xlQSxcbiAgICBib2R5QixcbiAgICBzaGFwZUIsXG4gICAgb2Zmc2V0QixcbiAgICBhbmdsZUIsXG4gICAganVzdFRlc3QsXG4gICAgcmFkaXVzQSxcbiAgICByYWRpdXNCXG4pe1xuXG4gICAgdmFyIGRpc3QgPSB0bXAxLFxuICAgICAgICByYWRpdXNBID0gcmFkaXVzQSB8fCBzaGFwZUEucmFkaXVzLFxuICAgICAgICByYWRpdXNCID0gcmFkaXVzQiB8fCBzaGFwZUIucmFkaXVzO1xuXG4gICAgc3ViKGRpc3Qsb2Zmc2V0QSxvZmZzZXRCKTtcbiAgICB2YXIgciA9IHJhZGl1c0EgKyByYWRpdXNCO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KHIsMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgc3ViKGMubm9ybWFsQSwgb2Zmc2V0Qiwgb2Zmc2V0QSk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgIHJhZGl1c0EpO1xuICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzQik7XG5cbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIG9mZnNldEEpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBvZmZzZXRCKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogUGxhbmUvQ29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXggPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIGRpc3QgPSB0bXAzO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMDtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gY29udmV4U2hhcGUudmVydGljZXNbaV07XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4LCB2LCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgaWYoZG90KGRpc3Qsd29ybGROb3JtYWwpIDw9IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIHZlcnRleFxuICAgICAgICAgICAgbnVtUmVwb3J0ZWQrKztcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksY29udmV4Qm9keSxwbGFuZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcblxuICAgICAgICAgICAgLy8gcmogaXMgZnJvbSBjb252ZXggY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuXG4gICAgICAgICAgICAvLyByaSBpcyBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgd29ybGRWZXJ0ZXgsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtUmVwb3J0ZWQpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1SZXBvcnRlZCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bVJlcG9ydGVkO1xufTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZSBmb3IgcGFydGljbGUgdnMgcGxhbmVcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gICBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gICAgICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcGxhbmVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSAgICAganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZVBsYW5lID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyO1xuXG4gICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcblxuICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihkID4gMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LHBhcnRpY2xlQm9keSxwbGFuZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuXG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuICAgIHZlYzIuc2NhbGUoIGRpc3QsIGMubm9ybWFsQSwgZCApO1xuICAgIC8vIGRpc3QgaXMgbm93IHRoZSBkaXN0YW5jZSB2ZWN0b3IgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cblxuICAgIC8vIHJpIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgZG93biBvbnRvIHRoZSBwbGFuZSwgZnJvbSB0aGUgcGxhbmUgY2VudGVyXG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0LCBkaXN0KTtcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmogaXMgZnJvbSB0aGUgYm9keSBjZW50ZXIgdG8gdGhlIHBhcnRpY2xlIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uICk7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENpcmNsZS9QYXJ0aWNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVQYXJ0aWNsZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QQVJUSUNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBhcnRpY2xlID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDE7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIGNpcmNsZU9mZnNldCk7XG4gICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpID4gTWF0aC5wb3coY2lyY2xlU2hhcGUucmFkaXVzLCAyKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxwYXJ0aWNsZUJvZHksY2lyY2xlU2hhcGUscGFydGljbGVTaGFwZSk7XG4gICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIFZlY3RvciBmcm9tIHBhcnRpY2xlIGNlbnRlciB0byBjb250YWN0IHBvaW50IGlzIHplcm9cbiAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxudmFyIHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMiA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2Fwc3VsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjYXBzdWxlQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVPZmZzZXQsXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBlbmQxID0gcGxhbmVDYXBzdWxlX3RtcDEsXG4gICAgICAgIGVuZDIgPSBwbGFuZUNhcHN1bGVfdG1wMixcbiAgICAgICAgY2lyY2xlID0gcGxhbmVDYXBzdWxlX3RtcENpcmNsZSxcbiAgICAgICAgZHN0ID0gcGxhbmVDYXBzdWxlX3RtcDM7XG5cbiAgICAvLyBDb21wdXRlIHdvcmxkIGVuZCBwb3NpdGlvbnNcbiAgICB2ZWMyLnNldChlbmQxLCAtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShlbmQxLGVuZDEsY2Fwc3VsZUFuZ2xlKTtcbiAgICBhZGQoZW5kMSxlbmQxLGNhcHN1bGVPZmZzZXQpO1xuXG4gICAgdmVjMi5zZXQoZW5kMiwgIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMixlbmQyLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDIsZW5kMixjYXBzdWxlT2Zmc2V0KTtcblxuICAgIGNpcmNsZS5yYWRpdXMgPSBjYXBzdWxlU2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG8gTmFycm93cGhhc2UgYXMgdHdvIGNpcmNsZXNcbiAgICB2YXIgbnVtQ29udGFjdHMxID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSxjaXJjbGUsZW5kMSwwLCBwbGFuZUJvZHkscGxhbmVTaGFwZSxwbGFuZU9mZnNldCxwbGFuZUFuZ2xlLCBqdXN0VGVzdCksXG4gICAgICAgIG51bUNvbnRhY3RzMiA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDIsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpO1xuXG4gICAgLy8gUmVzdG9yZSBmcmljdGlvblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gbnVtQ29udGFjdHMxIHx8IG51bUNvbnRhY3RzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbnVtVG90YWwgPSBudW1Db250YWN0czEgKyBudW1Db250YWN0czI7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgaWYobnVtVG90YWwpe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtVG90YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtVG90YWw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIENvbnRhY3RFcXVhdGlvbnMgYW5kIEZyaWN0aW9uRXF1YXRpb25zIGZvciBhIGNvbGxpc2lvbi5cbiAqIEBtZXRob2QgY2lyY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgIGJpICAgICBUaGUgZmlyc3QgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge0NpcmNsZX0gIHNpICAgICBUaGUgY2lyY2xlIHNoYXBlIHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbGxpc2lvbi5cbiAqIEBwYXJhbSAge0FycmF5fSAgIHhpICAgICBFeHRyYSBvZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgZm9yIHRoZSBTaGFwZSwgaW4gYWRkaXRpb24gdG8gdGhlIG9uZSBpbiBjaXJjbGVCb2R5LnBvc2l0aW9uLiBXaWxsICpub3QqIGJlIHJvdGF0ZWQgYnkgY2lyY2xlQm9keS5hbmdsZSAobWF5YmUgaXQgc2hvdWxkLCBmb3Igc2FrZSBvZiBob21vZ2VuaXR5PykuIFNldCB0byBudWxsIGlmIG5vbmUuXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaiAgICAgVGhlIHNlY29uZCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbm5lY3RlZCB0byB0aGUgZXF1YXRpb25zLlxuICogQHBhcmFtICB7UGxhbmV9ICAgc2ogICAgIFRoZSBQbGFuZSBzaGFwZSB0aGF0IGlzIHBhcnRpY2lwYXRpbmdcbiAqIEBwYXJhbSAge0FycmF5fSAgIHhqICAgICBFeHRyYSBvZmZzZXQgZm9yIHRoZSBwbGFuZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gIGFqICAgICBFeHRyYSBhbmdsZSB0byBhcHBseSB0byB0aGUgcGxhbmVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGxhbmUgPSBmdW5jdGlvbiggICBiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0ICl7XG4gICAgdmFyIGNpcmNsZUJvZHkgPSBiaSxcbiAgICAgICAgY2lyY2xlU2hhcGUgPSBzaSxcbiAgICAgICAgY2lyY2xlT2Zmc2V0ID0geGksIC8vIE9mZnNldCBmcm9tIGJvZHkgY2VudGVyLCByb3RhdGVkIVxuICAgICAgICBwbGFuZUJvZHkgPSBiaixcbiAgICAgICAgc2hhcGVCID0gc2osXG4gICAgICAgIHBsYW5lT2Zmc2V0ID0geGosXG4gICAgICAgIHBsYW5lQW5nbGUgPSBhajtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSB0byBjaXJjbGVcbiAgICB2YXIgcGxhbmVUb0NpcmNsZSA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMixcbiAgICAgICAgdGVtcCA9IHRtcDM7XG5cbiAgICBzdWIocGxhbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XG5cbiAgICAvLyBXb3JsZCBwbGFuZSBub3JtYWxcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gTm9ybWFsIGRpcmVjdGlvbiBkaXN0YW5jZVxuICAgIHZhciBkID0gZG90KHdvcmxkTm9ybWFsLCBwbGFuZVRvQ2lyY2xlKTtcblxuICAgIGlmKGQgPiBjaXJjbGVTaGFwZS5yYWRpdXMpe1xuICAgICAgICByZXR1cm4gMDsgLy8gTm8gb3ZlcmxhcC4gQWJvcnQuXG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgIHZhciBjb250YWN0ID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNpcmNsZUJvZHksc2osc2kpO1xuXG4gICAgLy8gbmkgaXMgdGhlIHBsYW5lIHdvcmxkIG5vcm1hbFxuICAgIHZlYzIuY29weShjb250YWN0Lm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcblxuICAgIC8vIHJqIGlzIHRoZSB2ZWN0b3IgZnJvbSBjaXJjbGUgY2VudGVyIHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgdmVjMi5zY2FsZShjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3Qubm9ybWFsQSwgLWNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5jb250YWN0UG9pbnRCLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyByaSBpcyB0aGUgZGlzdGFuY2UgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdC5cbiAgICB2ZWMyLnNjYWxlKHRlbXAsIGNvbnRhY3Qubm9ybWFsQSwgZCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVUb0NpcmNsZSwgdGVtcCApOyAvLyBTdWJ0cmFjdCBub3JtYWwgZGlzdGFuY2UgdmVjdG9yIGZyb20gdGhlIGRpc3RhbmNlIHZlY3RvclxuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVPZmZzZXQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIGNvbnRhY3QuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGNvbnRhY3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGNvbnRhY3QpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIENvbnZleC9jb252ZXggTmFycm93cGhhc2UuU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXCI+dGhpcyBhcnRpY2xlPC9hPiBmb3IgbW9yZSBpbmZvLlxuICogQG1ldGhvZCBjb252ZXhDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IGJpXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtDb252ZXh9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uKCAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCwgcHJlY2lzaW9uICl7XG4gICAgdmFyIHNlcEF4aXMgPSB0bXAxLFxuICAgICAgICB3b3JsZFBvaW50ID0gdG1wMixcbiAgICAgICAgd29ybGRQb2ludDAgPSB0bXAzLFxuICAgICAgICB3b3JsZFBvaW50MSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHByb2plY3RlZCA9IHRtcDYsXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gdG1wNyxcbiAgICAgICAgZGlzdCA9IHRtcDgsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wOSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwLFxuICAgICAgICBwcmVjaXNpb24gPSB0eXBlb2YocHJlY2lzaW9uKSA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiAwO1xuXG4gICAgdmFyIGZvdW5kID0gTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzKHNpLHhpLGFpLHNqLHhqLGFqLHNlcEF4aXMpO1xuICAgIGlmKCFmb3VuZCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgc2VwYXJhdGluZyBheGlzIGlzIGRpcmVjdGVkIGZyb20gc2hhcGUgaSB0byBzaGFwZSBqXG4gICAgc3ViKGRpc3QseGoseGkpO1xuICAgIGlmKGRvdChzZXBBeGlzLGRpc3QpID4gMCl7XG4gICAgICAgIHZlYzIuc2NhbGUoc2VwQXhpcyxzZXBBeGlzLC0xKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGVkZ2VzIHdpdGggbm9ybWFscyBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcbiAgICB2YXIgY2xvc2VzdEVkZ2UxID0gTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2Uoc2ksYWksc2VwQXhpcyx0cnVlKSwgLy8gRmxpcHBlZCBheGlzXG4gICAgICAgIGNsb3Nlc3RFZGdlMiA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNqLGFqLHNlcEF4aXMpO1xuXG4gICAgaWYoY2xvc2VzdEVkZ2UxID09PSAtMSB8fCBjbG9zZXN0RWRnZTIgPT09IC0xKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vcCBvdmVyIHRoZSBzaGFwZXNcbiAgICBmb3IodmFyIGs9MDsgazwyOyBrKyspe1xuXG4gICAgICAgIHZhciBjbG9zZXN0RWRnZUEgPSBjbG9zZXN0RWRnZTEsXG4gICAgICAgICAgICBjbG9zZXN0RWRnZUIgPSBjbG9zZXN0RWRnZTIsXG4gICAgICAgICAgICBzaGFwZUEgPSAgc2ksIHNoYXBlQiA9ICBzaixcbiAgICAgICAgICAgIG9mZnNldEEgPSB4aSwgb2Zmc2V0QiA9IHhqLFxuICAgICAgICAgICAgYW5nbGVBID0gYWksIGFuZ2xlQiA9IGFqLFxuICAgICAgICAgICAgYm9keUEgPSBiaSwgYm9keUIgPSBiajtcblxuICAgICAgICBpZihrID09PSAwKXtcbiAgICAgICAgICAgIC8vIFN3YXAhXG4gICAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgICAgdG1wID0gY2xvc2VzdEVkZ2VBO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2VCO1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBzaGFwZUE7XG4gICAgICAgICAgICBzaGFwZUEgPSBzaGFwZUI7XG4gICAgICAgICAgICBzaGFwZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IG9mZnNldEE7XG4gICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QjtcbiAgICAgICAgICAgIG9mZnNldEIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGFuZ2xlQTtcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFuZ2xlQjtcbiAgICAgICAgICAgIGFuZ2xlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gYm9keUE7XG4gICAgICAgICAgICBib2R5QSA9IGJvZHlCO1xuICAgICAgICAgICAgYm9keUIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgMiBwb2ludHMgaW4gY29udmV4IEJcbiAgICAgICAgZm9yKHZhciBqPWNsb3Nlc3RFZGdlQjsgajxjbG9zZXN0RWRnZUIrMjsgaisrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIHBvaW50XG4gICAgICAgICAgICB2YXIgdiA9IHNoYXBlQi52ZXJ0aWNlc1soaitzaGFwZUIudmVydGljZXMubGVuZ3RoKSVzaGFwZUIudmVydGljZXMubGVuZ3RoXTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQsIHYsIGFuZ2xlQik7XG4gICAgICAgICAgICBhZGQod29ybGRQb2ludCwgd29ybGRQb2ludCwgb2Zmc2V0Qik7XG5cbiAgICAgICAgICAgIHZhciBpbnNpZGVOdW1FZGdlcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciB0aGUgMyBjbG9zZXN0IGVkZ2VzIGluIGNvbnZleCBBXG4gICAgICAgICAgICBmb3IodmFyIGk9Y2xvc2VzdEVkZ2VBLTE7IGk8Y2xvc2VzdEVkZ2VBKzI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGkgICtzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzaGFwZUEudmVydGljZXNbKGkrMStzaGFwZUEudmVydGljZXMubGVuZ3RoKSVzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2UpOyAvLyBOb3JtYWwgcG9pbnRzIG91dCBvZiBjb252ZXggMVxuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCxkaXN0KTtcblxuICAgICAgICAgICAgICAgIGlmKChpID09PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSBwcmVjaXNpb24pIHx8IChpICE9PSBjbG9zZXN0RWRnZUEgJiYgZCA8PSAwKSl7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZU51bUVkZ2VzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnNpZGVOdW1FZGdlcyA+PSAzKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd29ybGRQb2ludCB3YXMgb24gdGhlIFwiaW5zaWRlXCIgc2lkZSBvZiBlYWNoIG9mIHRoZSAzIGNoZWNrZWQgZWRnZXMuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBpdCB0byB0aGUgY2VudGVyIGVkZ2UgYW5kIHVzZSB0aGUgcHJvamVjdGlvbiBkaXJlY3Rpb24gYXMgbm9ybWFsXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIsc2hhcGVBLHNoYXBlQik7XG4gICAgICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjZW50ZXIgZWRnZSBmcm9tIGJvZHkgQVxuICAgICAgICAgICAgICAgIHZhciB2MCA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKSAgICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhjbG9zZXN0RWRnZUErMSkgJSBzaGFwZUEudmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCB2MCwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgdjEsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQwLCB3b3JsZFBvaW50MCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MSwgb2Zmc2V0QSk7XG5cbiAgICAgICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KGMubm9ybWFsQSwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IEFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFBvaW50LCB3b3JsZFBvaW50MCk7IC8vIEZyb20gZWRnZSBwb2ludCB0byB0aGUgcGVuZXRyYXRpbmcgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdChjLm5vcm1hbEEsZGlzdCk7ICAgICAgICAgICAgIC8vIFBlbmV0cmF0aW9uXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShwZW5ldHJhdGlvblZlYywgYy5ub3JtYWxBLCBkKTsgICAgIC8vIFZlY3RvciBwZW5ldHJhdGlvblxuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgd29ybGRQb2ludCwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIC8vIFRvZG8gcmVkdWNlIHRvIDEgZnJpY3Rpb24gZXF1YXRpb24gaWYgd2UgaGF2ZSAyIGNvbnRhY3QgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLy8gLnByb2plY3RDb252ZXggaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIHBjb2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcbiAqIEBtZXRob2QgcHJvamVjdENvbnZleE9udG9BeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRBeGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKi9cbk5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyA9IGZ1bmN0aW9uKGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCB3b3JsZEF4aXMsIHJlc3VsdCl7XG4gICAgdmFyIG1heD1udWxsLFxuICAgICAgICBtaW49bnVsbCxcbiAgICAgICAgdixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGxvY2FsQXhpcyA9IHBjb2FfdG1wMTtcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCB3b3JsZEF4aXMsIC1jb252ZXhBbmdsZSk7XG5cbiAgICAvLyBHZXQgcHJvamVjdGVkIHBvc2l0aW9uIG9mIGFsbCB2ZXJ0aWNlc1xuICAgIGZvcih2YXIgaT0wOyBpPGNvbnZleFNoYXBlLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IGRvdCh2LGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICB2YXIgb2Zmc2V0ID0gZG90KGNvbnZleE9mZnNldCwgd29ybGRBeGlzKTtcblxuICAgIHZlYzIuc2V0KCByZXN1bHQsIG1pbiArIG9mZnNldCwgbWF4ICsgb2Zmc2V0KTtcbn07XG5cbi8vIC5maW5kU2VwYXJhdGluZ0F4aXMgaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIGZzYV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBGaW5kIGEgc2VwYXJhdGluZyBheGlzIGJldHdlZW4gdGhlIHNoYXBlcywgdGhhdCBtYXhpbWl6ZXMgdGhlIHNlcGFyYXRpbmcgZGlzdGFuY2UgYmV0d2VlbiB0aGVtLlxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMxXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTFcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGMyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBvZmZzZXQyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZTJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHNlcEF4aXMgICAgIFRoZSByZXN1bHRpbmcgYXhpc1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgV2hldGhlciB0aGUgYXhpcyBjb3VsZCBiZSBmb3VuZC5cbiAqL1xuTmFycm93cGhhc2UuZmluZFNlcGFyYXRpbmdBeGlzID0gZnVuY3Rpb24oYzEsb2Zmc2V0MSxhbmdsZTEsYzIsb2Zmc2V0MixhbmdsZTIsc2VwQXhpcyl7XG4gICAgdmFyIG1heERpc3QgPSBudWxsLFxuICAgICAgICBvdmVybGFwID0gZmFsc2UsXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIGVkZ2UgPSBmc2FfdG1wMSxcbiAgICAgICAgd29ybGRQb2ludDAgPSBmc2FfdG1wMixcbiAgICAgICAgd29ybGRQb2ludDEgPSBmc2FfdG1wMyxcbiAgICAgICAgbm9ybWFsID0gZnNhX3RtcDQsXG4gICAgICAgIHNwYW4xID0gZnNhX3RtcDUsXG4gICAgICAgIHNwYW4yID0gZnNhX3RtcDY7XG5cbiAgICBpZihjMSBpbnN0YW5jZW9mIEJveCAmJiBjMiBpbnN0YW5jZW9mIEJveCl7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09MjsgaSsrKXtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDAsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KG5vcm1hbCwgMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsb2Zmc2V0MSxhbmdsZTEsbm9ybWFsLHNwYW4xKTtcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsb2Zmc2V0MixhbmdsZTIsbm9ybWFsLHNwYW4yKTtcblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IDApO1xuXG4gICAgICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIGMudmVydGljZXNbaV0sIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MSwgYy52ZXJ0aWNlc1soaSsxKSVjLnZlcnRpY2VzLmxlbmd0aF0sIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHN1YihlZGdlLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKlxuICAgIC8vIE5lZWRzIHRvIGJlIHRlc3RlZCBzb21lIG1vcmVcbiAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMTtcbiAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMuYXhlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBjLmF4ZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLCBvZmZzZXQxLCBhbmdsZTEsIG5vcm1hbCwgc3BhbjEpO1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLCBvZmZzZXQyLCBhbmdsZTIsIG5vcm1hbCwgc3BhbjIpO1xuXG4gICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gTmFycm93cGhhc2UuY29udmV4UHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLy8gLmdldENsb3Nlc3RFZGdlIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBnY2VfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZ2NlX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogR2V0IHRoZSBlZGdlIHRoYXQgaGFzIGEgbm9ybWFsIGNsb3Nlc3QgdG8gYW4gYXhpcy5cbiAqIEBtZXRob2QgZ2V0Q2xvc2VzdEVkZ2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBheGlzXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICBmbGlwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgIEluZGV4IG9mIHRoZSBlZGdlIHRoYXQgaXMgY2xvc2VzdC4gVGhpcyBpbmRleCBhbmQgdGhlIG5leHQgc3BhbnMgdGhlIHJlc3VsdGluZyBlZGdlLiBSZXR1cm5zIC0xIGlmIGZhaWxlZC5cbiAqL1xuTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2UgPSBmdW5jdGlvbihjLGFuZ2xlLGF4aXMsZmxpcCl7XG4gICAgdmFyIGxvY2FsQXhpcyA9IGdjZV90bXAxLFxuICAgICAgICBlZGdlID0gZ2NlX3RtcDIsXG4gICAgICAgIG5vcm1hbCA9IGdjZV90bXAzO1xuXG4gICAgLy8gQ29udmVydCB0aGUgYXhpcyB0byBsb2NhbCBjb29yZHMgb2YgdGhlIGJvZHlcbiAgICB2ZWMyLnJvdGF0ZShsb2NhbEF4aXMsIGF4aXMsIC1hbmdsZSk7XG4gICAgaWYoZmxpcCl7XG4gICAgICAgIHZlYzIuc2NhbGUobG9jYWxBeGlzLGxvY2FsQXhpcywtMSk7XG4gICAgfVxuXG4gICAgdmFyIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIE4gPSBjLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgbWF4RG90ID0gLTE7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICAvLyBHZXQgdGhlIGVkZ2VcbiAgICAgICAgc3ViKGVkZ2UsIGMudmVydGljZXNbKGkrMSklTl0sIGMudmVydGljZXNbaSVOXSk7XG5cbiAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3Qobm9ybWFsLGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKGNsb3Nlc3RFZGdlID09PSAtMSB8fCBkID4gbWF4RG90KXtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlID0gaSAlIE47XG4gICAgICAgICAgICBtYXhEb3QgPSBkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RFZGdlO1xufTtcblxudmFyIGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uKCBjaXJjbGVCb2R5LGNpcmNsZVNoYXBlLGNpcmNsZVBvcyxjaXJjbGVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZkJvZHksaGZTaGFwZSxoZlBvcyxoZkFuZ2xlLCBqdXN0VGVzdCwgcmFkaXVzICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmhlaWdodHMsXG4gICAgICAgIHJhZGl1cyA9IHJhZGl1cyB8fCBjaXJjbGVTaGFwZS5yYWRpdXMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgZGlzdCA9IGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QsXG4gICAgICAgIGNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlLFxuICAgICAgICBtaW5DYW5kaWRhdGVOb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwsXG4gICAgICAgIHYwID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjAsXG4gICAgICAgIHYxID0gY2lyY2xlSGVpZ2h0ZmllbGRfdjE7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY2lyY2xlUG9zWzBdIC0gcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyApLFxuICAgICAgICBpZHhCID0gTWF0aC5jZWlsKCAgKGNpcmNsZVBvc1swXSArIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIC8qaWYoaWR4QiA8IDAgfHwgaWR4QSA+PSBkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwOyovXG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNpcmNsZVBvc1sxXS1yYWRpdXMgPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgLypcbiAgICBpZihjaXJjbGVQb3NbMV0rcmFkaXVzIDwgbWluKXtcbiAgICAgICAgLy8gQmVsb3cgdGhlIG1pbmltdW0gcG9pbnQuLi4gV2UgY2FuIGp1c3QgZ3Vlc3MuXG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgKi9cblxuICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgZmllbGQuIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50c1xuICAgICAgICB2ZWMyLnNldCh2MCwgICAgIGkqdywgZGF0YVtpXSAgKTtcbiAgICAgICAgdmVjMi5zZXQodjEsIChpKzEpKncsIGRhdGFbaSsxXSk7XG4gICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcbiAgICAgICAgdmVjMi5hZGQodjEsdjEsaGZQb3MpO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWxcbiAgICAgICAgdmVjMi5zdWIod29ybGROb3JtYWwsIHYxLCB2MCk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgTWF0aC5QSS8yKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIGVkZ2VcbiAgICAgICAgdmVjMi5zY2FsZShjYW5kaWRhdGUsd29ybGROb3JtYWwsLXJhZGl1cyk7XG4gICAgICAgIHZlYzIuYWRkKGNhbmRpZGF0ZSxjYW5kaWRhdGUsY2lyY2xlUG9zKTtcblxuICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIHYwIHRvIHRoZSBjYW5kaWRhdGUgcG9pbnRcbiAgICAgICAgdmVjMi5zdWIoZGlzdCxjYW5kaWRhdGUsdjApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSBlbGVtZW50IFwic3RpY2tcIlxuICAgICAgICB2YXIgZCA9IHZlYzIuZG90KGRpc3Qsd29ybGROb3JtYWwpO1xuICAgICAgICBpZihjYW5kaWRhdGVbMF0gPj0gdjBbMF0gJiYgY2FuZGlkYXRlWzBdIDwgdjFbMF0gJiYgZCA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjYW5kaWRhdGUgcG9pbnQsIHByb2plY3RlZCB0byB0aGUgZWRnZVxuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LHdvcmxkTm9ybWFsLC1kKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKG1pbkNhbmRpZGF0ZSxjYW5kaWRhdGUsZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihoZkJvZHksY2lyY2xlQm9keSxoZlNoYXBlLGNpcmNsZVNoYXBlKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsIGlzIG91dCBvZiB0aGUgaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZU5vcm1hbCk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsICBjLm5vcm1hbEEsIC1yYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMuY29udGFjdFBvaW50QSwgbWluQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHZlYzIuc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCB2ZXJ0aWNlc1xuICAgIGZvdW5kID0gZmFsc2U7XG4gICAgaWYocmFkaXVzID4gMCl7XG4gICAgICAgIGZvcih2YXIgaT1pZHhBOyBpPD1pZHhCOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRcbiAgICAgICAgICAgIHZlYzIuc2V0KHYwLCBpKncsIGRhdGFbaV0pO1xuICAgICAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihkaXN0LCBjaXJjbGVQb3MsIHYwKTtcblxuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzLCAyKSl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgbm9ybWFsIC0gb3V0IG9mIGhlaWdodGZpZWxkXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYwLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZlBvcyk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBoZkJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcblxufTtcblxudmFyIGNvbnZleEhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV0gfSk7XG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleEhlaWdodGZpZWxkID0gZnVuY3Rpb24oIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zLGNvbnZleEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSxoZlNoYXBlLGhmUG9zLGhmQW5nbGUsIGp1c3RUZXN0ICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmhlaWdodHMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgdjAgPSBjb252ZXhIZWlnaHRmaWVsZF92MCxcbiAgICAgICAgdjEgPSBjb252ZXhIZWlnaHRmaWVsZF92MSxcbiAgICAgICAgdGlsZVBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MsXG4gICAgICAgIHRpbGVDb252ZXggPSBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGU7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICksXG4gICAgICAgIGlkeEIgPSBNYXRoLmNlaWwoICAoY29udmV4Qm9keS5hYWJiLnVwcGVyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzFdID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIGVkZ2VzXG4gICAgLy8gVE9ETzogSWYgcG9zc2libGUsIGNvbnN0cnVjdCBhIGNvbnZleCBmcm9tIHNldmVyYWwgZGF0YSBwb2ludHMgKG5lZWQgbyBjaGVjayBpZiB0aGUgcG9pbnRzIG1ha2UgYSBjb252ZXggc2hhcGUpXG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcblxuICAgICAgICAvLyBHZXQgcG9pbnRzXG4gICAgICAgIHZlYzIuc2V0KHYwLCAgICAgaSp3LCBkYXRhW2ldICApO1xuICAgICAgICB2ZWMyLnNldCh2MSwgKGkrMSkqdywgZGF0YVtpKzFdKTtcbiAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuICAgICAgICB2ZWMyLmFkZCh2MSx2MSxoZlBvcyk7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgY29udmV4XG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gMTAwOyAvLyB0b2RvXG4gICAgICAgIHZlYzIuc2V0KHRpbGVQb3MsICh2MVswXSArIHYwWzBdKSowLjUsICh2MVsxXSArIHYwWzFdIC0gdGlsZUhlaWdodCkqMC41KTtcblxuICAgICAgICB2ZWMyLnN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzBdLCB2MSwgdGlsZVBvcyk7XG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMV0sIHYwLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5jb3B5KHRpbGVDb252ZXgudmVydGljZXNbMl0sIHRpbGVDb252ZXgudmVydGljZXNbMV0pO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1szXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1swXSk7XG4gICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbMl1bMV0gLT0gdGlsZUhlaWdodDtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1szXVsxXSAtPSB0aWxlSGVpZ2h0O1xuXG4gICAgICAgIC8vIERvIGNvbnZleCBjb2xsaXNpb25cbiAgICAgICAgbnVtQ29udGFjdHMgKz0gdGhpcy5jb252ZXhDb252ZXgoICAgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvcywgY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSwgdGlsZUNvbnZleCwgdGlsZVBvcywgMCwganVzdFRlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMSxcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzEsXCIuLi9zaGFwZXMvQm94XCI6MzcsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuLi9zaGFwZXMvQ29udmV4XCI6NDAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NSxcIi4uL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2xcIjo0OCxcIi4uL3V0aWxzL0ZyaWN0aW9uRXF1YXRpb25Qb29sXCI6NDksXCIuLi91dGlscy9UdXBsZURpY3Rpb25hcnlcIjo1NixcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuXG4vKipcbiAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy4gRm9yIGFuIGV4YW1wbGUsIHNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9yYXljYXN0Om1ldGhvZFwifX1Xb3JsZC5yYXljYXN0e3svY3Jvc3NMaW5rfX1cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZnJvbV1cbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnRvXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tb2RlPVJheS5BTlldXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKi9cbmZ1bmN0aW9uIFJheShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFJheSBzdGFydCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy5mcm9tWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSYXkgZW5kIHBvaW50XG4gICAgICogQHByb3BlcnR5IHthcnJheX0gdG9cbiAgICAgKi9cbiAgICB0aGlzLnRvID0gb3B0aW9ucy50byA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLnRvWzBdLCBvcHRpb25zLnRvWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIHt7I2Nyb3NzTGluayBcIlJheS9BTlk6cHJvcGVydHlcIn19UmF5LkFOWXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJSYXkvQUxMOnByb3BlcnR5XCJ9fVJheS5BTEx7ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJSYXkvQ0xPU0VTVDpwcm9wZXJ0eVwifX1SYXkuQ0xPU0VTVHt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vZGUgOiBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCwgdXNlci1wcm92aWRlZCByZXN1bHQgY2FsbGJhY2suIFdpbGwgYmUgdXNlZCBpZiBtb2RlIGlzIFJheS5BTEwuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbihyZXN1bHQpe307XG5cbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBMZW5ndGggb2YgdGhlIHJheVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xufVxuUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcblxuLyoqXG4gKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSB0cmF2ZXJzZSB0aHJvdWdoIGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBvbmx5IHJldHVybiB0aGUgY2xvc2VzdCBvbmUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0xPU0VTVFxuICovXG5SYXkuQ0xPU0VTVCA9IDE7XG5cbi8qKlxuICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCBtYWtlIHRoZSBSYXkgc3RvcCB3aGVuIGl0IGZpbmRzIHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQU5ZXG4gKi9cblJheS5BTlkgPSAyO1xuXG4vKipcbiAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgdHJhdmVyc2UgYWxsIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIGVhY2ggb25lLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFMTFxuICovXG5SYXkuQUxMID0gNDtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGlmIHlvdSBjaGFuZ2UgdGhlIGZyb20gb3IgdG8gcG9pbnQuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5SYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBVcGRhdGUgLmRpcmVjdGlvbiBhbmQgLmxlbmd0aFxuICAgIHZhciBkID0gdGhpcy5kaXJlY3Rpb247XG4gICAgdmVjMi5zdWIoZCwgdGhpcy50bywgdGhpcy5mcm9tKTtcbiAgICB0aGlzLmxlbmd0aCA9IHZlYzIubGVuZ3RoKGQpO1xuICAgIHZlYzIubm9ybWFsaXplKGQsIGQpO1xuXG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXG4gKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZGllcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXJlc3VsdC5zaG91bGRTdG9wKHRoaXMpICYmIGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBhYWJiID0gYm9keS5nZXRBQUJCKCk7XG4gICAgICAgIGlmKGFhYmIub3ZlcmxhcHNSYXkodGhpcykgPj0gMCB8fCBhYWJiLmNvbnRhaW5zUG9pbnQodGhpcy5mcm9tKSl7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkocmVzdWx0LCBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAocmVzdWx0LCBib2R5KSB7XG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2R5LnNoYXBlcy5sZW5ndGg7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgc2hhcGUuY29sbGlzaW9uTWFzaykgPT09IDAgfHwgKHNoYXBlLmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKSA9PT0gMCl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIHZhciB3b3JsZEFuZ2xlID0gc2hhcGUuYW5nbGUgKyBib2R5LmFuZ2xlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIHdvcmxkQW5nbGUsXG4gICAgICAgICAgICB3b3JsZFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHRoaXMpKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24ocmVzdWx0LCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcblxuICAgIC8vIENoZWNraW5nIHJhZGl1c1xuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvblNxdWFyZWQoZnJvbSwgdGhpcy5kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1JhZGl1cyAqIHNoYXBlLmJvdW5kaW5nUmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Qm9keSA9IGJvZHk7XG4gICAgdGhpcy5fY3VycmVudFNoYXBlID0gc2hhcGU7XG5cbiAgICBzaGFwZS5yYXljYXN0KHJlc3VsdCwgdGhpcywgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgIHRoaXMuX2N1cnJlbnRCb2R5ID0gdGhpcy5fY3VycmVudFNoYXBlID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQubG93ZXJCb3VuZCxcbiAgICAgICAgTWF0aC5taW4odG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQudXBwZXJCb3VuZCxcbiAgICAgICAgTWF0aC5tYXgodG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xufTtcblxudmFyIGhpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7bnVtYmVyfSBmcmFjdGlvblxuICogQHBhcmFtICB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtICB7bnVtYmVyfSBbZmFjZUluZGV4PS0xXVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcbiAqL1xuUmF5LnByb3RvdHlwZS5yZXBvcnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIGZyYWN0aW9uLCBub3JtYWwsIGZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgc2hhcGUgPSB0aGlzLl9jdXJyZW50U2hhcGU7XG4gICAgdmFyIGJvZHkgPSB0aGlzLl9jdXJyZW50Qm9keTtcblxuICAgIC8vIFNraXAgYmFjayBmYWNlcz9cbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgdmVjMi5kb3Qobm9ybWFsLCB0aGlzLmRpcmVjdGlvbikgPiAwKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0aGlzLm1vZGUpe1xuXG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XG4gICAgICAgIGlmKGZyYWN0aW9uIDwgcmVzdWx0LmZyYWN0aW9uIHx8ICFyZXN1bHQuaGFzSGl0KCkpe1xuICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbixcbiAgICAgICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxudmFyIHYwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpbnRlcnNlY3QgPSB2ZWMyLmNyZWF0ZSgpO1xuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXG4gICAgdmVjMi5zdWIodjAsIHBvc2l0aW9uLCBmcm9tKTtcbiAgICB2YXIgZG90ID0gdmVjMi5kb3QodjAsIGRpcmVjdGlvbik7XG5cbiAgICAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24gKiBkb3QgKyBmcm9tXG4gICAgdmVjMi5zY2FsZShpbnRlcnNlY3QsIGRpcmVjdGlvbiwgZG90KTtcbiAgICB2ZWMyLmFkZChpbnRlcnNlY3QsIGludGVyc2VjdCwgZnJvbSk7XG5cbiAgICByZXR1cm4gdmVjMi5zcXVhcmVkRGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgaGl0IGRhdGEuXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheWNhc3RSZXN1bHQoKXtcblxuXHQvKipcblx0ICogVGhlIG5vcm1hbCBvZiB0aGUgaGl0LCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cblx0ICogQHByb3BlcnR5IHthcnJheX0gbm9ybWFsXG5cdCAqL1xuXHR0aGlzLm5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBpbmRleGFibGUuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQsIGFzIGEgZnJhY3Rpb24uIDAgaXMgYXQgdGhlIFwiZnJvbVwiIHBvaW50LCAxIGlzIGF0IHRoZSBcInRvXCIgcG9pbnQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQgeWV0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZnJhY3Rpb25cblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZnJhY3Rpb24gPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nLlxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBpc1N0b3BwZWRcblx0ICovXG5cdHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLiBNdXN0IGJlIGRvbmUgYmVmb3JlIHJlLXVzaW5nIHRoZSByZXN1bHQgb2JqZWN0LlxuICogQG1ldGhvZCByZXNldFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0dmVjMi5zZXQodGhpcy5ub3JtYWwsIDAsIDApO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5mYWNlSW5kZXggPSAtMTtcblx0dGhpcy5mcmFjdGlvbiA9IC0xO1xuXHR0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBoaXQgcG9pbnQuXG4gKiBAbWV0aG9kIGdldEhpdERpc3RhbmNlXG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdERpc3RhbmNlID0gZnVuY3Rpb24gKHJheSkge1xuXHRyZXR1cm4gdmVjMi5kaXN0YW5jZShyYXkuZnJvbSwgcmF5LnRvKSAqIHRoaXMuZnJhY3Rpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmF5IGhpdCBzb21ldGhpbmcgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgaGFzSGl0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmhhc0hpdCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZnJhY3Rpb24gIT09IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgaGl0IHBvaW50LlxuICogQG1ldGhvZCBnZXRIaXRQb2ludFxuICogQHBhcmFtIHthcnJheX0gb3V0XG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdFBvaW50ID0gZnVuY3Rpb24gKG91dCwgcmF5KSB7XG5cdHZlYzIubGVycChvdXQsIHJheS5mcm9tLCByYXkudG8sIHRoaXMuZnJhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBDYW4gYmUgY2FsbGVkIHdoaWxlIGl0ZXJhdGluZyBvdmVyIGhpdHMgdG8gc3RvcCBzZWFyY2hpbmcgZm9yIGhpdCBwb2ludHMuXG4gKiBAbWV0aG9kIHN0b3BcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzaG91bGRTdG9wXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2hvdWxkU3RvcCA9IGZ1bmN0aW9uKHJheSl7XG5cdHJldHVybiB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5mcmFjdGlvbiAhPT0gLTEgJiYgcmF5Lm1vZGUgPT09IFJheS5BTlkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRub3JtYWwsXG5cdHNoYXBlLFxuXHRib2R5LFxuXHRmcmFjdGlvbixcblx0ZmFjZUluZGV4XG4pe1xuXHR2ZWMyLmNvcHkodGhpcy5ub3JtYWwsIG5vcm1hbCk7XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5ib2R5ID0gYm9keTtcblx0dGhpcy5mcmFjdGlvbiA9IGZyYWN0aW9uO1xuXHR0aGlzLmZhY2VJbmRleCA9IGZhY2VJbmRleDtcbn07XG59LHtcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMSxcIi4uL21hdGgvdmVjMlwiOjMwfV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBUEJyb2FkcGhhc2U7XG5cbi8qKlxuICogU3dlZXAgYW5kIHBydW5lIGJyb2FkcGhhc2UgYWxvbmcgb25lIGF4aXMuXG4gKlxuICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5jYWxsKHRoaXMsQnJvYWRwaGFzZS5TQVApO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzTGlzdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNMaXN0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXhpcyB0byBzb3J0IGFsb25nLiAwIG1lYW5zIHgtYXhpcyBhbmQgMSB5LWF4aXMuIElmIHlvdXIgYm9kaWVzIGFyZSBtb3JlIHNwcmVhZCBvdXQgb3ZlciB0aGUgWCBheGlzLCBzZXQgYXhpc0luZGV4IHRvIDAsIGFuZCB5b3Ugd2lsbCBnYWluIHNvbWUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNJbmRleFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5heGlzSW5kZXggPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgIHZhciBpZHggPSB0aGF0LmF4aXNMaXN0LmluZGV4T2YoZS5ib2R5KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICB0aGF0LmF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgd29ybGRcbiAqIEBtZXRob2Qgc2V0V29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMuYXhpc0xpc3QsIHdvcmxkLmJvZGllcyk7XG5cbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcbiAgICB3b3JsZFxuICAgICAgICAub2ZmKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKVxuICAgICAgICAub2ZmKFwicmVtb3ZlQm9keVwiLHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxuICAgIHdvcmxkLm9uKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKS5vbihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG59O1xuXG4vKipcbiAqIFNvcnRzIGJvZGllcyBhbG9uZyBhbiBheGlzLlxuICogQG1ldGhvZCBzb3J0QXhpc0xpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdCA9IGZ1bmN0aW9uKGEsIGF4aXNJbmRleCl7XG4gICAgYXhpc0luZGV4ID0gYXhpc0luZGV4fDA7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc29ydExpc3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICBTQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdChib2RpZXMsIGF4aXNJbmRleCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQsXG4gICAgICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgYWxsIEFBQkJzIGlmIG5lZWRlZFxuICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tsXTtcbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0c1xuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgWCBsaXN0XG4gICAgZm9yKHZhciBpPTAsIE49Ym9kaWVzLmxlbmd0aHwwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8TjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgLy8gQm91bmRzIG92ZXJsYXA/XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSAoYmouYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gYmkuYWFiYi51cHBlckJvdW5kW2F4aXNJbmRleF0pO1xuICAgICAgICAgICAgaWYoIW92ZXJsYXBzKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgdGhpcy5zb3J0TGlzdCgpO1xuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuICAgIHZhciBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIEJhc2UgY29uc3RyYWludCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChib2R5QSwgYm9keUIsIHR5cGUsIG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29uc3RyYWludC4gTWF5IGJlIG9uZSBvZiBDb25zdHJhaW50LkRJU1RBTkNFLCBDb25zdHJhaW50LkdFQVIsIENvbnN0cmFpbnQuTE9DSywgQ29uc3RyYWludC5QUklTTUFUSUMgb3IgQ29uc3RyYWludC5SRVZPTFVURS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQgOiB0cnVlLFxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIHRvIGJlIHNvbHZlZCBpbiB0aGlzIGNvbnN0cmFpbnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNvbGxpZGUuXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVDb25uZWN0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuXG4gICAgLy8gV2FrZSB1cCBib2RpZXMgd2hlbiBjb25uZWN0ZWRcbiAgICBpZihvcHRpb25zLndha2VVcEJvZGllcyl7XG4gICAgICAgIGlmKGJvZHlBKXtcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlCKXtcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGNvbnN0cmFpbnQgcGFyYW1ldGVycyBiZWZvcmUgc29sdmUuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBESVNUQU5DRVxuICovXG5Db25zdHJhaW50LkRJU1RBTkNFID0gMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gR0VBUlxuICovXG5Db25zdHJhaW50LkdFQVIgPSAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0NLXG4gKi9cbkNvbnN0cmFpbnQuTE9DSyA9IDM7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFBSSVNNQVRJQ1xuICovXG5Db25zdHJhaW50LlBSSVNNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFJFVk9MVVRFXG4gKi9cbkNvbnN0cmFpbnQuUkVWT0xVVEUgPSA1O1xuXG4vKipcbiAqIFNldCBzdGlmZm5lc3MgZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0U3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGVxLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHJlbGF4YXRpb24gZm9yIHRoaXMgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0UmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuc2V0UmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5yZWxheGF0aW9uID0gcmVsYXhhdGlvbjtcbiAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgdHJpZXMgdG8ga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzIGNvbnN0YW50LlxuICpcbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlBLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QiwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tYXhGb3JjZT1OdW1iZXIuTUFYX1ZBTFVFXSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSWYgZGlzdGFuY2UgaXMgbm90IGdpdmVuIGFzIGFuIG9wdGlvbiwgdGhlbiB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMgaXMgdXNlZC5cbiAqICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIHRoZSBib2RpZXMgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBoYXZlIGEgZGlzdGFuY2Ugb2YgMiBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgZGlzdGFuY2UgYW5kIGFuY2hvcnNcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIGRpc3RhbmNlOiAxLCAgICAgICAgICAvLyBEaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIHBvaW50c1xuICogICAgICAgICBsb2NhbEFuY2hvckE6IFsxLCAwXSwgLy8gUG9pbnQgb24gYm9keUFcbiAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbLTEsIDBdIC8vIFBvaW50IG9uIGJvZHlCXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgbG9jYWxBbmNob3JBOlswLDBdLFxuICAgICAgICBsb2NhbEFuY2hvckI6WzAsMF1cbiAgICB9KTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuRElTVEFOQ0Usb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBhbmNob3IgaW4gYm9keSBBLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5sb2NhbEFuY2hvckFbMF0sIG9wdGlvbnMubG9jYWxBbmNob3JBWzFdKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEIuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQlswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckJbMV0pO1xuXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBO1xuICAgIHZhciBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxuICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5kaXN0YW5jZSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBjdXJyZW50IHdvcmxkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgYm9keUIucG9zaXRpb24sIHdvcmxkQW5jaG9yQik7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHdvcmxkQW5jaG9yQSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdmVjMi5sZW5ndGgocik7XG4gICAgfVxuXG4gICAgdmFyIG1heEZvcmNlO1xuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgKXtcbiAgICAgICAgbWF4Rm9yY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEZvcmNlID0gb3B0aW9ucy5tYXhGb3JjZTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFsgbm9ybWFsIF07XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZvcmNlXG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLy8gZyA9ICh4aSAtIHhqKS5kb3QobilcbiAgICAvLyBkZy9kdCA9ICh2aSAtIHZqKS5kb3QobikgPSBHKlcgPSBbbiAwIC1uIDBdICogW3ZpIHdpIHZqIHdqXSdcblxuICAgIC8vIC4uLmFuZCBpZiB3ZSB3ZXJlIHRvIGluY2x1ZGUgb2Zmc2V0IHBvaW50czpcbiAgICAvLyBnID1cbiAgICAvLyAgICAgICh4aiArIHJqIC0geGkgLSByaSkuZG90KG4pIC0gZGlzdGFuY2VcbiAgICAvL1xuICAgIC8vIGRnL2R0ID1cbiAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XG4gICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XG4gICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XG4gICAgLy8gICAgICBHICogV1xuICAgIC8vXG4gICAgLy8gPT4gRyA9IFstbiAtcml4biBuIHJqeG5dXG5cbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHJpID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXG4gICAgdmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUocmksIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgeGosIHJqKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgcmkpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCB4aSk7XG5cbiAgICAgICAgLy92ZWMyLnN1YihyLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdmVjMi5sZW5ndGgocikgLSB0aGF0LmRpc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXBwZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBjb25zdHJhaW50IGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cHBlckxpbWl0XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvd2VyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25zdHJhaW50IHBvc2l0aW9uLiBUaGlzIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG59XG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG52YXIgbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbnZhciByaiA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQlxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbixcbiAgICAgICAgbm9ybWFsRXF1YXRpb24gPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgRyA9IG5vcm1hbC5HO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZShyaSwgdGhpcy5sb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShyaiwgdGhpcy5sb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcbiAgICB2ZWMyLmFkZChuLCB4aiwgcmopO1xuICAgIHZlYzIuc3ViKG4sIG4sIHJpKTtcbiAgICB2ZWMyLnN1YihuLCBuLCB4aSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIubGVuZ3RoKG4pO1xuXG4gICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gLXRoaXMubWF4Rm9yY2U7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy51cHBlckxpbWl0O1xuICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uIDwgdGhpcy5sb3dlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgfHwgdGhpcy51cHBlckxpbWl0RW5hYmxlZCkgJiYgIXZpb2xhdGluZyl7XG4gICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxuICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHZlYzIubm9ybWFsaXplKG4sbik7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxuICogQG1ldGhvZCBzZXRNYXhGb3JjZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihtYXhGb3JjZSl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIG5vcm1hbC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICBub3JtYWwubWF4Rm9yY2UgPSAgbWF4Rm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICByZXR1cm4gbm9ybWFsLm1heEZvcmNlO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMixcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vQ29uc3RyYWludFwiOjE0fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBBbmdsZUxvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlYXJDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIGFuZ2xlIG9mIHR3byBib2RpZXMgdG8gZWFjaCBvdGhlciB0byBiZSBlcXVhbC4gSWYgYSBnZWFyIHJhdGlvIGlzIG5vdCBvbmUsIHRoZSBhbmdsZSBvZiBib2R5QSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGFuZ2xlIG9mIGJvZHlCLlxuICogQGNsYXNzIEdlYXJDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF0gUmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLiBXaWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMgKHRoZSBnZWFyIHJhdGlvIGlzIGFjY291bnRlZCBmb3IpLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLnJhdGlvPTFdIEdlYXIgcmF0aW8uXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMubWF4VG9ycXVlXSBNYXhpbXVtIHRvcnF1ZSB0byBhcHBseS5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICByYXRpbzogMixcbiAqICAgICAgICAgbWF4VG9ycXVlOiAxMDAwXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gR2VhckNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIENvbnN0cmFpbnQuR0VBUiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkgcmF0aW9cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF0aW8gPSBvcHRpb25zLnJhdGlvICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiBib2R5Qi5hbmdsZSAtIHRoaXMucmF0aW8gKiBib2R5QS5hbmdsZTtcblxuICAgIC8vIFNlbmQgc2FtZSBwYXJhbWV0ZXJzIHRvIHRoZSBlcXVhdGlvblxuICAgIG9wdGlvbnMuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIG9wdGlvbnMucmF0aW8gPSB0aGlzLnJhdGlvO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKSxcbiAgICBdO1xuXG4gICAgLy8gU2V0IG1heCB0b3JxdWVcbiAgICBpZihvcHRpb25zLm1heFRvcnF1ZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgdGhpcy5zZXRNYXhUb3JxdWUob3B0aW9ucy5tYXhUb3JxdWUpO1xuICAgIH1cbn1cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZWFyQ29uc3RyYWludDtcblxuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgaWYoZXEucmF0aW8gIT09IHRoaXMucmF0aW8pe1xuICAgICAgICBlcS5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbiAgICB9XG4gICAgZXEuYW5nbGUgPSB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5lcXVhdGlvbnNbMF0uc2V0TWF4VG9ycXVlKHRvcnF1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGdldE1heFRvcnF1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMCxcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2tDb25zdHJhaW50O1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuTE9DSyxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9ICggdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBvcHRpb25zLm1heEZvcmNlICk7XG5cbiAgICB2YXIgbG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCIHx8IDA7XG5cbiAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XG4gICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxuICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcbiAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXG4gICAgLy9cbiAgICAvLyAuLi53aGVyZTpcbiAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxuICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcbiAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xuICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XG4gICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxuICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcbiAgICAvL1xuICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XG4gICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cbiAgICAvL1xuICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcbiAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcbiAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXG5cbiAgICB2YXIgeCA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgeSA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgcm90ID0gICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIHZhciBsID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzBdO1xuICAgIH07XG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMV07XG4gICAgfTtcbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcbiAgICAgICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuICAgICAgICB2ZWMyLnN1YihnLGJvZHlBLnBvc2l0aW9uLGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQoZyxnLHIpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LHIsLU1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMubG9jYWxPZmZzZXRCKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxPZmZzZXRCLCBvcHRpb25zLmxvY2FsT2Zmc2V0Qik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgdmVjMi5zdWIodGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMubG9jYWxPZmZzZXRCLCB0aGlzLmxvY2FsT2Zmc2V0QiwgLWJvZHlBLmFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuZ2xlQiA9IDA7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubG9jYWxBbmdsZUIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdFxuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHJvdCk7XG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG59XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZvcmNlIHRvIGJlIGFwcGxpZWQuXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yY2VcbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9ICBmb3JjZTtcbiAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UuXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcblxudmFyIGwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCk7XG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4ID0gICB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgeSA9ICAgdGhpcy5lcXVhdGlvbnNbMV0sXG4gICAgICAgIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZlYzIucm90YXRlKGwsdGhpcy5sb2NhbE9mZnNldEIsYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHIsdGhpcy5sb2NhbE9mZnNldEIsYm9keUIuYW5nbGUgLSB0aGlzLmxvY2FsQW5nbGVCKTtcbiAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh0LHIsTWF0aC5QSS8yKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHlBeGlzKTtcbiAgICB5LkdbNF0gPSAgMTtcblxuICAgIHJvdC5HWzBdID0gIC10WzBdO1xuICAgIHJvdC5HWzFdID0gIC10WzFdO1xuICAgIHJvdC5HWzNdID0gIHRbMF07XG4gICAgcm90LkdbNF0gPSAgdFsxXTtcbiAgICByb3QuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHIsdCk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpc21hdGljQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgb25seSBhbGxvd3MgYm9kaWVzIHRvIG1vdmUgYWxvbmcgYSBsaW5lLCByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuaWZvcmNlMmQubmV0L2IyZHR1dC9qb2ludHMtcHJpc21hdGljXCI+dGhpcyB0dXRvcmlhbDwvYT4uIEFsc28gY2FsbGVkIFwic2xpZGVyIGNvbnN0cmFpbnRcIi5cbiAqXG4gKiBAY2xhc3MgUHJpc21hdGljQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gICAgICAgICAgICAgICAgTWF4IGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgICAgICAgICAgIEJvZHkgQSdzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdICAgICAgICAgICAgQm9keSBCJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQXhpc0FdICAgICAgICAgICAgICBBbiBheGlzLCBkZWZpbmVkIGluIGJvZHkgQSBmcmFtZSwgdGhhdCBib2R5IEIncyBhbmNob3IgcG9pbnQgbWF5IHNsaWRlIGFsb25nLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2tdICAgSWYgc2V0IHRvIHRydWUsIGJvZHlCIHdpbGwgYmUgZnJlZSB0byByb3RhdGUgYXJvdW5kIGl0cyBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLnVwcGVyTGltaXRdXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLmxvd2VyTGltaXRdXG4gKiBAdG9kbyBBYmlsaXR5IHRvIGNyZWF0ZSB1c2luZyBvbmx5IGEgcG9pbnQgYW5kIGEgd29ybGRBeGlzXG4gKi9cbmZ1bmN0aW9uIFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LlBSSVNNQVRJQyxvcHRpb25zKTtcblxuICAgIC8vIEdldCBhbmNob3JzXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgICAgICBsb2NhbEF4aXNBID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgICAgIGxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEF4aXNBKXsgdmVjMi5jb3B5KGxvY2FsQXhpc0EsICAgb3B0aW9ucy5sb2NhbEF4aXNBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXsgdmVjMi5jb3B5KGxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEF4aXNBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBeGlzQSA9IGxvY2FsQXhpc0E7XG5cbiAgICAvKlxuXG4gICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGZvciB0aGUgY29tbW9uIGF4aXMgcG9pbnQgaXNcblxuICAgICAgICBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdCAgIDo9ICBnZyp0XG5cbiAgICB3aGVyZSByIGFyZSBib2R5LWxvY2FsIGFuY2hvciBwb2ludHMsIGFuZCB0IGlzIGEgdGFuZ2VudCB0byB0aGUgY29uc3RyYWludCBheGlzIGRlZmluZWQgaW4gYm9keSBpIGZyYW1lLlxuXG4gICAgICAgIGdkb3QgPSAgKCB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkgKSAqIHQgKyAoIHhqICsgcmogLSB4aSAtIHJpICkgKiAoIHdpIHggdCApXG5cbiAgICBOb3RlIHRoZSB1c2Ugb2YgdGhlIGNoYWluIHJ1bGUuIE5vdyB3ZSBpZGVudGlmeSB0aGUgamFjb2JpYW5cblxuICAgICAgICBHKlcgPSBbIC10ICAgICAgLXJpIHggdCArIHQgeCBnZyAgICAgdCAgICByaiB4IHQgXSAqIFt2aSB3aSB2aiB3al1cblxuICAgIFRoZSByb3RhdGlvbmFsIHBhcnQgaXMganVzdCBhIHJvdGF0aW9uIGxvY2suXG5cbiAgICAgKi9cblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXhGb3JjZSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvLyBUcmFuc2xhdGlvbmFsIHBhcnRcbiAgICB2YXIgdHJhbnMgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICB2YXIgcmkgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgcmogPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZ2cgPSBuZXcgdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdCA9ICBuZXcgdmVjMi5jcmVhdGUoKTtcbiAgICB0cmFucy5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdFxuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZ2csdCk7XG4gICAgfTtcbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG4gICAgICAgIHZlYzIucm90YXRlKHJpLGxvY2FsQW5jaG9yQSxib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLGxvY2FsQW5jaG9yQixib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGdnLHhqLHJqKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cseGkpO1xuICAgICAgICB2ZWMyLnN1YihnZyxnZyxyaSk7XG4gICAgICAgIHZlYzIucm90YXRlKHQsbG9jYWxBeGlzQSxib2R5QS5hbmdsZStNYXRoLlBJLzIpO1xuXG4gICAgICAgIEdbMF0gPSAtdFswXTtcbiAgICAgICAgR1sxXSA9IC10WzFdO1xuICAgICAgICBHWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgocmksdCkgKyB2ZWMyLmNyb3NzTGVuZ3RoKHQsZ2cpO1xuICAgICAgICBHWzNdID0gdFswXTtcbiAgICAgICAgR1s0XSA9IHRbMV07XG4gICAgICAgIEdbNV0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLHQpO1xuICAgIH07XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0cmFucyk7XG5cbiAgICAvLyBSb3RhdGlvbmFsIHBhcnRcbiAgICBpZighb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2spe1xuICAgICAgICB2YXIgcm90ID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiBhbmNob3IgQSByZWxhdGl2ZSB0byBhbmNob3IgQiwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuXG4gICAgLy8gSXMgdGhpcyBvbmUgdXNlZCBhdCBhbGw/XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbG93ZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMudXBwZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTG93ZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLmxvd2VyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG93ZXJMaW1pdCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBVcHBlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMudXBwZXJMaW1pdCA6IDE7XG5cbiAgICAvLyBFcXVhdGlvbnMgdXNlZCBmb3IgbGltaXRzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLy8gU2V0IG1heC9taW4gZm9yY2VzXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb24gdXNlZCBmb3IgdGhlIG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVxdWF0aW9uXG4gICAgICogQHR5cGUge0VxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBtb3RvciBzdGF0ZS4gRW5hYmxlIG9yIGRpc2FibGUgdGhlIG1vdG9yIHVzaW5nIC5lbmFibGVNb3RvclxuICAgICAqIEBwcm9wZXJ0eSBtb3RvckVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0YXJnZXQgc3BlZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JTcGVlZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb3RvclNwZWVkID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbW90b3JFcXVhdGlvbiA9IHRoaXMubW90b3JFcXVhdGlvbjtcbiAgICB2YXIgb2xkID0gbW90b3JFcXVhdGlvbi5jb21wdXRlR1c7XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR3EgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTtcbiAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoYXQubW90b3JTcGVlZDtcbiAgICB9O1xufVxuXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbnZhciB3b3JsZEF4aXNBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICBvcmllbnRlZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgdHJhbnMgPSBlcXNbMF0sXG4gICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsXG4gICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbixcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGxvY2FsQXhpc0EgPSB0aGlzLmxvY2FsQXhpc0EsXG4gICAgICAgIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgdGhpbmdzIHRvIHdvcmxkXG4gICAgdmVjMi5yb3RhdGUod29ybGRBeGlzQSwgICAgICBsb2NhbEF4aXNBLCAgICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShvcmllbnRlZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgICAgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIuYWRkKHdvcmxkQW5jaG9yQSwgICAgICAgb3JpZW50ZWRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JCLCBsb2NhbEFuY2hvckIsICAgIGJvZHlCLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckIsICAgICAgIG9yaWVudGVkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgdmFyIHJlbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHZlYzIuZG90KHdvcmxkQW5jaG9yQix3b3JsZEF4aXNBKSAtIHZlYzIuZG90KHdvcmxkQW5jaG9yQSx3b3JsZEF4aXNBKTtcblxuICAgIC8vIE1vdG9yXG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICAvLyBHID0gWyBhICAgICBhIHggcmkgICAtYSAgIC1hIHggcmogXVxuICAgICAgICB2YXIgRyA9IHRoaXMubW90b3JFcXVhdGlvbi5HO1xuICAgICAgICBHWzBdID0gd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1sxXSA9IHdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbMl0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0Esb3JpZW50ZWRBbmNob3JCKTtcbiAgICAgICAgR1szXSA9IC13b3JsZEF4aXNBWzBdO1xuICAgICAgICBHWzRdID0gLXdvcmxkQXhpc0FbMV07XG4gICAgICAgIEdbNV0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgTGltaXRzIHN0cmF0ZWd5OlxuICAgICAgICBBZGQgY29udGFjdCBlcXVhdGlvbiwgd2l0aCBub3JtYWwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cbiAgICAgICAgbWluL21heEZvcmNlIGlzIHNldCBzbyB0aGUgY29uc3RyYWludCBpcyByZXB1bHNpdmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAgICBTb21lIG9mZnNldCBpcyBhZGRlZCB0byBlaXRoZXIgZXF1YXRpb24uY29udGFjdFBvaW50QSBvciAuY29udGFjdFBvaW50QiB0byBnZXQgdGhlIGNvcnJlY3QgdXBwZXIvbG93ZXIgbGltaXQuXG5cbiAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgICAgICB8XG4gICAgICB1cHBlckxpbWl0IHhcbiAgICAgICAgICAgICAgICAgfCAgICAtLS0tLS1cbiAgICAgICAgIGFuY2hvckIgeDwtLS18ICBCIHxcbiAgICAgICAgICAgICAgICAgfCAgICB8ICAgIHxcbiAgICAgICAgLS0tLS0tICAgfCAgICAtLS0tLS1cbiAgICAgICAgfCAgICB8ICAgfFxuICAgICAgICB8ICBBIHwtLT54IGFuY2hvckFcbiAgICAgICAgLS0tLS0tICAgfFxuICAgICAgICAgICAgICAgICB4IGxvd2VyTGltaXRcbiAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgKi9cblxuXG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCAmJiByZWxQb3NpdGlvbiA+IHVwcGVyTGltaXQpe1xuICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXG4gICAgICAgIHZlYzIuc2NhbGUodXBwZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIC0xKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsdXBwZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuYWRkKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPCBsb3dlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKGxvd2VyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAxKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc2NhbGUodG1wLHdvcmxkQXhpc0EsbG93ZXJMaW1pdCk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLHRtcCk7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSBtb3RvclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnN0cmFpbnQgbGltaXRzLlxuICogQG1ldGhvZCBzZXRMaW1pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBsaW1pdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBsaW1pdC5cbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgIGlmKHR5cGVvZihsb3dlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKHVwcGVyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5cbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIxLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldm9sdXRlQ29uc3RyYWludDtcblxudmFyIHdvcmxkUGl2b3RBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZFBpdm90QiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpLFxuICAgIGcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cywgbGV0dGluZyB0aGVtIHJvdGF0ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyIGFyb3VuZCB0aGlzIHBvaW50LlxuICogQGNsYXNzIFJldm9sdXRlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy53b3JsZFBpdm90XSBBIHBpdm90IHBvaW50IGdpdmVuIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBJZiBzcGVjaWZpZWQsIGxvY2FsUGl2b3RBIGFuZCBsb2NhbFBpdm90QiBhcmUgYXV0b21hdGljYWxseSBjb21wdXRlZCBmcm9tIHRoaXMgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RBXSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90Ql0gU2VlIGxvY2FsUGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gVGhlIG1heGltdW0gZm9yY2UgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBjb25zdHJhaW4gdGhlIGJvZGllcy5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSByZXZvbHV0ZSBjb25zdHJhaW50IGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHBpdm90IHBvaW50IGluIGJldHdlZW4gdGhlbS5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxuICogICAgIH0pO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKlxuICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcbiAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5SRVZPTFVURSxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QVxuICAgICAqL1xuICAgIHRoaXMucGl2b3RBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QlxuICAgICAqL1xuICAgIHRoaXMucGl2b3RCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGlmKG9wdGlvbnMud29ybGRQaXZvdCl7XG4gICAgICAgIC8vIENvbXB1dGUgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90Qiwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIC8vIFJvdGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QSwgdGhpcy5waXZvdEEsIC1ib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RCLCB0aGlzLnBpdm90QiwgLWJvZHlCLmFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RCLCBvcHRpb25zLmxvY2FsUGl2b3RCKTtcbiAgICB9XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICBdO1xuXG4gICAgdmFyIHggPSBlcXNbMF07XG4gICAgdmFyIHkgPSBlcXNbMV07XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx4QXhpcyk7XG4gICAgfTtcblxuICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseUF4aXMpO1xuICAgIH07XG5cbiAgICB5Lm1pbkZvcmNlID0geC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICB5Lm1heEZvcmNlID0geC5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcblxuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW90b3IgaXMgZW5hYmxlZC4gVXNlIC5lbmFibGVNb3RvcigpIHRvIGVuYWJsZSB0aGUgY29uc3RyYWludCBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG1vdG9yRW5hYmxlZFxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RyYWludCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IDA7XG5cbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xufVxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBhbmdsZSBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9ICB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9ICB0aGlzLmJvZHlCLFxuICAgICAgICBwaXZvdEEgPSB0aGlzLnBpdm90QSxcbiAgICAgICAgcGl2b3RCID0gdGhpcy5waXZvdEIsXG4gICAgICAgIGVxcyA9ICAgIHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBub3JtYWwgPSBlcXNbMF0sXG4gICAgICAgIHRhbmdlbnQ9IGVxc1sxXSxcbiAgICAgICAgeCA9IGVxc1swXSxcbiAgICAgICAgeSA9IGVxc1sxXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uO1xuXG4gICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5hbmdsZSA9IHVwcGVyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPCBsb3dlckxpbWl0KXtcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gbG93ZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBpc1xuXG4gICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxuXG4gICAgLi4ud2hlcmUgeGkgYW5kIHhqIGFyZSB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIHJpIGFuZCByaiB3b3JsZC1vcmllbnRlZCBvZmZzZXQgdmVjdG9ycy4gRGlmZmVyZW50aWF0ZTpcblxuICAgICAgICBnZG90ID0gdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpXG5cbiAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXG5cbiAgICAgICAgZ2RvdCAqIHggPSAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArICh3aiB4IHJqKSp4IC12aSp4IC0od2kgeCByaSkqeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxuICAgICAgICAgICAgICAgICA9IFsgLXggICAtKHJpIHggeCkgICB4ICAgKHJqIHggeCldICogW3ZpIHdpIHZqIHdqXVxuICAgICAgICAgICAgICAgICA9IEcqV1xuXG4gICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XG5cbiAgICAgICAgR3ggPSBbIHggICAocmogeCB4KSAgIC14ICAgLShyaSB4IHgpXVxuICAgICAgICBHeSA9IFsgeSAgIChyaiB4IHkpICAgLXkgICAtKHJpIHggeSldXG5cbiAgICAgKi9cblxuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAvLyB0b2RvOiB0aGVzZSBhcmUgYSBiaXQgc3BhcnNlLiBXZSBjb3VsZCBzYXZlIHNvbWUgY29tcHV0YXRpb25zIG9uIG1ha2luZyBjdXN0b20gZXEuY29tcHV0ZUdXIGZ1bmN0aW9ucywgZXRjXG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG4gICAgeC5HWzRdID0gIDA7XG4gICAgeC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseEF4aXMpO1xuXG4gICAgeS5HWzBdID0gIDA7XG4gICAgeS5HWzFdID0gLTE7XG4gICAgeS5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseUF4aXMpO1xuICAgIHkuR1szXSA9ICAwO1xuICAgIHkuR1s0XSA9ICAxO1xuICAgIHkuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHlBeGlzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbW90b3IgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2QgbW90b3JJc0VuYWJsZWRcbiAqIEBkZXByZWNhdGVkIHVzZSBwcm9wZXJ0eSBtb3RvckVuYWJsZWQgaW5zdGVhZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUubW90b3JJc0VuYWJsZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXRoaXMubW90b3JFbmFibGVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9uc1tpXS5yZWxhdGl2ZVZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBnZXRNb3RvclNwZWVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHNwZWVkLCBvciBmYWxzZSBpZiB0aGUgbW90b3IgaXMgbm90IGVuYWJsZWQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb25cIjoyNCxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblwiOjI1LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0NvbnN0cmFpbnRcIjoxNH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmdsZUxvY2tFcXVhdGlvbjtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXG4gKlxuICogQGNsYXNzIEFuZ2xlTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHkgQS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYXRpb10gR2VhciByYXRpb1xuICovXG5mdW5jdGlvbiBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHNldFJhdGlvXG4gICAgICovXG4gICAgdGhpcy5yYXRpbyA9IHR5cGVvZihvcHRpb25zLnJhdGlvKT09PVwibnVtYmVyXCIgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIHRoaXMuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG59XG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5yYXRpbyAqIHRoaXMuYm9keUEuYW5nbGUgLSB0aGlzLmJvZHlCLmFuZ2xlICsgdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBnZWFyIHJhdGlvIGZvciB0aGlzIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHNldFJhdGlvXG4gKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldFJhdGlvID0gZnVuY3Rpb24ocmF0aW8pe1xuICAgIHZhciBHID0gdGhpcy5HO1xuICAgIEdbMl0gPSAgcmF0aW87XG4gICAgR1s1XSA9IC0xO1xuICAgIHRoaXMucmF0aW8gPSByYXRpbztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBlcXVhdGlvbi5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMubWF4Rm9yY2UgPSAgdG9ycXVlO1xuICAgIHRoaXMubWluRm9yY2UgPSAtdG9ycXVlO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vRXF1YXRpb25cIjoyMn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0RXF1YXRpb247XG5cbi8qKlxuICogTm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24uIFRyaWVzIHRvIG1ha2UgdGhlIGNvbnRhY3RQb2ludEEgYW5kIGNvbnRhY3RQb2ludEIgdmVjdG9ycyBjb2luY2lkZSwgd2hpbGUga2VlcGluZyB0aGUgYXBwbGllZCBmb3JjZSByZXB1bHNpdmUuXG4gKlxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgMCwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBWZWN0b3IgZnJvbSBib2R5IGkgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMi5jcmVhdGUoKTtcbiAgICB0aGlzLnBlbmV0cmF0aW9uVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciBmcm9tIGJvZHkgQSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbCB2ZWN0b3IsIHBvaW50aW5nIG91dCBvZiBib2R5IGlcbiAgICAgKiBAcHJvcGVydHkgbm9ybWFsQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHRvIHVzZSAoMD1ubyBib3VuY2luZXNzLCAxPW1heCBib3VuY2luZXNzKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBpbXBhY3QgYmV0d2VlbiB0aGUgYm9kaWVzIChub3QgcGVyc2lzdGFudCBjb250YWN0KS5cbiAgICAgKiBAcHJvcGVydHkgZmlyc3RJbXBhY3RcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0SW1wYWN0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBudWxsO1xufVxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICByaSA9IHRoaXMuY29udGFjdFBvaW50QSxcbiAgICAgICAgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG5cbiAgICB2YXIgcGVuZXRyYXRpb25WZWMgPSB0aGlzLnBlbmV0cmF0aW9uVmVjLFxuICAgICAgICBuID0gdGhpcy5ub3JtYWxBLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgdmFyIHJpeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaixuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHEgPSB4aityaiAtKHhpK3JpKSBpLmUuIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICB2ZWMyLmFkZChwZW5ldHJhdGlvblZlYyx4aixyaik7XG4gICAgdmVjMi5zdWIocGVuZXRyYXRpb25WZWMscGVuZXRyYXRpb25WZWMseGkpO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHJpKTtcblxuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEdXLCBHcTtcbiAgICBpZih0aGlzLmZpcnN0SW1wYWN0ICYmIHRoaXMucmVzdGl0dXRpb24gIT09IDApe1xuICAgICAgICBHcSA9IDA7XG4gICAgICAgIEdXID0gKDEvYikqKDErdGhpcy5yZXN0aXR1dGlvbikgKiB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEdxID0gdmVjMi5kb3QobixwZW5ldHJhdGlvblZlYykgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIH1cblxuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHZhciBCID0gLSBHcSAqIGEgLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbnZhciB2aSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdmogPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbFZlbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGl2ZSB2ZWxvY2l0eSBhbG9uZyB0aGUgbm9ybWFsIHZlY3Rvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5nZXRWZWxvY2l0eUFsb25nTm9ybWFsID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMuYm9keUEuZ2V0VmVsb2NpdHlBdFBvaW50KHZpLCB0aGlzLmNvbnRhY3RQb2ludEEpO1xuICAgIHRoaXMuYm9keUIuZ2V0VmVsb2NpdHlBdFBvaW50KHZqLCB0aGlzLmNvbnRhY3RQb2ludEIpO1xuXG4gICAgdmVjMi5zdWJ0cmFjdChyZWxWZWwsIHZpLCB2aik7XG5cbiAgICByZXR1cm4gdmVjMi5kb3QodGhpcy5ub3JtYWxBLCByZWxWZWwpO1xufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjJ9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEVxdWF0aW9uO1xuXG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpLFxuICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKSxcbiAgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBlcXVhdGlvbnMuXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QSBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluRm9yY2UgTWluaW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogLU51bWJlci5NQVhfVkFMVUVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LiBEZWZhdWx0OiBOdW1iZXIuTUFYX1ZBTFVFXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWluRm9yY2UsIG1heEZvcmNlKXtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtaW5Gb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5Gb3JjZSA9IHR5cGVvZihtaW5Gb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gLU51bWJlci5NQVhfVkFMVUUgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseSB3aGVuIHNvbHZpbmcuXG4gICAgICogQHByb3BlcnR5IG1heEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1ZBTFVFIDogbWF4Rm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyBvZiB0aGlzIGVxdWF0aW9uLiBUeXBpY2FsbHkgY2hvc2VuIHRvIGEgbGFyZ2UgbnVtYmVyICh+MWU3KSwgYnV0IGNhbiBiZSBjaG9zZW4gc29tZXdoYXQgZnJlZWx5IHRvIGdldCBhIHN0YWJsZSBzaW11bGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWUgc3RlcHMgbmVlZGVkIHRvIHN0YWJpbGl6ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbi4gVHlwaWNhbGx5IGJldHdlZW4gMyBhbmQgNSB0aW1lIHN0ZXBzLlxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgSmFjb2JpYW4gZW50cnkgb2YgdGhpcyBlcXVhdGlvbi4gNiBudW1iZXJzLCAzIHBlciBib2R5ICh4LHksYW5nbGUpLlxuICAgICAqIEBwcm9wZXJ0eSBHXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuRyA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKDYpO1xuICAgIGZvcih2YXIgaT0wOyBpPDY7IGkrKyl7XG4gICAgICAgIHRoaXMuR1tpXT0wO1xuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYSA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmVwc2lsb24gPSAwO1xuICAgIHRoaXMudGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHN0aWZmbmVzcyBvciByZWxheGF0aW9uIHdhcyBjaGFuZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbmVlZHNVcGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgY29uc3RyYWludCBtdWx0aXBsaWVyIGZyb20gdGhlIGxhc3Qgc29sdmUuIFRoaXMgaXMgbW9zdGx5IGVxdWl2YWxlbnQgdG8gdGhlIGZvcmNlIHByb2R1Y2VkIGJ5IHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBtdWx0aXBsaWVyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVsb2NpdHkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlbGF0aXZlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGVxdWF0aW9uIGlzIGVuYWJsZWQgb3Igbm90LiBJZiB0cnVlLCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbn1cbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWF0aW9uO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0aWZmbmVzcyB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfU1RJRkZORVNTXG4gKiBAZGVmYXVsdCAxZTZcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1MgPSAxZTY7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVsYXhhdGlvbiB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfUkVMQVhBVElPTlxuICogQGRlZmF1bHQgNFxuICovXG5FcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT04gPSA0O1xuXG4vKipcbiAqIENvbXB1dGUgU1BPT0sgcGFyYW1ldGVycyAuYSwgLmIgYW5kIC5lcHNpbG9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYXJhbWV0ZXJzLiBTZWUgZXF1YXRpb25zIDksIDEwIGFuZCAxMSBpbiB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcIj5TUE9PSyBub3RlczwvYT4uXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5yZWxheGF0aW9uLFxuICAgICAgICBoID0gdGhpcy50aW1lU3RlcDtcblxuICAgIHRoaXMuYSA9IDQuMCAvIChoICogKDEgKyA0ICogZCkpO1xuICAgIHRoaXMuYiA9ICg0LjAgKiBkKSAvICgxICsgNCAqIGQpO1xuICAgIHRoaXMuZXBzaWxvbiA9IDQuMCAvIChoICogaCAqIGsgKiAoMSArIDQgKiBkKSk7XG5cbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGEgamFjb2JpYW4gZW50cnkgd2l0aCBjb3JyZXNwb25kaW5nIHBvc2l0aW9ucyBvciB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGdtdWx0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5nbXVsdCA9IGZ1bmN0aW9uKEcsdmksd2ksdmosd2ope1xuICAgIHJldHVybiAgR1swXSAqIHZpWzBdICtcbiAgICAgICAgICAgIEdbMV0gKiB2aVsxXSArXG4gICAgICAgICAgICBHWzJdICogd2kgK1xuICAgICAgICAgICAgR1szXSAqIHZqWzBdICtcbiAgICAgICAgICAgIEdbNF0gKiB2alsxXSArXG4gICAgICAgICAgICBHWzVdICogd2o7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBSSFMgb2YgdGhlIFNQT09LIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGNvbXB1dGVCXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7XG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC0gR3EgKiBhIC0gR1cgKiBiIC0gR2lNZipoO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqcSwgd2hlcmUgcSBhcmUgdGhlIGdlbmVyYWxpemVkIGJvZHkgY29vcmRpbmF0ZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBxaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcWogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uLFxuICAgICAgICBhaSA9IGJpLmFuZ2xlLFxuICAgICAgICBhaiA9IGJqLmFuZ2xlO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRywgcWksIGFpLCBxaiwgYWopICsgdGhpcy5vZmZzZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKSArIHRoaXMucmVsYXRpdmVWZWxvY2l0eTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdmkgPSBiaS52bGFtYmRhLFxuICAgICAgICB2aiA9IGJqLnZsYW1iZGEsXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcbiAgICAgICAgd2ogPSBiai53bGFtYmRhO1xuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGlNZmogPSB2ZWMyLmNyZWF0ZSgpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgIHRpID0gYmkuYW5ndWxhckZvcmNlLFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0aiA9IGJqLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICB2ZWMyLnNjYWxlKGlNZmksIGZpLCBpbnZNYXNzaSk7XG4gICAgdmVjMi5tdWx0aXBseShpTWZpLCBiaS5tYXNzTXVsdGlwbGllciwgaU1maSk7XG4gICAgdmVjMi5zY2FsZShpTWZqLCBmaixpbnZNYXNzaik7XG4gICAgdmVjMi5tdWx0aXBseShpTWZqLCBiai5tYXNzTXVsdGlwbGllciwgaU1maik7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLGlNZmksdGkqaW52SWksaU1maix0aippbnZJaik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpHJ1xuICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHJldHVybiAgR1swXSAqIEdbMF0gKiBpbnZNYXNzaSAqIGJpLm1hc3NNdWx0aXBsaWVyWzBdICtcbiAgICAgICAgICAgIEdbMV0gKiBHWzFdICogaW52TWFzc2kgKiBiaS5tYXNzTXVsdGlwbGllclsxXSArXG4gICAgICAgICAgICBHWzJdICogR1syXSAqICAgIGludklpICtcbiAgICAgICAgICAgIEdbM10gKiBHWzNdICogaW52TWFzc2ogKiBiai5tYXNzTXVsdGlwbGllclswXSArXG4gICAgICAgICAgICBHWzRdICogR1s0XSAqIGludk1hc3NqICogYmoubWFzc011bHRpcGxpZXJbMV0gK1xuICAgICAgICAgICAgR1s1XSAqIEdbNV0gKiAgICBpbnZJajtcbn07XG5cbnZhciBhZGRUb1dsYW1iZGFfdGVtcCA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX3JqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbihkZWx0YWxhbWJkYSl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXAsXG4gICAgICAgIEdpID0gYWRkVG9XbGFtYmRhX0dpLFxuICAgICAgICBHaiA9IGFkZFRvV2xhbWJkYV9HaixcbiAgICAgICAgcmkgPSBhZGRUb1dsYW1iZGFfcmksXG4gICAgICAgIHJqID0gYWRkVG9XbGFtYmRhX3JqLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgTWRpYWcgPSBhZGRUb1dsYW1iZGFfTWRpYWcsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICBHaVswXSA9IEdbMF07XG4gICAgR2lbMV0gPSBHWzFdO1xuICAgIEdqWzBdID0gR1szXTtcbiAgICBHalsxXSA9IEdbNF07XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaSwgaW52TWFzc2kqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIubXVsdGlwbHkodGVtcCwgdGVtcCwgYmkubWFzc011bHRpcGxpZXIpO1xuICAgIHZlYzIuYWRkKCBiaS52bGFtYmRhLCBiaS52bGFtYmRhLCB0ZW1wKTtcbiAgICAvLyBUaGlzIGltcHVsc2UgaXMgaW4gdGhlIG9mZnNldCBmcmFtZVxuICAgIC8vIEFsc28gYWRkIGNvbnRyaWJ1dGlvbiB0byBhbmd1bGFyXG4gICAgLy9iaS53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaSk7XG4gICAgYmkud2xhbWJkYSArPSBpbnZJaSAqIEdbMl0gKiBkZWx0YWxhbWJkYTtcblxuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBHaiwgaW52TWFzc2oqZGVsdGFsYW1iZGEpO1xuICAgIHZlYzIubXVsdGlwbHkodGVtcCwgdGVtcCwgYmoubWFzc011bHRpcGxpZXIpO1xuICAgIHZlYzIuYWRkKCBiai52bGFtYmRhLCBiai52bGFtYmRhLCB0ZW1wKTtcbiAgICAvL2JqLndsYW1iZGEgLT0gdmVjMi5jcm9zc0xlbmd0aCh0ZW1wLHJqKTtcbiAgICBiai53bGFtYmRhICs9IGludklqICogR1s1XSAqIGRlbHRhbGFtYmRhO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEdcXCppbnYoTSlcXCpHJyArIGVwc1xuICogQG1ldGhvZCBjb21wdXRlSW52Q1xuICogQHBhcmFtICB7TnVtYmVyfSBlcHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVJbnZDID0gZnVuY3Rpb24oZXBzKXtcbiAgICByZXR1cm4gMS4wIC8gKHRoaXMuY29tcHV0ZUdpTUd0KCkgKyBlcHMpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnRcbiAqXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEEgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBCIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGFuZ2VudCB2ZWN0b3IgdGhhdCB0aGUgZnJpY3Rpb24gZm9yY2Ugd2lsbCBhY3QgYWxvbmcuIFdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSB0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudCA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0RXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIGZyaWN0aW9uIGVxdWF0aW9uLiBUaGUgY29udGFjdCBlcXVhdGlvbnMgY2FuIGJlIHVzZWQgdG8gcmVzY2FsZSB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZnJpY3Rpb24uIElmIG1vcmUgdGhhbiBvbmUgY29udGFjdCBlcXVhdGlvbiBpcyBnaXZlbiwgdGhlbiB0aGUgbWF4IGZvcmNlIGNhbiBiZSBzZXQgdG8gdGhlIGF2ZXJhZ2UuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Q29udGFjdEVxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUIuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG59XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxuICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbihzbGlwRm9yY2Upe1xuICAgIHRoaXMubWF4Rm9yY2UgPSBzbGlwRm9yY2U7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC1zbGlwRm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubWF4Rm9yY2U7XG59O1xuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgdCA9IHRoaXMudCxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICBHWzBdID0gLXRbMF07XG4gICAgR1sxXSA9IC10WzFdO1xuICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KTtcbiAgICBHWzNdID0gdFswXTtcbiAgICBHWzRdID0gdFsxXTtcbiAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vRXF1YXRpb25cIjoyMn1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbExvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5QS5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICAxO1xuICAgIEdbNV0gPSAtMTtcbn1cblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbnZhciB3b3JsZFZlY3RvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkVmVjdG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckEseEF4aXMsdGhpcy5ib2R5QS5hbmdsZSt0aGlzLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckIseUF4aXMsdGhpcy5ib2R5Qi5hbmdsZSk7XG4gICAgcmV0dXJuIHZlYzIuZG90KHdvcmxkVmVjdG9yQSx3b3JsZFZlY3RvckIpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vRXF1YXRpb25cIjoyMn1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblxuLyoqXG4gKiBTeW5jcyByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHR3byBib2RpZXMsIG9yIHNldHMgYSByZWxhdGl2ZSB2ZWxvY2l0eSAobW90b3IpLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSwgYm9keUIpe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMTtcbiAgICB0aGlzLnJhdGlvID0gMTtcbn1cblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb247XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9IC0xO1xuICAgIEdbNV0gPSB0aGlzLnJhdGlvO1xuXG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9FcXVhdGlvblwiOjIyfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXG4gKiBAY2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRFbWl0dGVyLFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0ICkge1xuICAgICAgICBsaXN0ZW5lci5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcbiAgICAgKiBAbWV0aG9kIGhhc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYobGlzdGVuZXIpe1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XG4gICAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudC5cbiAgICAgKiBAbWV0aG9kIGVtaXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudC50eXBlXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKCBsaXN0ZW5lci5jb250ZXh0LCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4vTWF0ZXJpYWwnKTtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLlxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQlxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvbj0wLjNdICAgICAgIEZyaWN0aW9uIGNvZWZmaWNpZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVzdGl0dXRpb249MF0gICAgICBSZXN0aXR1dGlvbiBjb2VmZmljaWVudCBha2EgXCJib3VuY2luZXNzXCIuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdGlmZm5lc3NdICAgICAgICAgIENvbnRhY3RFcXVhdGlvbiBzdGlmZm5lc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZWxheGF0aW9uXSAgICAgICAgIENvbnRhY3RFcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuc3VyZmFjZVZlbG9jaXR5PTBdICBTdXJmYWNlIHZlbG9jaXR5LlxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoIShtYXRlcmlhbEEgaW5zdGFuY2VvZiBNYXRlcmlhbCkgfHwgIShtYXRlcmlhbEIgaW5zdGFuY2VvZiBNYXRlcmlhbCkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCB0d28gYXJndW1lbnRzIG11c3QgYmUgTWF0ZXJpYWwgaW5zdGFuY2VzLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEFcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEJcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XG5cbiAgICAvKipcbiAgICAgKiBGcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFscy4gRnJpY3Rpb24gPSAwIHdpbGwgbWFrZSB0aGUgaW52b2x2ZWQgb2JqZWN0cyBzdXBlciBzbGlwcGVyeSwgYW5kIGZyaWN0aW9uID0gMSB3aWxsIG1ha2UgaXQgbXVjaCBsZXNzIHNsaXBwZXJ5LiBBIGZyaWN0aW9uIGNvZWZmaWNpZW50IGxhcmdlciB0aGFuIDEgd2lsbCBhbGxvdyBmb3IgdmVyeSBsYXJnZSBmcmljdGlvbiBmb3JjZXMsIHdoaWNoIGNhbiBiZSBjb252ZW5pZW50IGZvciBwcmV2ZW50aW5nIGNhciB0aXJlcyBub3Qgc2xpcCBvbiB0aGUgZ3JvdW5kLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4zXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiA9IHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLmZyaWN0aW9uKSA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uLCBvciBcImJvdW5jaW5lc3NcIiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFscy4gQSByZXN0aXR1dGlvbiBvZiAwIHdpbGwgbWFrZSBubyBib3VuY2UsIHdoaWxlIHJlc3RpdHV0aW9uPTEgd2lsbCBhcHByb3hpbWF0ZWx5IGJvdW5jZSBiYWNrIHdpdGggdGhlIHNhbWUgdmVsb2NpdHkgdGhlIG9iamVjdCBjYW1lIHdpdGguXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnJlc3RpdHV0aW9uKSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBIYXJkbmVzcyBvZiB0aGUgY29udGFjdC4gTGVzcyBzdGlmZm5lc3Mgd2lsbCBtYWtlIHRoZSBvYmplY3RzIHBlbmV0cmF0ZSBtb3JlLCBhbmQgd2lsbCBtYWtlIHRoZSBjb250YWN0IGFjdCBtb3JlIGxpa2UgYSBzcHJpbmcgdGhhbiBhIGNvbnRhY3QgZm9yY2UuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IHR5cGVvZihvcHRpb25zLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5zdGlmZm5lc3MpIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGUuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnJlbGF4YXRpb24pIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgZnJpY3Rpb24gZm9yY2UuIEZvciBtb3N0IGNhc2VzLCB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgYSBsYXJnZSBudW1iZXIuIEkgY2Fubm90IHRoaW5rIG9mIGFueSBjYXNlIHdoZXJlIHlvdSB3b3VsZCB3YW50IGxlc3MgZnJpY3Rpb25TdGlmZm5lc3MuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25TdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gVGhlIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIGdvb2QgZm9yIG1vc3Qgc2ltdWxhdGlvbnMuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBhZGQgc3VyZmFjZSB2ZWxvY2l0eSB0byB0aGlzIG1hdGVyaWFsLiBJZiBib2R5QSByZXN0cyBvbiB0b3AgaWYgYm9keUIsIGFuZCB0aGUgc3VyZmFjZSB2ZWxvY2l0eSBpcyBwb3NpdGl2ZSwgYm9keUEgd2lsbCBzbGlkZSB0byB0aGUgcmlnaHQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IHR5cGVvZihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgIT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIob3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpIDogMDtcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCB0byBiZSBzZXQgb24gQ29udGFjdEVxdWF0aW9ucy4gQSBwb3NpdGl2ZSB2YWx1ZSB3aWxsIG1ha2UgdGhlIGJvZGllcyBwZW5ldHJhdGUgbW9yZSBpbnRvIGVhY2ggb3RoZXIuIENhbiBiZSB1c2VmdWwgaW4gc2NlbmVzIHdoZXJlIGNvbnRhY3RzIG5lZWQgdG8gYmUgbW9yZSBwZXJzaXN0ZW50LCBmb3IgZXhhbXBsZSB3aGVuIHN0YWNraW5nLiBBa2EgXCJjdXJlIGZvciBuZXJ2b3VzIGNvbnRhY3RzXCIuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAwNTtcbn1cblxuQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjIsXCIuL01hdGVyaWFsXCI6Mjh9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBNYXRlcmlhbCBpZGVudGlmaWVyXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIE1hdGVyaWFsKGlkKXtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF0ZXJpYWwgaWRlbnRpZmllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkIHx8IE1hdGVyaWFsLmlkQ291bnRlcisrO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbiAgICAvKlxuICAgICAgICBQb2x5SyBsaWJyYXJ5XG4gICAgICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgICAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICBjb25kaXRpb25zOlxuXG4gICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICovXG5cbiAgICB2YXIgUG9seUsgPSB7fTtcblxuICAgIC8qXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XG5cbiAgICAgICAgTyhuXjIpXG4gICAgKi9cbiAgICAvKlxuICAgIFBvbHlLLklzU2ltcGxlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhMSA9IG5ldyBQb2x5Sy5fUCgpLCBhMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYjEgPSBuZXcgUG9seUsuX1AoKSwgYjIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgUG9seUsuX1AoKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcbiAgICAgICAgICAgIGExLnkgPSBwWzIqaSsxXTtcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaS1qKSA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSkgIHsgYjIueCA9IHBbMCAgICBdOyAgYjIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cblxuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBQb2x5Sy5Jc0NvbnZleCA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2ldLCBwW2krMV0sIHBbaSsyXSwgcFtpKzNdLCBwW2krNF0sIHBbaSs1XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLkdldEFyZWEgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcbiAgICAgICAgc3VtICs9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcbiAgICAgICAgcmV0dXJuIC0gc3VtICogMC41O1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkdldEFBQkIgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcbiAgICAgICAgdmFyIG1heHkgPSAtbWlueTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcbiAgICAgICAgICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XG4gICAgfVxuICAgICovXG5cbiAgICBQb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDMpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHRncyA9IFtdO1xuICAgICAgICB2YXIgYXZsID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYWwgPSBuO1xuICAgICAgICB3aGlsZShhbCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKFBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPGFsOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmKHZpPT1pMCB8fCB2aT09aTEgfHwgdmk9PWkyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7ZWFyRm91bmQgPSBmYWxzZTsgYnJlYWs7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICAgICAgaT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsrID4gMyphbCkgYnJlYWs7ICAgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICAgICAgICB9XG4gICAgICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgICAgICByZXR1cm4gdGdzO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwLCBweCwgcHkpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCA9IHBbMipuLTJdLXB4LCBieSA9IHBbMipuLTFdLXB5O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xuICAgICAgICAgICAgYnkgPSBwWzIqaSsxXSAtIHB5O1xuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF4PCAwICYmIGJ4PCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XG4gICAgICAgICAgICBpZihseD4wKSBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIFBvbHlLLlNsaWNlID0gZnVuY3Rpb24ocCwgYXgsIGF5LCBieCwgYnkpXG4gICAge1xuICAgICAgICBpZihQb2x5Sy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgUG9seUsuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuXG4gICAgICAgIHZhciBhID0gbmV3IFBvbHlLLl9QKGF4LCBheSk7XG4gICAgICAgIHZhciBiID0gbmV3IFBvbHlLLl9QKGJ4LCBieSk7XG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gICAgICAgIHZhciBwcyA9IFtdOyAgICAvLyBwb2ludHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IFBvbHlLLl9QKHBbaV0sIHBbaSsxXSkpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNjID0gbmV3IFBvbHlLLl9QKDAsMCk7XG4gICAgICAgICAgICBpc2MgPSBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkrMSklcHMubGVuZ3RoXSwgaXNjKTtcblxuICAgICAgICAgICAgaWYoaXNjKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgICAgICAgICAgICBwcy5zcGxpY2UoaSsxLDAsaXNjKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcbiAgICAgICAgdmFyIGNvbXAgPSBmdW5jdGlvbih1LHYpIHtyZXR1cm4gUG9seUsuX1AuZGlzdChhLHUpIC0gUG9seUsuX1AuZGlzdChhLHYpOyB9XG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcblxuICAgICAgICB2YXIgcGdzID0gW107XG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICAgICAgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc29sdmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpci0tO1xuICAgICAgICAgICAgICAgIHZhciBwZ24gPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcbiAgICAgICAgICAgICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgICAgICAgICAgIHBzID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XG4gICAgICAgICAgICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cGcubGVuZ3RoOyBqKyspIG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIFBvbHlLLlJheWNhc3QgPSBmdW5jdGlvbihwLCB4LCB5LCBkeCwgZHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XG5cbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLkNsb3Nlc3RFZGdlID0gZnVuY3Rpb24ocCwgeCwgeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XG5cbiAgICAgICAgdmFyIGlkc3QgPSAxL2lzYy5kaXN0O1xuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcbiAgICAgICAgcmV0dXJuIGlzYztcbiAgICB9XG5cbiAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdCA9IGZ1bmN0aW9uKHAsIGEsIGIsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcblxuICAgICAgICB2YXIgQSA9IHggLSB4MTtcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcbiAgICAgICAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICAgICAgICB2YXIgbGVuX3NxID0gQyAqIEMgKyBEICogRDtcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xuXG4gICAgICAgIHZhciB4eCwgeXk7XG5cbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgICAgICAgICB4eCA9IHgxO1xuICAgICAgICAgICAgeXkgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgICAgIHh4ID0geDI7XG4gICAgICAgICAgICB5eSA9IHkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICAgICAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSB4IC0geHg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmKGRzdDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl91cGRhdGVJU0MgPSBmdW5jdGlvbihkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBucmwgPSBQb2x5Sy5fUC5kaXN0KGExLCBjKTtcbiAgICAgICAgaWYobnJsPGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaWJsID0gMS9Qb2x5Sy5fUC5kaXN0KGIxLCBiMik7XG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcbiAgICAgICAgICAgIHZhciBkZG90ID0gMiooZHgqbngrZHkqbnkpO1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgICAgICAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fZ2V0UG9pbnRzID0gZnVuY3Rpb24ocHMsIGluZDAsIGluZDEpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5wcyA9IFtdO1xuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xuICAgICAgICByZXR1cm4gbnBzO1xuICAgIH1cblxuICAgIFBvbHlLLl9maXJzdFdpdGhGbGFnID0gZnVuY3Rpb24ocHMsIGluZClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgdmFyIHYweCA9IGN4LWF4O1xuICAgICAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgICAgIHZhciB2MXggPSBieC1heDtcbiAgICAgICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgICAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgICAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApICogaURlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xuXG4gICAgICAgIGlmKCFQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF4PjAgJiYgSS54PmExLngpIHx8IChkYXg8MCAmJiBJLng8YTEueCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApIC8gRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcblxuICAgICAgICBpZihQb2x5Sy5fSW5SZWN0KEksIGExLCBhMikgJiYgUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuX0luUmVjdCA9IGZ1bmN0aW9uKGEsIGIsIGMpXG4gICAge1xuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xuXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICByZXR1cm4gKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDA7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1AgPSBmdW5jdGlvbih4LHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgUG9seUsuX1AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiUG9pbnQgW1wiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiXVwiO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5kaXN0ID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gYi54LWEueDtcbiAgICAgICAgdmFyIGR5ID0gYi55LWEueTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fdHAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSBQb2x5Sy5fdHAucHVzaChuZXcgUG9seUsuX1AoMCwwKSk7XG4gICAgICAgICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seUs7XG5cbn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIFRoZSB2ZWMyIG9iamVjdCBmcm9tIGdsTWF0cml4LCB3aXRoIHNvbWUgZXh0ZW5zaW9ucyBhbmQgc29tZSByZW1vdmVkIG1ldGhvZHMuIFNlZSBodHRwOi8vZ2xtYXRyaXgubmV0LlxuICogQGNsYXNzIHZlYzJcbiAqL1xuXG52YXIgdmVjMiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogTWFrZSBhIGNyb3NzIHByb2R1Y3QgYW5kIG9ubHkgcmV0dXJuIHRoZSB6IGNvbXBvbmVudFxuICogQG1ldGhvZCBjcm9zc0xlbmd0aFxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NMZW5ndGggPSBmdW5jdGlvbihhLGIpe1xuICAgIHJldHVybiBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1ZaXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NWWiA9IGZ1bmN0aW9uKG91dCwgdmVjLCB6Y29tcCl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYywtTWF0aC5QSS8yKTsvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNyb3NzWlZcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSB2ZWNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc1pWID0gZnVuY3Rpb24ob3V0LCB6Y29tcCwgdmVjKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsdmVjLE1hdGguUEkvMik7IC8vIFJvdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0IGhhbmQgcnVsZVxuICAgIHZlYzIuc2NhbGUob3V0LG91dCx6Y29tcCk7ICAgICAgLy8gU2NhbGUgd2l0aCB6XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IGFuIGFuZ2xlXG4gKiBAbWV0aG9kIHJvdGF0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGUgPSBmdW5jdGlvbihvdXQsYSxhbmdsZSl7XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gYVswXSxcbiAgICAgICAgICAgIHkgPSBhWzFdO1xuICAgICAgICBvdXRbMF0gPSBjKnggLXMqeTtcbiAgICAgICAgb3V0WzFdID0gcyp4ICtjKnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxuICogQG1ldGhvZCByb3RhdGU5MGN3XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG52ZWMyLnJvdGF0ZTkwY3cgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF07XG4gICAgdmFyIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IHk7XG4gICAgb3V0WzFdID0gLXg7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGxvY2FsIGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCB3b3JsZFBvaW50KTtcbiAgICB2ZWMyLnN1YihvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG4gICAgdmVjMi5yb3RhdGUob3V0LCBvdXQsIC1mcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gZ2xvYmFsIGZyYW1lLlxuICogQG1ldGhvZCB0b0dsb2JhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQsIGxvY2FsUG9pbnQpO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCBmcmFtZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgZnJhbWVQb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHZlY3RvciB0byBsb2NhbCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRWZWN0b3JcbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRWZWN0b3IsIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIucm90YXRlKG91dCwgd29ybGRWZWN0b3IsIC1mcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gZ2xvYmFsIGZyYW1lLlxuICogQG1ldGhvZCB0b0dsb2JhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3JcbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnZlY3RvclRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsVmVjdG9yLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIGxvY2FsVmVjdG9yLCBmcmFtZUFuZ2xlKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBjZW50cm9pZCBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdmVjdG9ycyBhLGIsYy4gU2VlIGh0dHA6Ly9lYXN5Y2FsY3VsYXRpb24uY29tL2FuYWx5dGljYWwvbGVhcm4tY2VudHJvaWQucGhwXG4gKiBAbWV0aG9kIGNlbnRyb2lkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuICB7QXJyYXl9IFRoZSBvdXQgb2JqZWN0XG4gKi9cbnZlYzIuY2VudHJvaWQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgIHZlYzIuYWRkKG91dCwgYSwgYik7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGMpO1xuICAgIHZlYzIuc2NhbGUob3V0LCBvdXQsIDEvMyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbVZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3VidHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnN1YnRyYWN0XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YlxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5tdWx0aXBseVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBtdWxcbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZpZGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXZpZGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGl2XG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuZGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGlzdFxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkRGlzdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5zcXVhcmVkRGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyRGlzdFxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmxlbmd0aFxuICogQG1ldGhvZCBsZW5cbiAqIEBzdGF0aWNcbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3F1YXJlZExlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWRMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyTGVuXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5lZ2F0ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3RyXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlL21peCB0d28gdmVjdG9ycy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVycFxuICogQHBhcmFtIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBhIEZpcnN0IHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYiBTZWNvbmQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdCBMZXJwIGZhY3RvclxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlZmxlY3QgYSB2ZWN0b3IgYWxvbmcgYSBub3JtYWwuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHJlZmxlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG91dFxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBub3JtYWxcbiAqL1xudmVjMi5yZWZsZWN0ID0gZnVuY3Rpb24ob3V0LCB2ZWN0b3IsIG5vcm1hbCl7XG4gICAgdmFyIGRvdCA9IHZlY3RvclswXSAqIG5vcm1hbFswXSArIHZlY3RvclsxXSAqIG5vcm1hbFsxXTtcbiAgICBvdXRbMF0gPSB2ZWN0b3JbMF0gLSAyICogbm9ybWFsWzBdICogZG90O1xuICAgIG91dFsxXSA9IHZlY3RvclsxXSAtIDIgKiBub3JtYWxbMV0gKiBkb3Q7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvblxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xudmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihvdXQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgdmFyIHQgPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKHAwLCBwMSwgcDIsIHAzKTtcbiAgICBpZih0IDwgMCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBwMFswXSArICh0ICogKHAxWzBdIC0gcDBbMF0pKTtcbiAgICAgICAgb3V0WzFdID0gcDBbMV0gKyAodCAqIChwMVsxXSAtIHAwWzFdKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gZnJhY3Rpb24gYmV0d2VlbiB0d28gbGluZSBzZWdtZW50cy4gSWYgc3VjY2Vzc2Z1bCwgdGhlIGludGVyc2VjdGlvbiBpcyBhdCBwMCArIHQgKiAocDEgLSBwMClcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb25cbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqIEBwYXJhbSAge0FycmF5fSBwM1xuICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaWYgdGhlcmUgd2FzIGFuIGludGVyc2VjdGlvbiwgb3RoZXJ3aXNlIC0xLlxuICovXG52ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgczFfeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgdmFyIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xuICAgIHZhciBzMl94ID0gcDNbMF0gLSBwMlswXTtcbiAgICB2YXIgczJfeSA9IHAzWzFdIC0gcDJbMV07XG5cbiAgICB2YXIgcywgdDtcbiAgICBzID0gKC1zMV95ICogKHAwWzBdIC0gcDJbMF0pICsgczFfeCAqIChwMFsxXSAtIHAyWzFdKSkgLyAoLXMyX3ggKiBzMV95ICsgczFfeCAqIHMyX3kpO1xuICAgIHQgPSAoIHMyX3ggKiAocDBbMV0gLSBwMlsxXSkgLSBzMl95ICogKHAwWzBdIC0gcDJbMF0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XG4gICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMSkgeyAvLyBDb2xsaXNpb24gZGV0ZWN0ZWRcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXG59O1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTd9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgZGVjb21wID0gX2RlcmVxXygncG9seS1kZWNvbXAnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpXG4sICAgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpXG4sICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxuLyoqXG4gKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxuICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXG4gKlxuICogQGNsYXNzIEJvZHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mb3JjZV1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXBdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhckZvcmNlPTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2NkSXRlcmF0aW9ucz0xMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZD0tMV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdyYXZpdHlTY2FsZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pZF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXNzPTBdIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGVlcFNwZWVkTGltaXRdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgdHlwaWNhbCBkeW5hbWljIGJvZHlcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMSxcbiAqICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcbiAqICAgICAgICAgYW5nbGU6IDAsXG4gKiAgICAgICAgIHZlbG9jaXR5OiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogMFxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBjaXJjdWxhciBzaGFwZSB0byB0aGUgYm9keVxuICogICAgIGJvZHkuYWRkU2hhcGUobmV3IENpcmNsZSh7IHJhZGl1czogMSB9KSk7XG4gKlxuICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xuICovXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBpZGVudGlmeWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCArK0JvZHkuX2lkQ291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0aGF0IHRoaXMgYm9keSBpcyBhZGRlZCB0by4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gTlVMTCBpZiB0aGUgYm9keSBpcyBub3QgYWRkZWQgdG8gYW55IHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXNzID0gb3B0aW9ucy5tYXNzIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludk1hc3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZXJ0aWEgb2YgdGhlIGJvZHkgYXJvdW5kIHRoZSBaIGF4aXMuXG4gICAgICogQHByb3BlcnR5IGluZXJ0aWFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5lcnRpYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBpbmVydGlhIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBpbnZJbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuXG4gICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGZpeGVkUm90YXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSAhIW9wdGlvbnMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgYm9keSBtb3ZlbWVudCBhbG9uZyB0aGUgWCBheGlzLiBUaGUgYm9keSB3aWxsIHN0aWxsIGJlIGFibGUgdG8gbW92ZSBhbG9uZyBZLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZml4ZWRYXG4gICAgICovXG4gICAgdGhpcy5maXhlZFggPSAhIW9wdGlvbnMuZml4ZWRYO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSBib2R5IG1vdmVtZW50IGFsb25nIHRoZSBZIGF4aXMuIFRoZSBib2R5IHdpbGwgc3RpbGwgYmUgYWJsZSB0byBtb3ZlIGFsb25nIFguXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFlcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkWSA9ICEhb3B0aW9ucy5maXhlZFk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IG1hc3NNdWx0aXBsaWVyXG4gICAgICovXG4gICAgdGhpcy5tYXNzTXVsdGlwbGllciA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGFuZ2xlIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c0FuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudmVsb2NpdHksIG9wdGlvbnMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIHRoZSBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHZsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52bGFtYmRhID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLndsYW1iZGEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBib2R5LCBpbiByYWRpYW5zLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhlIGFuZ2xlIHByb3BlcnR5IGlzIG5vdCBub3JtYWxpemVkIHRvIHRoZSBpbnRlcnZhbCAwIHRvIDIqcGksIGl0IGNhbiBiZSBhbnkgdmFsdWUuXG4gICAgICogICAgIC8vIElmIHlvdSBuZWVkIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyKnBpLCB1c2UgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiB0byBub3JtYWxpemUgaXQuXG4gICAgICogICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlKGFuZ2xlKXtcbiAgICAgKiAgICAgICAgIGFuZ2xlID0gYW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICAgKiAgICAgICAgIGlmKGFuZ2xlIDwgMCl7XG4gICAgICogICAgICAgICAgICAgYW5nbGUgKz0gKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaW5jZSB0aGUgYm9keSBmb3JjZSAoYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvYW5ndWxhckZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KSB3aWxsIGJlIHplcm9lZCBhZnRlciBlYWNoIHN0ZXAsIHNvIHlvdSBuZWVkIHRvIHNldCB0aGUgZm9yY2UgYmVmb3JlIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHByb2R1Y2VzIGEgZm9yY2VmaWVsZCBvZiAxIE5ld3RvbiBpbiB0aGUgcG9zaXRpdmUgeCBkaXJlY3Rpb24uXG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5mb3JjZVswXSA9IDE7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgYXBwbHkgYSByb3RhdGlvbmFsIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5hbmd1bGFyRm9yY2UgPSAtMztcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zLmZvcmNlKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZm9yY2UsIG9wdGlvbnMuZm9yY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvZm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJGb3JjZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSBvcHRpb25zLmFuZ3VsYXJGb3JjZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVhciBkYW1waW5nIGFjdGluZyBvbiB0aGUgYm9keSBpbiB0aGUgdmVsb2NpdHkgZGlyZWN0aW9uLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5kYW1waW5nIDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJEYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJEYW1waW5nID0gdHlwZW9mKG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmd1bGFyRGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1vdGlvbiB0aGlzIGJvZHkgaGFzLiBTaG91bGQgYmUgb25lIG9mOiB7eyNjcm9zc0xpbmsgXCJCb2R5L1NUQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LlNUQVRJQ3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L0RZTkFNSUM6cHJvcGVydHlcIn19Qm9keS5EWU5BTUlDe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvS0lORU1BVElDOnByb3BlcnR5XCJ9fUJvZHkuS0lORU1BVElDe3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiAqIFN0YXRpYyBib2RpZXMgZG8gbm90IG1vdmUsIGFuZCB0aGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBjb2xsaXNpb24uXG4gICAgICogKiBEeW5hbWljIGJvZGllcyBib2R5IGNhbiBtb3ZlIGFuZCByZXNwb25kIHRvIGNvbGxpc2lvbnMgYW5kIGZvcmNlcy5cbiAgICAgKiAqIEtpbmVtYXRpYyBib2RpZXMgb25seSBtb3ZlcyBhY2NvcmRpbmcgdG8gaXRzIC52ZWxvY2l0eSwgYW5kIGRvZXMgbm90IHJlc3BvbmQgdG8gY29sbGlzaW9ucyBvciBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJvZGllcyBhcmUgc3RhdGljIGJ5IGRlZmF1bHQuIFN0YXRpYyBib2RpZXMgd2lsbCBuZXZlciBtb3ZlLlxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudHlwZSA9PSBCb2R5LlNUQVRJQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJ5IHNldHRpbmcgdGhlIG1hc3Mgb2YgYSBib2R5IHRvIGEgbm9uemVybyBudW1iZXIsIHRoZSBib2R5XG4gICAgICogICAgIC8vIHdpbGwgYmVjb21lIGR5bmFtaWMgYW5kIHdpbGwgbW92ZSBhbmQgaW50ZXJhY3Qgd2l0aCBvdGhlciBib2RpZXMuXG4gICAgICogICAgIHZhciBkeW5hbWljQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgKiAgICAgICAgIG1hc3MgOiAxXG4gICAgICogICAgIH0pO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhkeW5hbWljQm9keS50eXBlID09IEJvZHkuRFlOQU1JQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgd2lsbCBvbmx5IG1vdmUgaWYgeW91IGNoYW5nZSB0aGVpciB2ZWxvY2l0eS5cbiAgICAgKiAgICAgdmFyIGtpbmVtYXRpY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICB0eXBlOiBCb2R5LktJTkVNQVRJQyAvLyBUeXBlIGNhbiBiZSBzZXQgdmlhIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy50eXBlKSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfSBlbHNlIGlmKCFvcHRpb25zLm1hc3Mpe1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LkRZTkFNSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgYm94IG9mIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBQUJCfVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdXBkYXRlLiBVcGRhdGUgaXQgd2l0aCB7eyNjcm9zc0xpbmsgXCJCb2R5L3VwZGF0ZUFBQkI6bWV0aG9kXCJ9fS51cGRhdGVBQUJCKCl7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHNlZSB1cGRhdGVBQUJCXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcbiAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBib2R5IHdpbGwgYXV0b21hdGljYWxseSBmYWxsIHRvIHNsZWVwLiBOb3RlIHRoYXQgeW91IG5lZWQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJXb3JsZFwifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgYW55dGhpbmcgd2lsbCBoYXBwZW4uXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gb3B0aW9ucy5hbGxvd1NsZWVwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFsbG93U2xlZXAgOiB0cnVlO1xuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9uZSBvZiB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUFk6cHJvcGVydHlcIn19Qm9keS5TTEVFUFl7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9TTEVFUElORzpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiBUaGUgYm9keSBpcyBpbml0aWFsbHkgQm9keS5BV0FLRS4gSWYgaXRzIHZlbG9jaXR5IG5vcm0gaXMgYmVsb3cgLnNsZWVwU3BlZWRMaW1pdCwgdGhlIHNsZWVwU3RhdGUgd2lsbCBiZWNvbWUgQm9keS5TTEVFUFkuIElmIHRoZSBib2R5IGNvbnRpbnVlcyB0byBiZSBCb2R5LlNMRUVQWSBmb3IgLnNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IHdpbGwgZmFsbCBhc2xlZXAgKEJvZHkuU0xFRVBZKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFN0YXRlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBCb2R5LkFXQUtFXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4yXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFNwZWVkTGltaXQgPSBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbGVlcFNwZWVkTGltaXQgOiAwLjI7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcHkgZm9yIHRoaXMgc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBzbGVlcGluZy5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBUaW1lTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHlTY2FsZSA9IG9wdGlvbnMuZ3Jhdml0eVNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdyYXZpdHlTY2FsZSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGJvZHkgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9kaWVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxuICAgICAqL1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgdGltZSB3aGVuIHRoZSBib2R5IHdlbnQgdG8gU0xFRVBZIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lTGFzdFNsZWVweVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBzcGVlZCBleGNlZWRzIHRoaXMgdGhyZXNob2xkLCBDQ0QgKGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbikgd2lsbCBiZSBlbmFibGVkLiBTZXQgaXQgdG8gYSBuZWdhdGl2ZSBudW1iZXIgdG8gZGlzYWJsZSBDQ0QgY29tcGxldGVseSBmb3IgdGhpcyBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RTcGVlZFRocmVzaG9sZFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciB0aGUgdGltZSBvZiBpbXBhY3QgZHVyaW5nIENDRC4gQSBsYXJnZXIgbnVtYmVyIHdpbGwgYXNzdXJlIHRoYXQgdGhlcmUncyBhIHNtYWxsIHBlbmV0cmF0aW9uIG9uIENDRCBjb2xsaXNpb24sIGJ1dCBhIHNtYWxsIG51bWJlciB3aWxsIGdpdmUgbW9yZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkSXRlcmF0aW9uc1xuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5jY2RJdGVyYXRpb25zID0gb3B0aW9ucy5jY2RJdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgOiAxMDtcblxuICAgIHRoaXMuY29uY2F2ZVBhdGggPSBudWxsO1xuXG4gICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Cb2R5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvZHk7XG5cbkJvZHkuX2lkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IHRoaXMuaW52SW5lcnRpYTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdG90YWwgZGVuc2l0eSBvZiB0aGUgYm9keVxuICogQG1ldGhvZCBzZXREZW5zaXR5XG4gKiBAcGFyYW0ge251bWJlcn0gZGVuc2l0eVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oZGVuc2l0eSkge1xuICAgIHZhciB0b3RhbEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgICB0aGlzLm1hc3MgPSB0b3RhbEFyZWEgKiBkZW5zaXR5O1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBhcmVhIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGJvZHlcbiAqIEBtZXRob2QgZ2V0QXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0b3RhbEFyZWEgKz0gdGhpcy5zaGFwZXNbaV0uYXJlYTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQXJlYTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIGZyb20gdGhlIGJvZHkuIFRoZSBBQUJCIGlzIHVwZGF0ZWQgaWYgbmVjZXNzYXJ5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgQUFCQiBpbnN0YW5jZSAodGhpcy5hYWJiKVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hYWJiO1xufTtcblxudmFyIHNoYXBlQUFCQiA9IG5ldyBBQUJCKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBBQUJCIG9mIHRoZSBCb2R5LCBhbmQgc2V0IC5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZS5cbiAqIEBtZXRob2QgdXBkYXRlQUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wLFxuICAgICAgICBib2R5QW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBhbmdsZSA9IHNoYXBlLmFuZ2xlICsgYm9keUFuZ2xlO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBvZmZzZXRcbiAgICAgICAgdmVjMi5yb3RhdGUob2Zmc2V0LCBzaGFwZS5wb3NpdGlvbiwgYm9keUFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNvbXB1dGVBQUJCKHNoYXBlQUFCQiwgb2Zmc2V0LCBhbmdsZSk7XG5cbiAgICAgICAgaWYoaT09PTApe1xuICAgICAgICAgICAgdGhpcy5hYWJiLmNvcHkoc2hhcGVBQUJCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5leHRlbmQoc2hhcGVBQUJCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBib2R5ICh0aGlzLmJvdW5kaW5nUmFkaXVzKS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZSBkaW1lbnNpb25zIG9yIHBvc2l0aW9ucyBhcmUgY2hhbmdlZC5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHZlYzIubGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIHIgPSBzaGFwZS5ib3VuZGluZ1JhZGl1cztcbiAgICAgICAgaWYob2Zmc2V0ICsgciA+IHJhZGl1cyl7XG4gICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcbn07XG5cbi8qKlxuICogQWRkIGEgc2hhcGUgdG8gdGhlIGJvZHkuIFlvdSBjYW4gcGFzcyBhIGxvY2FsIHRyYW5zZm9ybSB3aGVuIGFkZGluZyBhIHNoYXBlLFxuICogc28gdGhhdCB0aGUgc2hhcGUgZ2V0cyBhbiBvZmZzZXQgYW5kIGFuZ2xlIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogV2lsbCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIGFuZCBib3VuZGluZyByYWRpdXMuXG4gKlxuICogQG1ldGhvZCBhZGRTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgICAgICAgICBzaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IFtvZmZzZXRdIExvY2FsIGJvZHkgb2Zmc2V0IG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgW2FuZ2xlXSAgTG9jYWwgYm9keSBhbmdsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKSxcbiAqICAgICAgICAgc2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqXG4gKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB4LWF4aXMuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMSwwXSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeS1heGlzLCBhbmQgcm90YXRlZCA5MCBkZWdyZWVzIENDVy5cbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFswLDFdLE1hdGguUEkvMik7XG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIG9mZnNldCwgYW5nbGUpe1xuICAgIGlmKHNoYXBlLmJvZHkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2hhcGUgY2FuIG9ubHkgYmUgYWRkZWQgdG8gb25lIGJvZHkuJyk7XG4gICAgfVxuICAgIHNoYXBlLmJvZHkgPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgb2Zmc2V0IHZlY3RvclxuICAgIGlmKG9mZnNldCl7XG4gICAgICAgIHZlYzIuY29weShzaGFwZS5wb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZWMyLnNldChzaGFwZS5wb3NpdGlvbiwgMCwgMCk7XG4gICAgfVxuXG4gICAgc2hhcGUuYW5nbGUgPSBhbmdsZSB8fCAwO1xuXG4gICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZSk7XG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc2hhcGVcbiAqIEBtZXRob2QgcmVtb3ZlU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2hhcGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XG5cbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaGFwZS5ib2R5ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlblxuICogY2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvciBtYXNzIG9mIHRoZSBCb2R5LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlTWFzc1Byb3BlcnRpZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGJvZHkubWFzcyArPSAxO1xuICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG5cbiAgICAgICAgdGhpcy5tYXNzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMDtcbiAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5tYXNzIC8gTixcbiAgICAgICAgICAgIEkgPSAwO1xuXG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYShtKTtcbiAgICAgICAgICAgICAgICBJICs9IEljbSArIG0qcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJO1xuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gST4wID8gMS9JIDogMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnNlIG1hc3MgcHJvcGVydGllcyBhcmUgZWFzeVxuICAgICAgICB0aGlzLmludk1hc3MgPSAxIC8gdGhpcy5tYXNzO1xuXG4gICAgICAgIHZlYzIuc2V0KFxuICAgICAgICAgICAgdGhpcy5tYXNzTXVsdGlwbGllcixcbiAgICAgICAgICAgIHRoaXMuZml4ZWRYID8gMCA6IDEsXG4gICAgICAgICAgICB0aGlzLmZpeGVkWSA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgfVxufTtcblxudmFyIEJvZHlfYXBwbHlGb3JjZV9yID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBSaWdpZEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuIElmIHJlbGF0aXZlUG9pbnQgaXMgemVybywgdGhlIGZvcmNlIHdpbGwgYmUgYXBwbGllZCBkaXJlY3RseSBvbiB0aGUgY2VudGVyIG9mIG1hc3MsIGFuZCB0aGUgdG9ycXVlIHByb2R1Y2VkIHdpbGwgYmUgemVyby5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtIHtBcnJheX0gZm9yY2UgVGhlIGZvcmNlIHRvIGFkZC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZWxhdGl2ZVBvaW50XSBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlLCByZWxhdGl2ZVBvaW50KXtcblxuICAgIC8vIEFkZCBsaW5lYXIgZm9yY2VcbiAgICB2ZWMyLmFkZCh0aGlzLmZvcmNlLCB0aGlzLmZvcmNlLCBmb3JjZSk7XG5cbiAgICBpZihyZWxhdGl2ZVBvaW50KXtcblxuICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICAgICAgdmFyIHJvdEZvcmNlID0gdmVjMi5jcm9zc0xlbmd0aChyZWxhdGl2ZVBvaW50LGZvcmNlKTtcblxuICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxuICAgICAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgYm9keS1sb2NhbCBwb2ludC5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZUxvY2FsXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxGb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gbG9jYWwgYm9keSBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbbG9jYWxQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUZvcmNlX2ZvcmNlV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIEJvZHlfYXBwbHlGb3JjZV9wb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbCA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlTG9jYWwgPSBmdW5jdGlvbihsb2NhbEZvcmNlLCBsb2NhbFBvaW50KXtcbiAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbDtcbiAgICB2YXIgd29ybGRGb3JjZSA9IEJvZHlfYXBwbHlGb3JjZV9mb3JjZVdvcmxkO1xuICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQ7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRGb3JjZSwgbG9jYWxGb3JjZSk7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRQb2ludCwgbG9jYWxQb2ludCk7XG4gICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHdvcmxkUG9pbnQpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cbiAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXG4gKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2UgPSBmdW5jdGlvbihpbXB1bHNlVmVjdG9yLCByZWxhdGl2ZVBvaW50KXtcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcbiAgICB2ZWMyLnNjYWxlKHZlbG8sIGltcHVsc2VWZWN0b3IsIHRoaXMuaW52TWFzcyk7XG4gICAgdmVjMi5tdWx0aXBseSh2ZWxvLCB0aGlzLm1hc3NNdWx0aXBsaWVyLCB2ZWxvKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxuICAgIHZlYzIuYWRkKHRoaXMudmVsb2NpdHksIHZlbG8sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgaWYocmVsYXRpdmVQb2ludCl7XG4gICAgICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBpbXB1bHNlIHZlbG9jaXR5XG4gICAgICAgIHZhciByb3RWZWxvID0gdmVjMi5jcm9zc0xlbmd0aChyZWxhdGl2ZVBvaW50LCBpbXB1bHNlVmVjdG9yKTtcbiAgICAgICAgcm90VmVsbyAqPSB0aGlzLmludkluZXJ0aWE7XG5cbiAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSByb3RWZWxvO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZUxvY2FsXG4gKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhjZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxuICovXG52YXIgQm9keV9hcHBseUltcHVsc2VfaW1wdWxzZVdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsID0gdmVjMi5jcmVhdGUoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5SW1wdWxzZUxvY2FsID0gZnVuY3Rpb24obG9jYWxJbXB1bHNlLCBsb2NhbFBvaW50KXtcbiAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsO1xuICAgIHZhciB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5SW1wdWxzZV9pbXB1bHNlV29ybGQ7XG4gICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkSW1wdWxzZSwgbG9jYWxJbXB1bHNlKTtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZFBvaW50LCBsb2NhbFBvaW50KTtcbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHdvcmxkUG9pbnQpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCAgIFRoZSBpbnB1dCB3b3JsZCBwb2ludFxuICovXG5Cb2R5LnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQpe1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludCAgIFRoZSBpbnB1dCBsb2NhbCBwb2ludFxuICovXG5Cb2R5LnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQpe1xuICAgIHZlYzIudG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRWZWN0b3IgIFRoZSBpbnB1dCB3b3JsZCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFZlY3Rvcil7XG4gICAgdmVjMi52ZWN0b3JUb0xvY2FsRnJhbWUob3V0LCB3b3JsZFZlY3RvciwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3IgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFZlY3Rvcil7XG4gICAgdmVjMi52ZWN0b3JUb0dsb2JhbEZyYW1lKG91dCwgbG9jYWxWZWN0b3IsIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxuICogQG1ldGhvZCBmcm9tUG9seWdvblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXG4gKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBbb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHM9ZmFsc2VdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgZmFsc2UgdG8ga2VlcCBhbGwgcG9pbnRzLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5mcm9tUG9seWdvbiA9IGZ1bmN0aW9uKHBhdGgsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT10aGlzLnNoYXBlcy5sZW5ndGg7IGk+PTA7IC0taSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU2hhcGUodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IGRlY29tcC5Qb2x5Z29uKCk7XG4gICAgcC52ZXJ0aWNlcyA9IHBhdGg7XG5cbiAgICAvLyBNYWtlIGl0IGNvdW50ZXItY2xvY2t3aXNlXG4gICAgcC5tYWtlQ0NXKCk7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgcC5yZW1vdmVDb2xsaW5lYXJQb2ludHMob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgcGF0aCBpdHNlbGZcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgaWYoIXAuaXNTaW1wbGUoKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoaXMgcGF0aCBmb3IgbGF0ZXJcbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gcC52ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBbMCwwXTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdGhpcy5jb25jYXZlUGF0aFtpXSk7XG4gICAgICAgIHRoaXMuY29uY2F2ZVBhdGhbaV0gPSB2O1xuICAgIH1cblxuICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XG4gICAgdmFyIGNvbnZleGVzO1xuICAgIGlmKG9wdGlvbnMub3B0aW1hbERlY29tcCl7XG4gICAgICAgIGNvbnZleGVzID0gcC5kZWNvbXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXhlcyA9IHAucXVpY2tEZWNvbXAoKTtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLy8gQWRkIGNvbnZleGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXhcbiAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4KHsgdmVydGljZXM6IGNvbnZleGVzW2ldLnZlcnRpY2VzIH0pO1xuXG4gICAgICAgIC8vIE1vdmUgYWxsIHZlcnRpY2VzIHNvIGl0cyBjZW50ZXIgb2YgbWFzcyBpcyBpbiB0aGUgbG9jYWwgY2VudGVyIG9mIHRoZSBjb252ZXhcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1jLnZlcnRpY2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gYy52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIHZlYzIuc3ViKHYsdixjLmNlbnRlck9mTWFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnNjYWxlKGNtLGMuY2VudGVyT2ZNYXNzLDEpO1xuICAgICAgICBjLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICBjLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgICAgICBjLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzaGFwZVxuICAgICAgICB0aGlzLmFkZFNoYXBlKGMsY20pO1xuICAgIH1cblxuICAgIHRoaXMuYWRqdXN0Q2VudGVyT2ZNYXNzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIE1vdmVzIHRoZSBzaGFwZSBvZmZzZXRzIHNvIHRoZWlyIGNlbnRlciBvZiBtYXNzIGJlY29tZXMgdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXG4gKiBAbWV0aG9kIGFkanVzdENlbnRlck9mTWFzc1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGp1c3RDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciBvZmZzZXRfdGltZXNfYXJlYSA9IGFkanVzdENlbnRlck9mTWFzc190bXAyLFxuICAgICAgICBzdW0gPSAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzLFxuICAgICAgICBjbSA9ICAgICAgICAgICAgICAgIGFkanVzdENlbnRlck9mTWFzc190bXA0LFxuICAgICAgICB0b3RhbEFyZWEgPSAgICAgICAgIDA7XG4gICAgdmVjMi5zZXQoc3VtLDAsMCk7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgdmVjMi5zY2FsZShvZmZzZXRfdGltZXNfYXJlYSwgcy5wb3NpdGlvbiwgcy5hcmVhKTtcbiAgICAgICAgdmVjMi5hZGQoc3VtLCBzdW0sIG9mZnNldF90aW1lc19hcmVhKTtcbiAgICAgICAgdG90YWxBcmVhICs9IHMuYXJlYTtcbiAgICB9XG5cbiAgICB2ZWMyLnNjYWxlKGNtLHN1bSwxL3RvdGFsQXJlYSk7XG5cbiAgICAvLyBOb3cgbW92ZSBhbGwgc2hhcGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIHZlYzIuc3ViKHMucG9zaXRpb24sIHMucG9zaXRpb24sIGNtKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib2R5IHBvc2l0aW9uIHRvb1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sdGhpcy5wb3NpdGlvbixjbSk7XG5cbiAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXG4gICAgZm9yKHZhciBpPTA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5jb25jYXZlUGF0aFtpXSwgdGhpcy5jb25jYXZlUGF0aFtpXSwgY20pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXG4gKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMC4wLDAuMCk7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwLjA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2bGFtYmRhID0gYi52bGFtYmRhO1xuICAgIHZlYzIuc2V0KHZsYW1iZGEsMCwwKTtcbiAgICBiLndsYW1iZGEgPSAwO1xufTtcblxuQm9keS5wcm90b3R5cGUuYWRkQ29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHYgPSBiLnZlbG9jaXR5O1xuICAgIHZlYzIuYWRkKCB2LCB2LCBiLnZsYW1iZGEpO1xuICAgIGIuYW5ndWxhclZlbG9jaXR5ICs9IGIud2xhbWJkYTtcbn07XG5cbi8qKlxuICogQXBwbHkgZGFtcGluZywgc2VlIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzRcIj50aGlzPC9hPiBmb3IgZGV0YWlscy5cbiAqIEBtZXRob2QgYXBwbHlEYW1waW5nXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0IEN1cnJlbnQgdGltZSBzdGVwXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5RGFtcGluZyA9IGZ1bmN0aW9uKGR0KXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdmVjMi5zY2FsZSh2LCB2LCBNYXRoLnBvdygxLjAgLSB0aGlzLmRhbXBpbmcsZHQpKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMS4wIC0gdGhpcy5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXG4gKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXG4gKiBAbWV0aG9kIHdha2VVcFxuICovXG5Cb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzID0gdGhpcy5zbGVlcFN0YXRlO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgaWYocyAhPT0gQm9keS5BV0FLRSl7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5Lndha2VVcEV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZvcmNlIGJvZHkgc2xlZXBcbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMDtcbiAgICB2ZWMyLnNldCh0aGlzLnZlbG9jaXR5LDAsMCk7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLDApO1xuICAgIHRoaXMuZW1pdChCb2R5LnNsZWVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXG4gKiBAcGFyYW0ge251bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSwgZG9udFNsZWVwLCBkdCl7XG4gICAgaWYoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIHZhciBzbGVlcFN0YXRlID0gdGhpcy5zbGVlcFN0YXRlLFxuICAgICAgICBzcGVlZFNxdWFyZWQgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgKyBNYXRoLnBvdyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwyKSxcbiAgICAgICAgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcblxuICAgIC8vIEFkZCB0byBpZGxlIHRpbWVcbiAgICBpZihzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlkbGVUaW1lICs9IGR0O1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcbiAgICB9XG4gICAgaWYodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICBpZighZG9udFNsZWVwKXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvZHkgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBib2R5LiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgb25seSB3b3JrcyBpZiB0aGUgYm9keSB3YXMgYWRkZWQgdG8gYSBXb3JsZCBhbmQgaWYgYXQgbGVhc3Qgb25lIHN0ZXAgd2FzIHRha2VuLlxuICogQG1ldGhvZCBvdmVybGFwc1xuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQm9keS5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihib2R5KXtcbiAgICByZXR1cm4gdGhpcy53b3JsZC5vdmVybGFwS2VlcGVyLmJvZGllc0FyZU92ZXJsYXBwaW5nKHRoaXMsIGJvZHkpO1xufTtcblxudmFyIGludGVncmF0ZV9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVncmF0ZV92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lIGdpdmVuIGl0cyBjdXJyZW50IHZlbG9jaXR5LlxuICogQG1ldGhvZCBpbnRlZ3JhdGVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24oZHQpe1xuICAgIHZhciBtaW52ID0gdGhpcy5pbnZNYXNzLFxuICAgICAgICBmID0gdGhpcy5mb3JjZSxcbiAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdmVsbyA9IHRoaXMudmVsb2NpdHk7XG5cbiAgICAvLyBTYXZlIG9sZCBwb3NpdGlvblxuICAgIHZlYzIuY29weSh0aGlzLnByZXZpb3VzUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IHRoaXMuYW5nbGU7XG5cbiAgICAvLyBWZWxvY2l0eSB1cGRhdGVcbiAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5hbmd1bGFyRm9yY2UgKiB0aGlzLmludkluZXJ0aWEgKiBkdDtcbiAgICB9XG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfZmhNaW52LCBmLCBkdCAqIG1pbnYpO1xuICAgIHZlYzIubXVsdGlwbHkoaW50ZWdyYXRlX2ZoTWludiwgdGhpcy5tYXNzTXVsdGlwbGllciwgaW50ZWdyYXRlX2ZoTWludik7XG4gICAgdmVjMi5hZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XG5cbiAgICAvLyBDQ0RcbiAgICBpZighdGhpcy5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdChkdCkpe1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgcG9zaXRpb24gdXBkYXRlXG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgdmVsbywgZHQpO1xuICAgICAgICB2ZWMyLmFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxudmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG52YXIgcmF5ID0gbmV3IFJheSh7XG4gICAgbW9kZTogUmF5LkFMTFxufSk7XG52YXIgZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHN0YXJ0VG9FbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbWVtYmVyUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QgPSBmdW5jdGlvbihkdCl7XG5cbiAgICBpZih0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgPCBNYXRoLnBvdyh0aGlzLmNjZFNwZWVkVGhyZXNob2xkLCAyKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2ZWMyLm5vcm1hbGl6ZShkaXJlY3Rpb24sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgdmVjMi5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcbiAgICB2ZWMyLmFkZChlbmQsIGVuZCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgIHZhciBsZW4gPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKTtcblxuICAgIHZhciB0aW1lT2ZJbXBhY3QgPSAxO1xuXG4gICAgdmFyIGhpdDtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmVzdWx0LnJlc2V0KCk7XG4gICAgcmF5LmNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZihyZXN1bHQuYm9keSA9PT0gdGhhdCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGl0ID0gcmVzdWx0LmJvZHk7XG4gICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChlbmQsIHJheSk7XG4gICAgICAgIHZlYzIuc3ViKHN0YXJ0VG9FbmQsIGVuZCwgdGhhdC5wb3NpdGlvbik7XG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzIubGVuZ3RoKHN0YXJ0VG9FbmQpIC8gbGVuO1xuICAgICAgICByZXN1bHQuc3RvcCgpO1xuICAgIH07XG4gICAgdmVjMi5jb3B5KHJheS5mcm9tLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkocmF5LnRvLCBlbmQpO1xuICAgIHJheS51cGRhdGUoKTtcbiAgICB0aGlzLndvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xuXG4gICAgaWYoIWhpdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVtZW1iZXJBbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgdmVjMi5jb3B5KHJlbWVtYmVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBpdGVyID0gMDtcbiAgICB2YXIgdG1pbiA9IDA7XG4gICAgdmFyIHRtaWQgPSAwO1xuICAgIHZhciB0bWF4ID0gdGltZU9mSW1wYWN0O1xuICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyKys7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludFxuICAgICAgICB0bWlkID0gKHRtYXggLSB0bWluKSAvIDI7XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgYm9keSB0byB0aGF0IHBvaW50XG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdGltZU9mSW1wYWN0KTtcbiAgICAgICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlICsgc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcblxuICAgICAgICAvLyBjaGVjayBvdmVybGFwXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuYWFiYi5vdmVybGFwcyhoaXQuYWFiYikgJiYgdGhpcy53b3JsZC5uYXJyb3dwaGFzZS5ib2RpZXNPdmVybGFwKHRoaXMsIGhpdCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWluIHRvIHNlYXJjaCB1cHBlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1pbiA9IHRtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWF4IHRvIHNlYXJjaCBsb3dlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1heCA9IHRtaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lT2ZJbXBhY3QgPSB0bWlkO1xuXG4gICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24pO1xuICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlO1xuXG4gICAgLy8gbW92ZSB0byBUT0lcbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBHZXQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0IEEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSByZWxhdGl2ZVBvaW50IEEgd29ybGQgb3JpZW50ZWQgdmVjdG9yLCBpbmRpY2F0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgdG8gZ2V0IHRoZSB2ZWxvY2l0eSBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBdFBvaW50ID0gZnVuY3Rpb24ocmVzdWx0LCByZWxhdGl2ZVBvaW50KXtcbiAgICB2ZWMyLmNyb3NzVloocmVzdWx0LCByZWxhdGl2ZVBvaW50LCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgdmVjMi5zdWJ0cmFjdChyZXN1bHQsIHRoaXMudmVsb2NpdHksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVweVxuICovXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXB5XCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVwXG4gKi9cbkJvZHkuc2xlZXBFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVwXCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHdha2V1cFxuICovXG5Cb2R5Lndha2VVcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwid2FrZXVwXCJcbn07XG5cbi8qKlxuICogRHluYW1pYyBib2R5LlxuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogU3RhdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgU1RBVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNUQVRJQyA9IDI7XG5cbi8qKlxuICogS2luZW1hdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHByb3BlcnR5IEFXQUtFXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkFXQUtFID0gMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBZXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQWSA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQSU5HXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQSU5HID0gMjtcblxuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4uL2NvbGxpc2lvbi9SYXlcIjoxMSxcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTIsXCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjYsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3NoYXBlcy9Db252ZXhcIjo0MCxcInBvbHktZGVjb21wXCI6NX1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gX2RlcmVxXygnLi9TcHJpbmcnKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXG4gKlxuICogVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMaW5lYXJTcHJpbmdcbiAqIEBleHRlbmRzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTcHJpbmcuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlCIGluIGxvY2FsIGJvZHlCIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpeyB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQil7IHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsgfVxuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMi5kaXN0YW5jZSh3b3JsZEFuY2hvckEsIHdvcmxkQW5jaG9yQik7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IHdvcmxkRGlzdGFuY2U7XG59XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlID0gbmV3IFNwcmluZygpO1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQSl7XG4gICAgdGhpcy5ib2R5QS50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHdvcmxkQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JCXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24od29ybGRBbmNob3JCKXtcbiAgICB0aGlzLmJvZHlCLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQiwgd29ybGRBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5QS50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUIudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckIpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2Vfcmo7XG5cbiAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcblxuICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXG4gICAgdmVjMi5zdWIocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIuc3ViKHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xuICAgIHZlYzIuc3ViKHIsIHdvcmxkQW5jaG9yQiwgd29ybGRBbmNob3JBKTtcbiAgICB2YXIgcmxlbiA9IHZlYzIubGVuKHIpO1xuICAgIHZlYzIubm9ybWFsaXplKHJfdW5pdCxyKTtcblxuICAgIC8vY29uc29sZS5sb2cocmxlbilcbiAgICAvL2NvbnNvbGUubG9nKFwiQVwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQSksXCJCXCIsdmVjMi5zdHIod29ybGRBbmNob3JCKSlcblxuICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcbiAgICB2ZWMyLnN1Yih1LCBib2R5Qi52ZWxvY2l0eSwgYm9keUEudmVsb2NpdHkpO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xuICAgIHZlYzIuYWRkKHUsIHUsIHRtcCk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUEuYW5ndWxhclZlbG9jaXR5LCByaSk7XG4gICAgdmVjMi5zdWIodSwgdSwgdG1wKTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICB2ZWMyLnNjYWxlKGYsIHJfdW5pdCwgLWsqKHJsZW4tbCkgLSBkKnZlYzIuZG90KHUscl91bml0KSk7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIHZlYzIuc3ViKCBib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xuICAgIHZlYzIuYWRkKCBib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xuXG4gICAgLy8gQW5ndWxhciBmb3JjZVxuICAgIHZhciByaV94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLCBmKTtcbiAgICB2YXIgcmpfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgZik7XG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NwcmluZ1wiOjM0fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSBfZGVyZXFfKCcuL1NwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXG4gKlxuICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RBbmdsZSA9IHR5cGVvZihvcHRpb25zLnJlc3RBbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RBbmdsZSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG59XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RBbmdsZSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLFxuICAgICAgICB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHRvcnF1ZSA9IC0gayAqICh4IC0gbCkgLSBkICogdSAqIDA7XG5cbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TcHJpbmdcIjozNH1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMgYW5kIGRvZXMgdGhlcmVmb3JlIG5vdCBwdXQgbG9hZCBvbiB0aGUgY29uc3RyYWludCBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3M7XG5cbiAgICAvKipcbiAgICAgKiBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5TcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9wRG93blZlaGljbGU7XG5cbi8qKlxuICogQGNsYXNzIFRvcERvd25WZWhpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gY2hhc3Npc0JvZHkgQSBkeW5hbWljIGJvZHksIGFscmVhZHkgYWRkZWQgdG8gdGhlIHdvcmxkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIGR5bmFtaWMgYm9keSBmb3IgdGhlIGNoYXNzaXNcbiAqICAgICB2YXIgY2hhc3Npc0JvZHkgPSBuZXcgQm9keSh7XG4gKiAgICAgICAgIG1hc3M6IDFcbiAqICAgICB9KTtcbiAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDAuNSwgaGVpZ2h0OiAxIH0pO1xuICogICAgIGNoYXNzaXNCb2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGNoYXNzaXNCb2R5KTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSB2ZWhpY2xlXG4gKiAgICAgdmFyIHZlaGljbGUgPSBuZXcgVG9wRG93blZlaGljbGUoY2hhc3Npc0JvZHkpO1xuICpcbiAqICAgICAvLyBBZGQgb25lIGZyb250IHdoZWVsIGFuZCBvbmUgYmFjayB3aGVlbCAtIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgZm91ciA6KVxuICogICAgIHZhciBmcm9udFdoZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XG4gKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAwLjVdIC8vIGZyb250XG4gKiAgICAgfSk7XG4gKiAgICAgZnJvbnRXaGVlbC5zZXRTaWRlRnJpY3Rpb24oNCk7XG4gKlxuICogICAgIC8vIEJhY2sgd2hlZWxcbiAqICAgICB2YXIgYmFja1doZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XG4gKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAtMC41XSAvLyBiYWNrXG4gKiAgICAgfSk7XG4gKiAgICAgYmFja1doZWVsLnNldFNpZGVGcmljdGlvbigzKTsgLy8gTGVzcyBzaWRlIGZyaWN0aW9uIG9uIGJhY2sgd2hlZWwgbWFrZXMgaXQgZWFzaWVyIHRvIGRyaWZ0XG4gKiAgICAgdmVoaWNsZS5hZGRUb1dvcmxkKHdvcmxkKTtcbiAqXG4gKiAgICAgLy8gU3RlZXIgdmFsdWUgemVybyBtZWFucyBzdHJhaWdodCBmb3J3YXJkLiBQb3NpdGl2ZSBpcyBsZWZ0IGFuZCBuZWdhdGl2ZSByaWdodC5cbiAqICAgICBmcm9udFdoZWVsLnN0ZWVyVmFsdWUgPSBNYXRoLlBJIC8gMTY7XG4gKlxuICogICAgIC8vIEVuZ2luZSBmb3JjZSBmb3J3YXJkXG4gKiAgICAgYmFja1doZWVsLmVuZ2luZUZvcmNlID0gMTA7XG4gKiAgICAgYmFja1doZWVsLnNldEJyYWtlRm9yY2UoMCk7XG4gKi9cbmZ1bmN0aW9uIFRvcERvd25WZWhpY2xlKGNoYXNzaXNCb2R5LCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gY2hhc3Npc0JvZHlcbiAgICAgKi9cbiAgICB0aGlzLmNoYXNzaXNCb2R5ID0gY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3aGVlbHNcbiAgICAgKi9cbiAgICB0aGlzLndoZWVscyA9IFtdO1xuXG4gICAgLy8gQSBkdW1teSBib2R5IHRvIGNvbnN0cmFpbiB0aGUgY2hhc3NpcyB0b1xuICAgIHRoaXMuZ3JvdW5kQm9keSA9IG5ldyBCb2R5KHsgbWFzczogMCB9KTtcblxuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhhdC51cGRhdGUoKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHdvcmxkLmFkZEJvZHkodGhpcy5ncm91bmRCb2R5KTtcbiAgICB3b3JsZC5vbigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2hlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xuICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KHdoZWVsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ub3BEb3duVmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xuICAgIHdvcmxkLnJlbW92ZUJvZHkodGhpcy5ncm91bmRCb2R5KTtcbiAgICB3b3JsZC5vZmYoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd2hlZWwgPSB0aGlzLndoZWVsc1tpXTtcbiAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludCh3aGVlbCk7XG4gICAgfVxuICAgIHRoaXMud29ybGQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW3doZWVsT3B0aW9uc11cbiAqIEByZXR1cm4ge1doZWVsQ29uc3RyYWludH1cbiAqL1xuVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFdoZWVsID0gZnVuY3Rpb24od2hlZWxPcHRpb25zKXtcbiAgICB2YXIgd2hlZWwgPSBuZXcgV2hlZWxDb25zdHJhaW50KHRoaXMsd2hlZWxPcHRpb25zKTtcbiAgICB0aGlzLndoZWVscy5wdXNoKHdoZWVsKTtcbiAgICByZXR1cm4gd2hlZWw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblRvcERvd25WZWhpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aGVlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53aGVlbHNbaV0udXBkYXRlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAY2xhc3MgV2hlZWxDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtDb25zdHJhaW50fVxuICogQHBhcmFtIHtWZWhpY2xlfSB2ZWhpY2xlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3JdVGhlIGxvY2FsIHdoZWVsIGZvcndhcmQgdmVjdG9yIGluIGxvY2FsIGJvZHkgc3BhY2UuIERlZmF1bHQgaXMgemVyby5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsUG9zaXRpb25dIFRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgd2hlZW4gaW4gdGhlIGNoYXNzaXMgYm9keS4gRGVmYXVsdCBpcyB6ZXJvIC0gdGhlIGNlbnRlciBvZiB0aGUgYm9keS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnNpZGVGcmljdGlvbj01XSBUaGUgbWF4IGZyaWN0aW9uIGZvcmNlIGluIHRoZSBzaWRld2F5cyBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIFdoZWVsQ29uc3RyYWludCh2ZWhpY2xlLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMudmVoaWNsZSA9IHZlaGljbGU7XG5cbiAgICB0aGlzLmZvcndhcmRFcXVhdGlvbiA9IG5ldyBGcmljdGlvbkVxdWF0aW9uKHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XG5cbiAgICB0aGlzLnNpZGVFcXVhdGlvbiA9IG5ldyBGcmljdGlvbkVxdWF0aW9uKHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlZXJWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMuc3RlZXJWYWx1ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZW5naW5lRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLmVuZ2luZUZvcmNlID0gMDtcblxuICAgIHRoaXMuc2V0U2lkZUZyaWN0aW9uKG9wdGlvbnMuc2lkZUZyaWN0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNpZGVGcmljdGlvbiA6IDUpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxGb3J3YXJkVmVjdG9yXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgMSk7XG4gICAgaWYob3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3Ipe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIG9wdGlvbnMubG9jYWxGb3J3YXJkVmVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbFBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5sb2NhbFBvc2l0aW9uID0gdmVjMi5mcm9tVmFsdWVzKDAsIDApO1xuICAgIGlmKG9wdGlvbnMubG9jYWxQb3NpdGlvbil7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvY2FsUG9zaXRpb24sIG9wdGlvbnMubG9jYWxQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgQ29uc3RyYWludC5hcHBseSh0aGlzLCB2ZWhpY2xlLmNoYXNzaXNCb2R5LCB2ZWhpY2xlLmdyb3VuZEJvZHkpO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5mb3J3YXJkRXF1YXRpb24sXG4gICAgICAgIHRoaXMuc2lkZUVxdWF0aW9uXG4gICAgKTtcblxuICAgIHRoaXMuc2V0QnJha2VGb3JjZSgwKTtcbn1cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0Rm9yd2FyZEZyaWN0aW9uXG4gKi9cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUuc2V0QnJha2VGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICB0aGlzLmZvcndhcmRFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFNpZGVGcmljdGlvblxuICovXG5XaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnNldFNpZGVGcmljdGlvbiA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICB0aGlzLnNpZGVFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xufTtcblxudmFyIHdvcmxkVmVsb2NpdHkgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbGF0aXZlUG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0U3BlZWRcbiAqL1xuV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5nZXRTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxhdGl2ZVBvaW50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRQb2ludCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcbiAgICByZXR1cm4gdmVjMi5kb3Qod29ybGRWZWxvY2l0eSwgcmVsYXRpdmVQb2ludCk7XG59O1xuXG52YXIgdG1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5XaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBEaXJlY3Rpb25hbFxuICAgIHRoaXMudmVoaWNsZS5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5mb3J3YXJkRXF1YXRpb24udCwgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IpO1xuICAgIHZlYzIucm90YXRlKHRoaXMuc2lkZUVxdWF0aW9uLnQsIHRoaXMubG9jYWxGb3J3YXJkVmVjdG9yLCBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnNpZGVFcXVhdGlvbi50LCB0aGlzLnNpZGVFcXVhdGlvbi50KTtcblxuICAgIHZlYzIucm90YXRlKHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQsIHRoaXMuc3RlZXJWYWx1ZSk7XG4gICAgdmVjMi5yb3RhdGUodGhpcy5zaWRlRXF1YXRpb24udCwgdGhpcy5zaWRlRXF1YXRpb24udCwgdGhpcy5zdGVlclZhbHVlKTtcblxuICAgIC8vIEF0dGFjaG1lbnQgcG9pbnRcbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkudG9Xb3JsZEZyYW1lKHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHRoaXMubG9jYWxQb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KHRoaXMuc2lkZUVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEIpO1xuXG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB0aGlzLmxvY2FsUG9zaXRpb24pO1xuICAgIHZlYzIuY29weSh0aGlzLnNpZGVFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBKTtcblxuICAgIC8vIEFkZCBlbmdpbmUgZm9yY2VcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0bXBWZWMsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLnQpO1xuICAgIHZlYzIuc2NhbGUodG1wVmVjLCB0bXBWZWMsIHRoaXMuZW5naW5lRm9yY2UpO1xuXG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmFwcGx5Rm9yY2UodG1wVmVjLCB0aGlzLmZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRBKTtcbn07XG59LHtcIi4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNCxcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1N31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEV4cG9ydCBwMiBjbGFzc2VzXG52YXIgcDIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RFcXVhdGlvblBvb2wgOiAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9Db250YWN0RXF1YXRpb25Qb29sJyksXG4gICAgQ29udGFjdE1hdGVyaWFsIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpLFxuICAgIENvbnZleCA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ29udmV4JyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudEVtaXR0ZXIgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXZlbnRzL0V2ZW50RW1pdHRlcicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb24gOiAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb25Qb29sIDogICAgICAgICAgX2RlcmVxXygnLi91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbCcpLFxuICAgIEdlYXJDb25zdHJhaW50IDogICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludCcpLFxuICAgIEdTU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvR1NTb2x2ZXInKSxcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgTGluZSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9MaW5lJyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0ZXJpYWwgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL01hdGVyaWFsJyksXG4gICAgTmFycm93cGhhc2UgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZScpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIFBsYW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGxhbmUnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9Cb3gnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgVG9wRG93blZlaGljbGUgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvVG9wRG93blZlaGljbGUnKSxcbiAgICBMaW5lYXJTcHJpbmcgOiAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nJyksXG4gICAgVXRpbHMgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3V0aWxzL1V0aWxzJyksXG4gICAgV29ybGQgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3dvcmxkL1dvcmxkJyksXG4gICAgdmVjMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvdmVjMicpLFxuICAgIHZlcnNpb24gOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwMiwgJ1JlY3RhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBSZWN0YW5nbGUgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBCb3guJyk7XG4gICAgICAgIHJldHVybiB0aGlzLkJveDtcbiAgICB9XG59KTtcbn0se1wiLi4vcGFja2FnZS5qc29uXCI6NixcIi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo5LFwiLi9jb2xsaXNpb24vTmFycm93cGhhc2VcIjoxMCxcIi4vY29sbGlzaW9uL1JheVwiOjExLFwiLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEyLFwiLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjEzLFwiLi9jb25zdHJhaW50cy9Db25zdHJhaW50XCI6MTQsXCIuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludFwiOjE1LFwiLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE2LFwiLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOjE3LFwiLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50XCI6MTgsXCIuL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjE5LFwiLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMCxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIxLFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMixcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMyxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXCI6MjUsXCIuL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNixcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjcsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjgsXCIuL21hdGgvdmVjMlwiOjMwLFwiLi9vYmplY3RzL0JvZHlcIjozMSxcIi4vb2JqZWN0cy9MaW5lYXJTcHJpbmdcIjozMixcIi4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nXCI6MzMsXCIuL29iamVjdHMvU3ByaW5nXCI6MzQsXCIuL29iamVjdHMvVG9wRG93blZlaGljbGVcIjozNSxcIi4vc2hhcGVzL0JveFwiOjM3LFwiLi9zaGFwZXMvQ2Fwc3VsZVwiOjM4LFwiLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuL3NoYXBlcy9Db252ZXhcIjo0MCxcIi4vc2hhcGVzL0hlaWdodGZpZWxkXCI6NDEsXCIuL3NoYXBlcy9MaW5lXCI6NDIsXCIuL3NoYXBlcy9QYXJ0aWNsZVwiOjQzLFwiLi9zaGFwZXMvUGxhbmVcIjo0NCxcIi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2xcIjo0OCxcIi4vdXRpbHMvRnJpY3Rpb25FcXVhdGlvblBvb2xcIjo0OSxcIi4vdXRpbHMvUG9vbFwiOjU1LFwiLi91dGlscy9VdGlsc1wiOjU3LFwiLi93b3JsZC9Xb3JsZFwiOjYxfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi9Db252ZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3g7XG5cbi8qKlxuICogQm94IHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIEJveFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTFdIFRvdGFsIHdpZHRoIG9mIHRoZSBib3hcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MV0gVG90YWwgaGVpZ2h0IG9mIHRoZSBib3hcbiAqIEBleHRlbmRzIENvbnZleFxuICovXG5mdW5jdGlvbiBCb3gob3B0aW9ucyl7XG4gICAgaWYodHlwZW9mKGFyZ3VtZW50c1swXSkgPT09ICdudW1iZXInICYmIHR5cGVvZihhcmd1bWVudHNbMV0pID09PSAnbnVtYmVyJyl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGVpZ2h0OiBhcmd1bWVudHNbMV1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgUmVjdGFuZ2xlIGhhcyBiZWVuIHJlbmFtZWQgdG8gQm94IGFuZCBpdHMgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgQm94KHsgd2lkdGg6IDEsIGhlaWdodDogMSwgLi4uIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgd2lkdGggb2YgdGhlIGJveFxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIGhlaWdodCBvZiB0aGUgYm94XG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMTtcblxuICAgIHZhciB2ZXJ0cyA9IFtcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAtaGVpZ2h0LzIpLFxuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoIHdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgIGhlaWdodC8yKSxcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAgaGVpZ2h0LzIpXG4gICAgXTtcbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKDEsIDApLFxuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoMCwgMSlcbiAgICBdO1xuXG4gICAgb3B0aW9ucy52ZXJ0aWNlcyA9IHZlcnRzO1xuICAgIG9wdGlvbnMuYXhlcyA9IGF4ZXM7XG4gICAgb3B0aW9ucy50eXBlID0gU2hhcGUuQk9YO1xuICAgIENvbnZleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuQm94LnByb3RvdHlwZSA9IG5ldyBDb252ZXgoKTtcbkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3g7XG5cbi8qKlxuICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQm94LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHcqdyArIGgqaCkgLyAyO1xufTtcblxudmFyIGNvcm5lcjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5Cb3gucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbn07XG5cblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4vQ29udmV4XCI6NDAsXCIuL1NoYXBlXCI6NDV9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDYXBzdWxlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENhcHN1bGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFJhZGl1cyBvZiB0aGUgY2Fwc3VsZVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgY2Fwc3VsZVNoYXBlID0gbmV3IENhcHN1bGUoe1xuICogICAgICAgICBsZW5ndGg6IDEsXG4gKiAgICAgICAgIHJhZGl1czogMlxuICogICAgIH0pO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY2Fwc3VsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2Fwc3VsZShvcHRpb25zKXtcbiAgICBpZih0eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxlbmd0aDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgcmFkaXVzOiBhcmd1bWVudHNbMV1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgQ2Fwc3VsZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBDYXBzdWxlKHsgcmFkaXVzOiAxLCBsZW5ndGg6IDEgfSknKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAxO1xuXG4gICAgb3B0aW9ucy50eXBlID0gU2hhcGUuQ0FQU1VMRTtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuQ2Fwc3VsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNhcHN1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDYXBzdWxlLlxuICogQG1ldGhvZCBjb25wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0b2RvXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIHJlY3RhbmdsZVxuICAgIHZhciByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIHcgPSB0aGlzLmxlbmd0aCArIHIsIC8vIDIqciBpcyB0b28gbXVjaCwgMCBpcyB0b28gbGl0dGxlXG4gICAgICAgIGggPSByKjI7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aC8yO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAqIDIgKiB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciByID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXG4gICAgLy8gQ29tcHV0ZSBjZW50ZXIgcG9zaXRpb24gb2Ygb25lIG9mIHRoZSB0aGUgY2lyY2xlcywgd29ybGQgb3JpZW50ZWQsIGJ1dCB3aXRoIGxvY2FsIG9mZnNldFxuICAgIHZlYzIuc2V0KHIsdGhpcy5sZW5ndGggLyAyLDApO1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUocixyLGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYm91bmRzXG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICBNYXRoLm1heChyWzBdK3JhZGl1cywgLXJbMF0rcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJbMV0rcmFkaXVzLCAtclsxXStyYWRpdXMpKTtcbiAgICB2ZWMyLnNldChvdXQubG93ZXJCb3VuZCwgIE1hdGgubWluKHJbMF0tcmFkaXVzLCAtclswXS1yYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oclsxXS1yYWRpdXMsIC1yWzFdLXJhZGl1cykpO1xuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxudmFyIGludGVyc2VjdENhcHN1bGVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfbDAgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfbDEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENhcHN1bGVfdW5pdF95ID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuXG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RDYXBzdWxlX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENhcHN1bGVfbm9ybWFsO1xuICAgIHZhciBsMCA9IGludGVyc2VjdENhcHN1bGVfbDA7XG4gICAgdmFyIGwxID0gaW50ZXJzZWN0Q2Fwc3VsZV9sMTtcblxuICAgIC8vIFRoZSBzaWRlc1xuICAgIHZhciBoYWxmTGVuID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIGZvcih2YXIgaT0wOyBpPDI7IGkrKyl7XG5cbiAgICAgICAgLy8gZ2V0IHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgdmFyIHkgPSB0aGlzLnJhZGl1cyAqIChpKjItMSk7XG4gICAgICAgIHZlYzIuc2V0KGwwLCAtaGFsZkxlbiwgeSk7XG4gICAgICAgIHZlYzIuc2V0KGwxLCBoYWxmTGVuLCB5KTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwxLCBsMSwgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKGZyb20sIHRvLCBsMCwgbDEpO1xuICAgICAgICBpZihkZWx0YSA+PSAwKXtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3ksIGFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUobm9ybWFsLCBub3JtYWwsIChpKjItMSkpO1xuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENpcmNsZXNcbiAgICB2YXIgZGlhZ29uYWxMZW5ndGhTcXVhcmVkID0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICsgTWF0aC5wb3coaGFsZkxlbiwgMik7XG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcbiAgICAgICAgdmVjMi5zZXQobDAsIGhhbGZMZW4gKiAoaSoyLTEpLCAwKTtcbiAgICAgICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgICAgICB2YXIgYSA9IE1hdGgucG93KHRvWzBdIC0gZnJvbVswXSwgMikgKyBNYXRoLnBvdyh0b1sxXSAtIGZyb21bMV0sIDIpO1xuICAgICAgICB2YXIgYiA9IDIgKiAoKHRvWzBdIC0gZnJvbVswXSkgKiAoZnJvbVswXSAtIGwwWzBdKSArICh0b1sxXSAtIGZyb21bMV0pICogKGZyb21bMV0gLSBsMFsxXSkpO1xuICAgICAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBsMFswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gbDBbMV0sIDIpIC0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgICAgICBpZihkZWx0YSA8IDApe1xuICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAgICAgdmVjMi5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkZWx0YSk7XG5cbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XG4gICAgICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIHZhciBkMSA9ICgtIGIgLSBzcXJ0RGVsdGEpICogaW52MmE7XG4gICAgICAgICAgICB2YXIgZDIgPSAoLSBiICsgc3FydERlbHRhKSAqIGludjJhO1xuXG4gICAgICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xuICAgICAgICAgICAgICAgIHZlYzIubGVycChoaXRQb2ludFdvcmxkLCBmcm9tLCB0bywgZDEpO1xuICAgICAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgbDApO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnNob3VsZFN0b3AocmF5KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGQyID49IDAgJiYgZDIgPD0gMSl7XG4gICAgICAgICAgICAgICAgdmVjMi5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMik7XG4gICAgICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDIsIG5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG5cbi8qKlxuICogQ2lyY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENpcmNsZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcHRpb25zfSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFRoZSByYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBDaXJjbGUoeyByYWRpdXM6IDEgfSk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENpcmNsZShvcHRpb25zKXtcbiAgICBpZih0eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ251bWJlcicpe1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmFkaXVzOiBhcmd1bWVudHNbMF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgQ2lyY2xlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICAgKiBAcHJvcGVydHkgcmFkaXVzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDE7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DSVJDTEU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cbkNpcmNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gbWFzcyAqIHIgKiByIC8gMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgciwgIHIpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xuICAgIGlmKHBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cbn07XG5cbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24ocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGZyb20gPSByYXkuZnJvbSxcbiAgICAgICAgdG8gPSByYXkudG8sXG4gICAgICAgIHIgPSB0aGlzLnJhZGl1cztcblxuICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XG4gICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGRlbHRhKTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCAtMSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcbiAgICAgICAgdmFyIGludjJhID0gMSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBzcXJ0RGVsdGEpICogaW52MmE7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBzcXJ0RGVsdGEpICogaW52MmE7XG5cbiAgICAgICAgaWYoZDEgPj0gMCAmJiBkMSA8PSAxKXtcbiAgICAgICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQxKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMSwgbm9ybWFsLCAtMSk7XG5cbiAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGQyID49IDAgJiYgZDIgPD0gMSl7XG4gICAgICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDIsIG5vcm1hbCwgLTEpO1xuICAgICAgICB9XG4gICAgfVxufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL1NoYXBlXCI6NDV9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBwb2x5ayA9IF9kZXJlcV8oJy4uL21hdGgvcG9seWsnKVxuLCAgIGRlY29tcCA9IF9kZXJlcV8oJ3BvbHktZGVjb21wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4O1xuXG4vKipcbiAqIENvbnZleCBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDb252ZXhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZXJ0aWNlc10gQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5heGVzXSBBbiBhcnJheSBvZiB1bml0IGxlbmd0aCB2ZWN0b3JzLCByZXByZXNlbnRpbmcgdGhlIHN5bW1ldHJ5IGF4ZXMgaW4gdGhlIGNvbnZleC5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIGEgYm94XG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XG4gKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiB2ZXJ0aWNlcyB9KTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ29udmV4KG9wdGlvbnMpe1xuICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNlczogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXhlczogYXJndW1lbnRzWzFdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIENvbnZleCBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBDb252ZXgoeyB2ZXJ0aWNlczogWy4uLl0sIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xuICAgIHZhciB2ZXJ0aWNlcyA9IG9wdGlvbnMudmVydGljZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmVydGljZXMgOiBbXTtcbiAgICBmb3IodmFyIGk9MDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB2ZWMyLmNvcHkodiwgdmVydGljZXNbaV0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2godik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXhlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4ZXMgPSBbXTtcblxuICAgIGlmKG9wdGlvbnMuYXhlcyl7XG5cbiAgICAgICAgLy8gQ29weSB0aGUgYXhlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IG9wdGlvbnMuYXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkoYXhpcywgb3B0aW9ucy5heGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKGF4aXMpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBheGVzIGZyb20gdGhlIHZlcnRleCBkYXRhXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHRoaXMudmVydGljZXNbKGkrMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xuXG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChub3JtYWwpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIENvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBjZW50ZXJPZk1hc3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXG4gICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYodGhpcy52ZXJ0aWNlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGNvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DT05WRVg7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbiAgICBpZih0aGlzLmFyZWEgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY29udGVyLWNsb2Nrd2lzZSB3aW5kaW5nLlwiKTtcbiAgICB9XG59XG5Db252ZXgucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Db252ZXgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4O1xuXG52YXIgdG1wVmVjMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdG1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b0xvY2FsQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gdG1wVmVjMTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IHZlYzIuZG90KHYsIGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgbWluLCBtYXgpO1xufTtcblxuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b1dvcmxkQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCl7XG4gICAgdmFyIHdvcmxkQXhpcyA9IHRtcFZlYzI7XG5cbiAgICB0aGlzLnByb2plY3RPbnRvTG9jYWxBeGlzKGxvY2FsQXhpcywgcmVzdWx0KTtcblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICBpZihzaGFwZUFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmxkQXhpcyA9IGxvY2FsQXhpcztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHZlYzIuZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQocmVzdWx0LCByZXN1bHRbMF0gKyBvZmZzZXQsIHJlc3VsdFsxXSArIG9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAudHJpYW5nbGVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZVRyaWFuZ2xlc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZVRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmV3cml0ZSBvbiBwb2x5ayBub3RhdGlvbiwgYXJyYXkgb2YgbnVtYmVyc1xuICAgIHZhciBwb2x5a1ZlcnRzID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgcG9seWtWZXJ0cy5wdXNoKHZbMF0sdlsxXSk7XG4gICAgfVxuXG4gICAgLy8gVHJpYW5ndWxhdGVcbiAgICB2YXIgdHJpYW5nbGVzID0gcG9seWsuVHJpYW5ndWxhdGUocG9seWtWZXJ0cyk7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHRyaWFuZ2xlcywgYWRkIHRoZWlyIGluZXJ0aWEgY29udHJpYnV0aW9ucyB0byBJXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSs9Myl7XG4gICAgICAgIHZhciBpZDEgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBpZDIgPSB0cmlhbmdsZXNbaSsxXSxcbiAgICAgICAgICAgIGlkMyA9IHRyaWFuZ2xlc1tpKzJdO1xuXG4gICAgICAgIC8vIEFkZCB0byB0cmlhbmdsZXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChbaWQxLGlkMixpZDNdKTtcbiAgICB9XG59O1xuXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2FjID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmNlbnRlck9mTWFzcyBwcm9wZXJ0eS5cbiAqIEBtZXRob2QgdXBkYXRlQ2VudGVyT2ZNYXNzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQ2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgY20gPSB0aGlzLmNlbnRlck9mTWFzcyxcbiAgICAgICAgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsXG4gICAgICAgIG4gPSB1cGRhdGVDZW50ZXJPZk1hc3NfbixcbiAgICAgICAgYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19hLFxuICAgICAgICBiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2IsXG4gICAgICAgIGMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYyxcbiAgICAgICAgYWMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYWMsXG4gICAgICAgIGNhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NhLFxuICAgICAgICBjYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYixcbiAgICAgICAgY2VudHJvaWRfdGltZXNfbWFzcyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzO1xuXG4gICAgdmVjMi5zZXQoY20sMCwwKTtcbiAgICB2YXIgdG90YWxBcmVhID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgdmVjMi5jZW50cm9pZChjZW50cm9pZCxhLGIsYyk7XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdG90YWxBcmVhICs9IG07XG5cbiAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXG4gICAgICAgIHZlYzIuc2NhbGUoY2VudHJvaWRfdGltZXNfbWFzcywgY2VudHJvaWQsIG0pO1xuICAgICAgICB2ZWMyLmFkZChjbSwgY20sIGNlbnRyb2lkX3RpbWVzX21hc3MpO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sY20sMS90b3RhbEFyZWEpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDb252ZXguXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzM0MjgyMi1tb21lbnQtb2YtaW5lcnRpYS1vZi1hLXBvbHlnb24tMmQvXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciBkZW5vbSA9IDAuMCxcbiAgICAgICAgbnVtZXIgPSAwLjAsXG4gICAgICAgIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IodmFyIGogPSBOLTEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkgKyspe1xuICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzIuY3Jvc3NMZW5ndGgocDAscDEpKTtcbiAgICAgICAgdmFyIGIgPSB2ZWMyLmRvdChwMSxwMSkgKyB2ZWMyLmRvdChwMSxwMCkgKyB2ZWMyLmRvdChwMCxwMCk7XG4gICAgICAgIGRlbm9tICs9IGEgKiBiO1xuICAgICAgICBudW1lciArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gKG1hc3MgLyA2LjApICogKGRlbm9tIC8gbnVtZXIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYm91bmRpbmdSYWRpdXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcjIgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XG4gICAgICAgIGlmKGwyID4gcjIpe1xuICAgICAgICAgICAgcjIgPSBsMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIHBvaW50cyBhLCBiLCBjLiBUaGUgYXJlYSBpcyBwb3NpdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciwgb3RoZXJ3aXNlIG5lZ2F0aXZlLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCB0cmlhbmdsZUFyZWFcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ29udmV4LnRyaWFuZ2xlQXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYVxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0aGlzLmFyZWEgKz0gbTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcbn07XG5cbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9yYXlFbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByYXlTdGFydCA9IGludGVyc2VjdENvbnZleF9yYXlTdGFydDtcbiAgICB2YXIgcmF5RW5kID0gaW50ZXJzZWN0Q29udmV4X3JheUVuZDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRvIGxvY2FsIHNoYXBlIHNwYWNlXG4gICAgdmVjMi50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHJheS5mcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKHJheUVuZCwgcmF5LnRvLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgdmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgIXJlc3VsdC5zaG91bGRTdG9wKHJheSk7IGkrKykge1xuICAgICAgICB2YXIgcTEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIHEyID0gdmVydGljZXNbKGkrMSkgJSBuXTtcbiAgICAgICAgdmFyIGRlbHRhID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihyYXlTdGFydCwgcmF5RW5kLCBxMSwgcTIpO1xuXG4gICAgICAgIGlmKGRlbHRhID49IDApe1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBxMiwgcTEpO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIC1NYXRoLlBJIC8gMiArIGFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbn0se1wiLi4vbWF0aC9wb2x5a1wiOjI5LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuL1NoYXBlXCI6NDUsXCJwb2x5LWRlY29tcFwiOjV9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZGlzdGFuY2UgXCJlbGVtZW50V2lkdGhcIi5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmhlaWdodHNdIEFuIGFycmF5IG9mIFkgdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdGVycmFpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VmFsdWVdIE1heGltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFdpZHRoPTAuMV0gV29ybGQgc3BhY2luZyBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBoZWlnaHRzLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoe1xuICogICAgICAgICBoZWlnaHRzOiBoZWlnaHRzLFxuICogICAgICAgICBlbGVtZW50V2lkdGg6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb25cbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICpcbiAqIEB0b2RvIFNob3VsZCB1c2UgYSBzY2FsZSBwcm9wZXJ0eSB3aXRoIFggYW5kIFkgZGlyZWN0aW9uIGluc3RlYWQgb2YganVzdCBlbGVtZW50V2lkdGhcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQob3B0aW9ucyl7XG4gICAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlaWdodHM6IGFyZ3VtZW50c1swXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMV0pID09PSAnb2JqZWN0Jyl7XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBhcmd1bWVudHNbMV0pe1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IGFyZ3VtZW50c1sxXVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgSGVpZ2h0ZmllbGQgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgSGVpZ2h0ZmllbGQoeyBoZWlnaHRzOiBbLi4uXSwgLi4uIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhlaWdodHNcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodHMgPSBvcHRpb25zLmhlaWdodHMgPyBvcHRpb25zLmhlaWdodHMuc2xpY2UoMCkgOiBbXTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgaGVpZ2h0c1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGhlaWdodHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50V2lkdGhcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRXaWR0aCA9IG9wdGlvbnMuZWxlbWVudFdpZHRoIHx8IDAuMTtcblxuICAgIGlmKG9wdGlvbnMubWF4VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1pblZhbHVlID09PSB1bmRlZmluZWQpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1heE1pblZhbHVlcygpO1xuICAgIH1cblxuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLkhFSUdIVEZJRUxEO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIGFuZCB0aGUgLm1heFZhbHVlXG4gKiBAbWV0aG9kIHVwZGF0ZU1heE1pblZhbHVlc1xuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4TWluVmFsdWVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cztcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdO1xuICAgIHZhciBtaW5WYWx1ZSA9IGRhdGFbMF07XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IGRhdGFbaV07XG4gICAgICAgIGlmKHYgPiBtYXhWYWx1ZSl7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYodiA8IG1pblZhbHVlKXtcbiAgICAgICAgICAgIG1pblZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1heFZhbHVlID0gbWF4VmFsdWU7XG4gICAgdGhpcy5taW5WYWx1ZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cyxcbiAgICAgICAgYXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgYXJlYSArPSAoZGF0YVtpXStkYXRhW2krMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIH1cbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xufTtcblxudmFyIHBvaW50cyA9IFtcbiAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIHZlYzIuY3JlYXRlKCksXG4gICAgdmVjMi5jcmVhdGUoKSxcbiAgICB2ZWMyLmNyZWF0ZSgpXG5dO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5zZXQocG9pbnRzWzBdLCAwLCB0aGlzLm1heFZhbHVlKTtcbiAgICB2ZWMyLnNldChwb2ludHNbMV0sIHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5oZWlnaHRzLmxlbmd0aCwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzJdLCB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuaGVpZ2h0cy5sZW5ndGgsIHRoaXMubWluVmFsdWUpO1xuICAgIHZlYzIuc2V0KHBvaW50c1szXSwgMCwgdGhpcy5taW5WYWx1ZSk7XG4gICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBsaW5lIHNlZ21lbnQgaW4gdGhlIGhlaWdodGZpZWxkXG4gKiBAbWV0aG9kIGdldExpbmVTZWdtZW50XG4gKiBAcGFyYW0gIHthcnJheX0gc3RhcnQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzdGFydCBwb2ludFxuICogQHBhcmFtICB7YXJyYXl9IGVuZCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIGVuZCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGkpe1xuICAgIHZhciBkYXRhID0gdGhpcy5oZWlnaHRzO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIHZlYzIuc2V0KHN0YXJ0LCBpICogd2lkdGgsIGRhdGFbaV0pO1xuICAgIHZlYzIuc2V0KGVuZCwgKGkgKyAxKSAqIHdpZHRoLCBkYXRhW2kgKyAxXSk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24ocG9zaXRpb24pe1xuICAgIHJldHVybiBNYXRoLmZsb29yKHBvc2l0aW9uWzBdIC8gdGhpcy5lbGVtZW50V2lkdGgpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENsYW1wZWRTZWdtZW50SW5kZXggPSBmdW5jdGlvbihwb3NpdGlvbil7XG4gICAgdmFyIGkgPSB0aGlzLmdldFNlZ21lbnRJbmRleChwb3NpdGlvbik7XG4gICAgaSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0cy5sZW5ndGgsIE1hdGgubWF4KGksIDApKTsgLy8gY2xhbXBcbiAgICByZXR1cm4gaTtcbn07XG5cbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDAgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2wxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbEZyb20gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsVG8gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX3VuaXRfeSA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG4vLyBSZXR1cm5zIDEgaWYgdGhlIGxpbmVzIGludGVyc2VjdCwgb3RoZXJ3aXNlIDAuXG5mdW5jdGlvbiBnZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb24gKG91dCwgcDAsIHAxLCBwMiwgcDMpIHtcblxuICAgIHZhciBzMV94LCBzMV95LCBzMl94LCBzMl95O1xuICAgIHMxX3ggPSBwMVswXSAtIHAwWzBdO1xuICAgIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xuICAgIHMyX3ggPSBwM1swXSAtIHAyWzBdO1xuICAgIHMyX3kgPSBwM1sxXSAtIHAyWzFdO1xuXG4gICAgdmFyIHMsIHQ7XG4gICAgcyA9ICgtczFfeSAqIChwMFswXSAtIHAyWzBdKSArIHMxX3ggKiAocDBbMV0gLSBwMlsxXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcbiAgICB0ID0gKCBzMl94ICogKHAwWzFdIC0gcDJbMV0pIC0gczJfeSAqIChwMFswXSAtIHAyWzBdKSkgLyAoLXMyX3ggKiBzMV95ICsgczFfeCAqIHMyX3kpO1xuICAgIGlmIChzID49IDAgJiYgcyA8PSAxICYmIHQgPj0gMCAmJiB0IDw9IDEpIHsgLy8gQ29sbGlzaW9uIGRldGVjdGVkXG4gICAgICAgIHZhciBpbnRYID0gcDBbMF0gKyAodCAqIHMxX3gpO1xuICAgICAgICB2YXIgaW50WSA9IHAwWzFdICsgKHQgKiBzMV95KTtcbiAgICAgICAgb3V0WzBdID0gaW50WDtcbiAgICAgICAgb3V0WzFdID0gaW50WTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXG59XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuXG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9oaXRQb2ludFdvcmxkO1xuICAgIHZhciB3b3JsZE5vcm1hbCA9IGludGVyc2VjdEhlaWdodGZpZWxkX3dvcmxkTm9ybWFsO1xuICAgIHZhciBsMCA9IGludGVyc2VjdEhlaWdodGZpZWxkX2wwO1xuICAgIHZhciBsMSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2wxO1xuICAgIHZhciBsb2NhbEZyb20gPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbEZyb207XG4gICAgdmFyIGxvY2FsVG8gPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvO1xuXG4gICAgLy8gZ2V0IGxvY2FsIHJheSBzdGFydCBhbmQgZW5kXG4gICAgdmVjMi50b0xvY2FsRnJhbWUobG9jYWxGcm9tLCBmcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKGxvY2FsVG8sIHRvLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgLy8gR2V0IHRoZSBzZWdtZW50IHJhbmdlXG4gICAgdmFyIGkwID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsRnJvbSk7XG4gICAgdmFyIGkxID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsVG8pO1xuICAgIGlmKGkwID4gaTEpe1xuICAgICAgICB2YXIgdG1wID0gaTA7XG4gICAgICAgIGkwID0gaTE7XG4gICAgICAgIGkxID0gdG1wO1xuICAgIH1cblxuICAgIC8vIFRoZSBzZWdtZW50c1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICB0aGlzLmdldExpbmVTZWdtZW50KGwwLCBsMSwgaSk7XG4gICAgICAgIHZhciB0ID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsb2NhbEZyb20sIGxvY2FsVG8sIGwwLCBsMSk7XG4gICAgICAgIGlmKHQgPj0gMCl7XG4gICAgICAgICAgICB2ZWMyLnN1Yih3b3JsZE5vcm1hbCwgbDEsIGwwKTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUgKyBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIHQsIHdvcmxkTm9ybWFsLCAtMSk7XG4gICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NoYXBlXCI6NDV9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqXG4gKiBMaW5lIHNoYXBlIGNsYXNzLiBUaGUgbGluZSBzaGFwZSBpcyBhbG9uZyB0aGUgeCBkaXJlY3Rpb24sIGFuZCBzdHJldGNoZXMgZnJvbSBbLWxlbmd0aC8yLCAwXSB0byBbbGVuZ3RoLzIsMF0uXG4gKiBAY2xhc3MgTGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MV0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMaW5lKG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMF0pID09PSAnbnVtYmVyJyl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsZW5ndGg6IGFyZ3VtZW50c1swXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBMaW5lIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IExpbmUoeyBsZW5ndGg6IDEsIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgMTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLkxJTkU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cbkxpbmUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmU7XG5cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gbWFzcyAqIE1hdGgucG93KHRoaXMubGVuZ3RoLDIpIC8gMTI7XG59O1xuXG5MaW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMubGVuZ3RoLzI7XG59O1xuXG52YXIgcG9pbnRzID0gW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBsMiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICB2ZWMyLnNldChwb2ludHNbMF0sIC1sMiwgIDApO1xuICAgIHZlYzIuc2V0KHBvaW50c1sxXSwgIGwyLCAgMCk7XG4gICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLHBvc2l0aW9uLGFuZ2xlLDApO1xufTtcblxudmFyIHJheWNhc3RfaGl0UG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJheWNhc3Rfbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X2wwID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X2wxID0gdmVjMi5jcmVhdGUoKTtcbnZhciByYXljYXN0X3VuaXRfeSA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKi9cbkxpbmUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbihyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xuICAgIHZhciB0byA9IHJheS50bztcblxuICAgIHZhciBsMCA9IHJheWNhc3RfbDA7XG4gICAgdmFyIGwxID0gcmF5Y2FzdF9sMTtcblxuICAgIC8vIGdldCBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXG4gICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgdmVjMi5zZXQobDAsIC1oYWxmTGVuLCAwKTtcbiAgICB2ZWMyLnNldChsMSwgaGFsZkxlbiwgMCk7XG4gICAgdmVjMi50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDEsIGwxLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgdmFyIGZyYWN0aW9uID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsMCwgbDEsIGZyb20sIHRvKTtcbiAgICBpZihmcmFjdGlvbiA+PSAwKXtcbiAgICAgICAgdmFyIG5vcm1hbCA9IHJheWNhc3Rfbm9ybWFsO1xuICAgICAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIHJheWNhc3RfdW5pdF95LCBhbmdsZSk7IC8vIHRvZG86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiB3aGljaCBzaWRlIHRoZSByYXkgY29tZXMgZnJvbVxuICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgLTEpO1xuICAgIH1cbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy50eXBlID0gU2hhcGUuUEFSVElDTEU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi9TaGFwZVwiOjQ1fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gIF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gIF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcblxuLyoqXG4gKiBQbGFuZSBzaGFwZSBjbGFzcy4gVGhlIHBsYW5lIGlzIGZhY2luZyBpbiB0aGUgWSBkaXJlY3Rpb24uXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLlBMQU5FO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gYW5nbGUgJSAoMiAqIE1hdGguUEkpO1xuICAgIHZhciBzZXQgPSB2ZWMyLnNldDtcbiAgICB2YXIgbWF4ID0gMWU3O1xuICAgIHZhciBsb3dlckJvdW5kID0gb3V0Lmxvd2VyQm91bmQ7XG4gICAgdmFyIHVwcGVyQm91bmQgPSBvdXQudXBwZXJCb3VuZDtcblxuICAgIC8vIFNldCBtYXggYm91bmRzXG4gICAgc2V0KGxvd2VyQm91bmQsIC1tYXgsIC1tYXgpO1xuICAgIHNldCh1cHBlckJvdW5kLCAgbWF4LCAgbWF4KTtcblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgdXBwZXJCb3VuZFsxXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAtbWF4LCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICBtYXgsICAwKTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJIC8gMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgbG93ZXJCb3VuZFswXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAwLCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICAgICAgbWF4LCAgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJKXtcblxuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBsb3dlckJvdW5kWzFdID0gMDtcbiAgICAgICAgLy8gc2V0KGxvd2VyQm91bmQsIC1tYXgsIDApO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIG1heCwgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSAzKk1hdGguUEkvMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHVwcGVyQm91bmRbMF0gPSAwO1xuICAgICAgICAvLyBzZXQobG93ZXJCb3VuZCwgLW1heCwgICAgIC1tYXgpO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIDAsICBtYXgpO1xuXG4gICAgfVxufTtcblxuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG52YXIgaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3QgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2hpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5QbGFuZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdDtcbiAgICB2YXIgaGl0UG9pbnQgPSBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfbm9ybWFsO1xuICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xuXG4gICAgdmVjMi5zdWIobGVuLCBmcm9tLCBwb3NpdGlvbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuICAgIHZlYzIuc3ViKGxlbiwgdG8sIHBvc2l0aW9uKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGZyb20sIHRvKSA8IHBsYW5lVG9Gcm9tICogcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHZlYzIuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTtcblxuICAgIHZlYzIuc3ViKHBsYW5lUG9pbnRUb0Zyb20sIGZyb20sIHBvc2l0aW9uKTtcbiAgICB2YXIgdCA9IC12ZWMyLmRvdChub3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyIC8gcmF5Lmxlbmd0aDtcblxuICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCBub3JtYWwsIC0xKTtcbn07XG59LHtcIi4uL21hdGgvdmVjMlwiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1NyxcIi4vU2hhcGVcIjo0NX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzLlxuICogQGNsYXNzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPTFdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbnNvcj1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50eXBlPTBdXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgdGhpcyBzaGFwZSBpcyBhdHRhY2hlZCB0by4gQSBzaGFwZSBjYW4gb25seSBiZSBhdHRhY2hlZCB0byBhIHNpbmdsZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5LWxvY2FsIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvZHktbG9jYWwgYW5nbGUgb2YgdGhlIHNoYXBlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcbiAgICAgKlxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0lSQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLkNJUkNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QQVJUSUNMRTpwcm9wZXJ0eVwifX1TaGFwZS5QQVJUSUNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QTEFORTpwcm9wZXJ0eVwifX1TaGFwZS5QTEFORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DT05WRVg6cHJvcGVydHlcIn19U2hhcGUuQ09OVkVYe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0xJTkU6cHJvcGVydHlcIn19U2hhcGUuTElORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9CT1g6cHJvcGVydHlcIn19U2hhcGUuQk9Ye3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NBUFNVTEU6cHJvcGVydHlcIn19U2hhcGUuQ0FQU1VMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9IRUlHSFRGSUVMRDpwcm9wZXJ0eVwifX1TaGFwZS5IRUlHSFRGSUVMRHt7L2Nyb3NzTGlua319XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2JqZWN0IGlkZW50aWZpZXIuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIGdyb3VwIHRoYXQgdGhpcyBzaGFwZSBiZWxvbmdzIHRvIChiaXQgbWFzaykuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hdXJlbGllbnJpYm9uLmNvbS9ibG9nLzIwMTEvMDcvYm94MmQtdHV0b3JpYWwtY29sbGlzaW9uLWZpbHRlcmluZy9cIj50aGlzIHR1dG9yaWFsPC9hPi5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFNldHVwIGJpdHMgZm9yIGVhY2ggYXZhaWxhYmxlIGdyb3VwXG4gICAgICogICAgIHZhciBQTEFZRVIgPSBNYXRoLnBvdygyLDApLFxuICAgICAqICAgICAgICAgRU5FTVkgPSAgTWF0aC5wb3coMiwxKSxcbiAgICAgKiAgICAgICAgIEdST1VORCA9IE1hdGgucG93KDIsMilcbiAgICAgKlxuICAgICAqICAgICAvLyBQdXQgc2hhcGVzIGludG8gdGhlaXIgZ3JvdXBzXG4gICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uR3JvdXAgPSBFTkVNWTtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbkdyb3VwID0gR1JPVU5EO1xuICAgICAqXG4gICAgICogICAgIC8vIEFzc2lnbiBncm91cHMgdGhhdCBlYWNoIHNoYXBlIGNvbGxpZGUgd2l0aC5cbiAgICAgKiAgICAgLy8gTm90ZSB0aGF0IHRoZSBwbGF5ZXJzIGNhbiBjb2xsaWRlIHdpdGggZ3JvdW5kIGFuZCBlbmVtaWVzLCBidXQgbm90IHdpdGggb3RoZXIgcGxheWVycy5cbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBHUk9VTkQ7XG4gICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgRU5FTVk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBIb3cgY29sbGlzaW9uIGNoZWNrIGlzIGRvbmVcbiAgICAgKiAgICAgaWYoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spIT0wICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykhPTApe1xuICAgICAqICAgICAgICAgLy8gVGhlIHNoYXBlcyB3aWxsIGNvbGxpZGVcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkdyb3VwIDogMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgc2hhcGUgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9keSBzaGFwZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2UgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIG1hc2sgb2YgdGhpcyBzaGFwZS4gU2VlIC5jb2xsaXNpb25Hcm91cC5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uTWFza1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAxO1xuXG4gICAgLyoqXG4gICAgICogTWF0ZXJpYWwgdG8gdXNlIGluIGNvbGxpc2lvbnMgZm9yIHRoaXMgU2hhcGUuIElmIHRoaXMgaXMgc2V0IHRvIG51bGwsIHRoZSB3b3JsZCB3aWxsIHVzZSBkZWZhdWx0IG1hdGVyaWFsIHByb3BlcnRpZXMgaW5zdGVhZC5cbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWwgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFyZWEgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkgYXJlYVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgc2hhcGUgdG8gYmUgYSBzZW5zb3IuIEEgc2Vuc29yIGRvZXMgbm90IGdlbmVyYXRlIGNvbnRhY3RzLCBidXQgaXQgc3RpbGwgcmVwb3J0cyBjb250YWN0IGV2ZW50cy4gVGhpcyBpcyBnb29kIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzaGFwZSBpcyBvdmVybGFwcGluZyBhbm90aGVyIHNoYXBlLCB3aXRob3V0IHRoZW0gZ2VuZXJhdGluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlbnNvclxuICAgICAqL1xuICAgIHRoaXMuc2Vuc29yID0gb3B0aW9ucy5zZW5zb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2Vuc29yIDogZmFsc2U7XG5cbiAgICBpZih0aGlzLnR5cGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG59XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxuICovXG5TaGFwZS5DSVJDTEUgPSAgICAgIDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFBBUlRJQ0xFXG4gKi9cblNoYXBlLlBBUlRJQ0xFID0gICAgMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcbiAqL1xuU2hhcGUuUExBTkUgPSAgICAgICA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDT05WRVhcbiAqL1xuU2hhcGUuQ09OVkVYID0gICAgICA4O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXG4gKi9cblNoYXBlLkxJTkUgPSAgICAgICAgMTY7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPWFxuICovXG5TaGFwZS5CT1ggPSAgIDMyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhcGUsICdSRUNUQU5HTEUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTaGFwZS5SRUNUQU5HTEUgaXMgZGVwcmVjYXRlZCwgdXNlIFNoYXBlLkJPWCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gU2hhcGUuQk9YO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDQVBTVUxFXG4gKi9cblNoYXBlLkNBUFNVTEUgPSAgICAgNjQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhFSUdIVEZJRUxEXG4gKi9cblNoYXBlLkhFSUdIVEZJRUxEID0gMTI4O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdGhlIG1vbWVudCBvZiBpbmVydGlhIGFyb3VuZCB0aGUgWiBheGlzIG9mIHRoZSBib2R5IGdpdmVuIHRoZSB0b3RhbCBtYXNzLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcIj5XaWtpcGVkaWEncyBsaXN0IG9mIG1vbWVudHMgb2YgaW5lcnRpYTwvYT4uXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBJZiB0aGUgaW5lcnRpYSBpcyBpbmZpbml0eSBvciBpZiB0aGUgb2JqZWN0IHNpbXBseSBpc24ndCBwb3NzaWJsZSB0byByb3RhdGUsIHJldHVybiAwLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe307XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYSBwcm9wZXJ0eSBvZiB0aGUgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGFsbCBzdWJjbGFzc2VzXG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHdvcmxkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBvdXQgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9IHBvc2l0aW9uIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGUgV29ybGQgYW5nbGUgb2YgdGhlIHNoYXBlLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHJheWNhc3Rpbmcgb24gdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5UmVzdWx0fSByZXN1bHQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBkYXRhLlxuICogQHBhcmFtICB7UmF5fSByYXkgVGhlIFJheSB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgcmF5Y2FzdGluZy5cbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvbiBXb3JsZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgKHRoZSAucG9zaXRpb24gcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkKS5cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgV29ybGQgYW5nbGUgb2YgdGhlIHNoYXBlICh0aGUgLmFuZ2xlIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZCkuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24ocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzB9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xuXG4vKipcbiAqIEl0ZXJhdGl2ZSBHYXVzcy1TZWlkZWwgY29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIEdTU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNvbHZlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlPTBdXG4gKi9cbmZ1bmN0aW9uIEdTU29sdmVyKG9wdGlvbnMpe1xuICAgIFNvbHZlci5jYWxsKHRoaXMsb3B0aW9ucyxTb2x2ZXIuR1MpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBkbyB3aGVuIHNvbHZpbmcuIE1vcmUgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMsIGJ1dCBpcyBtb3JlIGV4cGVuc2l2ZS5cbiAgICAgKiBAcHJvcGVydHkgaXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zIHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIHRvbGVyYW5jZSwgcGVyIGNvbnN0cmFpbnQuIElmIHRoZSB0b3RhbCBlcnJvciBpcyBiZWxvdyB0aGlzIGxpbWl0LCB0aGUgc29sdmVyIHdpbGwgc3RvcCBpdGVyYXRpbmcuIFNldCB0byB6ZXJvIGZvciBhcyBnb29kIHNvbHV0aW9uIGFzIHBvc3NpYmxlLCBidXQgdG8gc29tZXRoaW5nIGxhcmdlciB0aGFuIHplcm8gdG8gbWFrZSBjb21wdXRhdGlvbnMgZmFzdGVyLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFlLTdcbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZSA9IG9wdGlvbnMudG9sZXJhbmNlIHx8IDFlLTc7XG5cbiAgICB0aGlzLmFycmF5U3RlcCA9IDMwO1xuICAgIHRoaXMubGFtYmRhID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuQnMgPSAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuaW52Q3MgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2V0IGFsbCByaWdodCBoYW5kIHNpZGUgdGVybXMgdG8gemVybyB3aGVuIHNvbHZpbmcuIENhbiBiZSBoYW5keSBmb3IgYSBmZXcgYXBwbGljYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB1c2VaZXJvUkhTXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHRvZG8gUmVtb3ZlLCBub3QgdXNlZFxuICAgICAqL1xuICAgIHRoaXMudXNlWmVyb1JIUyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gYXBwcm94aW1hdGUgbm9ybWFsIGZvcmNlcyB1c2VkIGZvciBmcmljdGlvbiAoRl9mcmljdGlvbiA9IG11ICogRl9ub3JtYWwpLiBUaGVzZSBmcmljdGlvbiBmb3JjZXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgZnJpY3Rpb24gZm9yY2VzIHRoYXQgYXJlIHNldC4gSWYgeW91IHNldCBmcmljdGlvbkl0ZXJhdGlvbnMgPSAwLCB0aGVuIHRoaXMgZmVhdHVyZSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVXNlIG9ubHkgZnJpY3Rpb25JdGVyYXRpb25zID4gMCBpZiB0aGUgYXBwcm94aW1hdGVkIG5vcm1hbCBmb3JjZSAoRl9ub3JtYWwgPSBtYXNzICogZ3Jhdml0eSkgaXMgbm90IGdvb2QgZW5vdWdoLiBFeGFtcGxlcyBvZiB3aGVyZSBpdCBjYW4gaGFwcGVuIGlzIGluIHNwYWNlIGdhbWVzIHdoZXJlIGdyYXZpdHkgaXMgemVybywgb3IgaW4gdGFsbCBzdGFja3Mgd2hlcmUgdGhlIG5vcm1hbCBmb3JjZSBpcyBsYXJnZSBhdCBib3R0b20gYnV0IHNtYWxsIGF0IHRvcC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyA9IG9wdGlvbnMuZnJpY3Rpb25JdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5mcmljdGlvbkl0ZXJhdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXG4gICAgICovXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG59XG5HU1NvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5HU1NvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHU1NvbHZlcjtcblxuZnVuY3Rpb24gc2V0QXJyYXlaZXJvKGFycmF5KXtcbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBhcnJheVtsXSA9ICswLjA7XG4gICAgfVxufVxuXG4vKipcbiAqIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgIFRpbWUgc3RlcFxuICogQHBhcmFtICB7V29ybGR9ICAgd29ybGQgICAgV29ybGQgdG8gc29sdmVcbiAqL1xuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oaCwgd29ybGQpe1xuXG4gICAgdGhpcy5zb3J0RXF1YXRpb25zKCk7XG5cbiAgICB2YXIgaXRlciA9IDAsXG4gICAgICAgIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsXG4gICAgICAgIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlKk5lcSwgMiksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmJvZGllcyA9IHdvcmxkLmJvZGllcy5sZW5ndGgsXG4gICAgICAgIGFkZCA9IHZlYzIuYWRkLFxuICAgICAgICBzZXQgPSB2ZWMyLnNldCxcbiAgICAgICAgdXNlWmVyb1JIUyA9IHRoaXMudXNlWmVyb1JIUyxcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGE7XG5cbiAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcblxuICAgIGlmKE5lcSl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgICAgICAgICAgYi51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIGlmKGxhbWJkYS5sZW5ndGggPCBOZXEpe1xuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYSA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuQnMgPSAgICAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICAgICAgdGhpcy5pbnZDcyA9ICAgICAgICAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgIH1cbiAgICBzZXRBcnJheVplcm8obGFtYmRhKTtcbiAgICB2YXIgaW52Q3MgPSB0aGlzLmludkNzLFxuICAgICAgICBCcyA9IHRoaXMuQnMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoYy50aW1lU3RlcCAhPT0gaCB8fCBjLm5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGMudGltZVN0ZXAgPSBoO1xuICAgICAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBCc1tpXSA9ICAgICBjLmNvbXB1dGVCKGMuYSxjLmIsaCk7XG4gICAgICAgIGludkNzW2ldID0gIGMuY29tcHV0ZUludkMoYy5lcHNpbG9uKTtcbiAgICB9XG5cbiAgICB2YXIgcSwgQiwgYywgZGVsdGFsYW1iZGFUb3QsaSxqO1xuXG4gICAgaWYoTmVxICE9PSAwKXtcblxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2bGFtYmRhXG4gICAgICAgICAgICBiLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYXhGcmljdGlvbkl0ZXIpe1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGNvbnRhY3QgZXF1YXRpb25zIHRvIGdldCBub3JtYWwgZm9yY2VzXG4gICAgICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgbGFtYmRhLCAxL2gpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY29tcHV0ZWQgZnJpY3Rpb24gZm9yY2VcbiAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgICAgIGlmKGVxIGluc3RhbmNlb2YgRnJpY3Rpb25FcXVhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gIGY7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlcXVhdGlvbnNcbiAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEl0ZXI7IGl0ZXIrKyl7XG5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IE1hdGguYWJzKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uYWRkQ29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcbiAgICB9XG59O1xuXG4vLyBTZXRzIHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG5HU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyA9IGZ1bmN0aW9uKGVxdWF0aW9ucywgbGFtYmRhLCBpbnZEdCl7XG4gICAgLy8gU2V0IHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG4gICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XG4gICAgfVxufTtcblxuR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uID0gZnVuY3Rpb24oaixlcSxlcHMsQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsZHQsaXRlcil7XG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgQiA9IEJzW2pdLFxuICAgICAgICBpbnZDID0gaW52Q3Nbal0sXG4gICAgICAgIGxhbWJkYWogPSBsYW1iZGFbal0sXG4gICAgICAgIEdXbGFtYmRhID0gZXEuY29tcHV0ZUdXbGFtYmRhKCk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSBlcS5tYXhGb3JjZSxcbiAgICAgICAgbWluRm9yY2UgPSBlcS5taW5Gb3JjZTtcblxuICAgIGlmKHVzZVplcm9SSFMpe1xuICAgICAgICBCID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFsYW1iZGEgPSBpbnZDICogKCBCIC0gR1dsYW1iZGEgLSBlcHMgKiBsYW1iZGFqICk7XG5cbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxuICAgIHZhciBsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPSBsYW1iZGFqICsgZGVsdGFsYW1iZGE7XG4gICAgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhIDwgbWluRm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1pbkZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9IGVsc2UgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9XG4gICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XG5cbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMCxcIi4uL3V0aWxzL1V0aWxzXCI6NTcsXCIuL1NvbHZlclwiOjQ3fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxuICogQGNsYXNzIFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsdHlwZSl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNvcnQgYWxsIGVxdWF0aW9ucyBiZWZvcmUgZWFjaCBzb2x2ZS5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25Tb3J0RnVuY3Rpb25cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb258Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gb3B0aW9ucy5lcXVhdGlvblNvcnRGdW5jdGlvbiB8fCBmYWxzZTtcbn1cblNvbHZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Tb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29sdmVyO1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2x2ZXIuc29sdmUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMhXCIpO1xufTtcblxudmFyIG1vY2tXb3JsZCA9IHtib2RpZXM6W119O1xuXG4vKipcbiAqIFNvbHZlcyBhbGwgY29uc3RyYWludHMgaW4gYW4gaXNsYW5kLlxuICogQG1ldGhvZCBzb2x2ZUlzbGFuZFxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7SXNsYW5kfSBpc2xhbmRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uKGR0LGlzbGFuZCl7XG5cbiAgICB0aGlzLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICB0aGlzLmFkZEVxdWF0aW9ucyhpc2xhbmQuZXF1YXRpb25zKTtcbiAgICAgICAgbW9ja1dvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBpc2xhbmQuZ2V0Qm9kaWVzKG1vY2tXb3JsZC5ib2RpZXMpO1xuXG4gICAgICAgIC8vIFNvbHZlXG4gICAgICAgIGlmKG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc29sdmUoZHQsbW9ja1dvcmxkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU29ydCBhbGwgZXF1YXRpb25zIHVzaW5nIHRoZSAuZXF1YXRpb25Tb3J0RnVuY3Rpb24uIFNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3NlcyBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2Qgc29ydEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvcnRFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uIHRvIGJlIHNvbHZlZC5cbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gZXFzXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24oZXFzKXtcbiAgICAvL1V0aWxzLmFwcGVuZEFycmF5KHRoaXMuZXF1YXRpb25zLGVxcyk7XG4gICAgZm9yKHZhciBpPTAsIE49ZXFzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGg9MDtcbn07XG5cblNvbHZlci5HUyA9IDE7XG5Tb2x2ZXIuSVNMQU5EID0gMjtcblxufSx7XCIuLi9ldmVudHMvRXZlbnRFbWl0dGVyXCI6MjYsXCIuLi91dGlscy9VdGlsc1wiOjU3fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWN0RXF1YXRpb25Qb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XG4gKi9cbkNvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBDb250YWN0RXF1YXRpb24oKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25cbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvblBvb2x9XG4gKi9cbkNvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcblx0ZXF1YXRpb24uYm9keUEgPSBlcXVhdGlvbi5ib2R5QiA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjEsXCIuL1Bvb2xcIjo1NX1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb25Qb29sKCkge1xuXHRQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XG4gKi9cbkZyaWN0aW9uRXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgRnJpY3Rpb25FcXVhdGlvbigpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSB7RnJpY3Rpb25FcXVhdGlvbn0gZXF1YXRpb25cbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb25Qb29sfVxuICovXG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcXVhdGlvbikge1xuXHRlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uXCI6MjMsXCIuL1Bvb2xcIjo1NX1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBJc2xhbmROb2RlID0gX2RlcmVxXygnLi4vd29ybGQvSXNsYW5kTm9kZScpO1xudmFyIFBvb2wgPSBfZGVyZXFfKCcuL1Bvb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZVBvb2woKSB7XG5cdFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbklzbGFuZE5vZGVQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5Jc2xhbmROb2RlUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7SXNsYW5kTm9kZX1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBJc2xhbmROb2RlKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlUG9vbH1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRub2RlLnJlc2V0KCk7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuLi93b3JsZC9Jc2xhbmROb2RlXCI6NjAsXCIuL1Bvb2xcIjo1NX1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBJc2xhbmQgPSBfZGVyZXFfKCcuLi93b3JsZC9Jc2xhbmQnKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gSXNsYW5kUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuSXNsYW5kUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuSXNsYW5kUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJc2xhbmRQb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtJc2xhbmR9XG4gKi9cbklzbGFuZFBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBJc2xhbmQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge0lzbGFuZH0gaXNsYW5kXG4gKiBAcmV0dXJuIHtJc2xhbmRQb29sfVxuICovXG5Jc2xhbmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGlzbGFuZCkge1xuXHRpc2xhbmQucmVzZXQoKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4uL3dvcmxkL0lzbGFuZFwiOjU4LFwiLi9Qb29sXCI6NTV9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi9UdXBsZURpY3Rpb25hcnknKTtcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gX2RlcmVxXygnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wgPSBfZGVyZXFfKCcuL092ZXJsYXBLZWVwZXJSZWNvcmRQb29sJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcEtlZXBlcjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBvdmVybGFwcyBpbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIGxhc3Qgc3RlcCBzdGF0ZS5cbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlcigpIHtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy5yZWNvcmRQb29sID0gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sKHsgc2l6ZTogMTYgfSk7XG4gICAgdGhpcy50bXBEaWN0ID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMudG1wQXJyYXkxID0gW107XG59XG5cbi8qKlxuICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXG4gKiBAbWV0aG9kIHRpY2tcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG5cbiAgICAvLyBTYXZlIG9sZCBvYmplY3RzIGludG8gcG9vbFxuICAgIHZhciBsID0gbGFzdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gbGFzdC5rZXlzW2xdO1xuICAgICAgICB2YXIgbGFzdE9iamVjdCA9IGxhc3QuZ2V0QnlLZXkoa2V5KTtcbiAgICAgICAgdmFyIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIGlmKGxhc3RPYmplY3Qpe1xuICAgICAgICAgICAgLy8gVGhlIHJlY29yZCBpcyBvbmx5IHVzZWQgaW4gdGhlIFwibGFzdFwiIGRpY3QsIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFdlIG1pZ2h0IGFzIHdlbGwgcG9vbCBpdC5cbiAgICAgICAgICAgIHRoaXMucmVjb3JkUG9vbC5yZWxlYXNlKGxhc3RPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcbiAgICBsYXN0LnJlc2V0KCk7XG5cbiAgICAvLyBUcmFuc2ZlciBmcm9tIG5ldyBvYmplY3QgdG8gb2xkXG4gICAgbGFzdC5jb3B5KGN1cnJlbnQpO1xuXG4gICAgLy8gQ2xlYXIgY3VycmVudCBvYmplY3RcbiAgICBjdXJyZW50LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU3RvcmUgY3VycmVudCBjb250YWN0IHN0YXRlXG4gICAgaWYoIWN1cnJlbnQuZ2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkKSl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWNvcmRQb29sLmdldCgpO1xuICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xuICAgIH1cbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld092ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGJvZGllcyBhcmUgY3VycmVudGx5IG92ZXJsYXBwaW5nLlxuICogQG1ldGhvZCBib2RpZXNBcmVPdmVybGFwcGluZ1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5ib2RpZXNBcmVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuICAgICAgICBpZigoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbihkaWN0QSwgZGljdEIsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgbGFzdCA9IGRpY3RBO1xuICAgIHZhciBjdXJyZW50ID0gZGljdEI7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcra2V5KycgaGFkIG5vIGRhdGEhJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERhdGEgPSBsYXN0LmRhdGFba2V5XTtcbiAgICAgICAgaWYoIWxhc3REYXRhKXtcbiAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmlzTmV3T3ZlcmxhcCA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgaWRBID0gc2hhcGVBLmlkfDAsXG4gICAgICAgIGlkQiA9IHNoYXBlQi5pZHwwO1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG4gICAgLy8gTm90IGluIGxhc3QgYnV0IGluIG5ld1xuICAgIHJldHVybiAhISFsYXN0LmdldChpZEEsIGlkQikgJiYgISFjdXJyZW50LmdldChpZEEsIGlkQik7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRCb2R5RGlmZiA9IGZ1bmN0aW9uKG92ZXJsYXBzLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XG5cbiAgICB2YXIgbCA9IG92ZXJsYXBzLmxlbmd0aDtcblxuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gb3ZlcmxhcHNbbF07XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgdXNlIGJvZHkgaWQncyBmb3IgdGhlIGFjY3VtdWxhdG9yLCB0aGVzZSB3aWxsIGJlIGEgc3Vic2V0IG9mIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAgYWNjdW11bGF0b3Iuc2V0KGRhdGEuYm9keUEuaWR8MCwgZGF0YS5ib2R5Qi5pZHwwLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsID0gYWNjdW11bGF0b3Iua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhLmJvZHlBLCBkYXRhLmJvZHlCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjY3VtdWxhdG9yLnJlc2V0KCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuL092ZXJsYXBLZWVwZXJSZWNvcmRcIjo1MyxcIi4vT3ZlcmxhcEtlZXBlclJlY29yZFBvb2xcIjo1NCxcIi4vVHVwbGVEaWN0aW9uYXJ5XCI6NTYsXCIuL1V0aWxzXCI6NTd9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmQ7XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG5cbn0se31dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gX2RlcmVxXygnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgUG9vbCA9IF9kZXJlcV8oJy4vUG9vbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wucHJvdG90eXBlID0gbmV3IFBvb2woKTtcbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtPdmVybGFwS2VlcGVyUmVjb3JkfVxuICovXG5PdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge092ZXJsYXBLZWVwZXJSZWNvcmR9IHJlY29yZFxuICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZFBvb2x9XG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuXHRyZWNvcmQuYm9keUEgPSByZWNvcmQuYm9keUIgPSByZWNvcmQuc2hhcGVBID0gcmVjb3JkLnNoYXBlQiA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuL092ZXJsYXBLZWVwZXJSZWNvcmRcIjo1MyxcIi4vUG9vbFwiOjU1fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBQb29sO1xuXG4vKipcbiAqIEBjbGFzcyBPYmplY3QgcG9vbGluZyB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBQb29sKG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0dGhpcy5vYmplY3RzID0gW107XG5cblx0aWYob3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQpe1xuXHRcdHRoaXMucmVzaXplKG9wdGlvbnMuc2l6ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYsIGZvciBjaGFpbmluZ1xuICovXG5Qb29sLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHR2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcblxuXHR3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XG5cdFx0b2JqZWN0cy5wb3AoKTtcblx0fVxuXG5cdHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcblx0XHRvYmplY3RzLnB1c2godGhpcy5jcmVhdGUoKSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCBmcm9tIHRoZSBwb29sIG9yIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAqIEBtZXRob2QgZ2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG5cdHJldHVybiBvYmplY3RzLmxlbmd0aCA/IG9iamVjdHMucG9wKCkgOiB0aGlzLmNyZWF0ZSgpO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBhbmQgcHV0IHRoZSBvYmplY3QgYmFjayBpbnRvIHRoZSBwb29sIGZvciBsYXRlciB1c2UuXG4gKiBAbWV0aG9kIHJlbGVhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1Bvb2x9IFNlbGYgZm9yIGNoYWluaW5nXG4gKi9cblBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdHRoaXMuZGVzdHJveShvYmplY3QpO1xuXHR0aGlzLm9iamVjdHMucHVzaChvYmplY3QpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbn0se31dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4vVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbi8qKlxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBLZXlzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGtleXNcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBnaXZlbiB0d28gaW50ZWdlcnNcbiAqIEBtZXRob2QgZ2V0S2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge251bWJlcn0galxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGlkMSwgaWQyKSB7XG4gICAgaWQxID0gaWQxfDA7XG4gICAgaWQyID0gaWQyfDA7XG5cbiAgICBpZiAoIChpZDF8MCkgPT09IChpZDJ8MCkgKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XG4gICAgcmV0dXJuICgoaWQxfDApID4gKGlkMnwwKSA/XG4gICAgICAgIChpZDEgPDwgMTYpIHwgKGlkMiAmIDB4RkZGRikgOlxuICAgICAgICAoaWQyIDw8IDE2KSB8IChpZDEgJiAweEZGRkYpKXwwXG4gICAgICAgIDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRCeUtleVxuICogQHBhcmFtICB7TnVtYmVyfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRCeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IGtleXwwO1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRLZXkoaSwgaildO1xufTtcblxuLyoqXG4gKiBTZXQgYSB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZighdmFsdWUpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoaSwgaik7XG5cbiAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICBpZighdGhpcy5kYXRhW2tleV0pe1xuICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleXNbbF1dO1xuICAgIH1cblxuICAgIGtleXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkaWN0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMua2V5cywgZGljdC5rZXlzKTtcbiAgICB2YXIgbCA9IGRpY3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGRpY3Qua2V5c1tsXTtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkaWN0LmRhdGFba2V5XTtcbiAgICB9XG59O1xuXG59LHtcIi4vVXRpbHNcIjo1N31dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDwvc2NyaXB0PlxuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj48L3NjcmlwdD5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbn0se31dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kO1xuXG4vKipcbiAqIEFuIGlzbGFuZCBvZiBib2RpZXMgY29ubmVjdGVkIHdpdGggZXF1YXRpb25zLlxuICogQGNsYXNzIElzbGFuZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElzbGFuZCgpe1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgaXNsYW5kIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuYm9kaWVzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgYm9keUlkcyA9IFtdO1xuXG4vKipcbiAqIEdldCBhbGwgdW5pcXVlIGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAqIEBtZXRob2QgZ2V0Qm9kaWVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgQm9keVxuICovXG5Jc2xhbmQucHJvdG90eXBlLmdldEJvZGllcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIGJvZGllcyA9IHJlc3VsdCB8fCBbXSxcbiAgICAgICAgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgYm9keUlkcy5sZW5ndGggPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpIT09ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUEuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUEpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlBLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUIuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUIpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlCLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9kaWVzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZW50aXJlIGlzbGFuZCB3YW50cyB0byBzbGVlcC5cbiAqIEBtZXRob2Qgd2FudHNUb1NsZWVwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Jc2xhbmQucHJvdG90eXBlLndhbnRzVG9TbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJiAhYi53YW50c1RvU2xlZXApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYWtlIGFsbCBib2RpZXMgaW4gdGhlIGlzbGFuZCBzbGVlcC5cbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBiLnNsZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuLi9vYmplY3RzL0JvZHlcIjozMX1dLDU5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBJc2xhbmQgPSBfZGVyZXFfKCcuL0lzbGFuZCcpXG4sICAgSXNsYW5kTm9kZSA9IF9kZXJlcV8oJy4vSXNsYW5kTm9kZScpXG4sICAgSXNsYW5kTm9kZVBvb2wgPSBfZGVyZXFfKCcuLy4uL3V0aWxzL0lzbGFuZE5vZGVQb29sJylcbiwgICBJc2xhbmRQb29sID0gX2RlcmVxXygnLi8uLi91dGlscy9Jc2xhbmRQb29sJylcbiwgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kTWFuYWdlcjtcblxuLyoqXG4gKiBTcGxpdHMgdGhlIHN5c3RlbSBvZiBib2RpZXMgYW5kIGVxdWF0aW9ucyBpbnRvIGluZGVwZW5kZW50IGlzbGFuZHNcbiAqXG4gKiBAY2xhc3MgSXNsYW5kTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTWFuYWdlcihvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBub2RlUG9vbFxuICAgICAqIEB0eXBlIHtJc2xhbmROb2RlUG9vbH1cbiAgICAgKi9cbiAgICB0aGlzLm5vZGVQb29sID0gbmV3IElzbGFuZE5vZGVQb29sKHsgc2l6ZTogMTYgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaXNsYW5kUG9vbFxuICAgICAqIEB0eXBlIHtJc2xhbmRQb29sfVxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kUG9vbCA9IG5ldyBJc2xhbmRQb29sKHsgc2l6ZTogOCB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcXVhdGlvbnMgdG8gc3BsaXQuIE1hbnVhbGx5IGZpbGwgdGhpcyBhcnJheSBiZWZvcmUgcnVubmluZyAuc3BsaXQoKS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyB7eyNjcm9zc0xpbmsgXCJJc2xhbmRcIn19e3svY3Jvc3NMaW5rfX1zLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGlzbGFuZHNcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZ3JhcGggbm9kZXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbm9kZXNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBxdWV1ZSwgdXNlZCB3aGVuIHRyYXZlcnNpbmcgdGhlIGdyYXBoIG9mIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcXVldWVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIHVudmlzaXRlZCBub2RlIGZyb20gYSBsaXN0IG9mIG5vZGVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRVbnZpc2l0ZWROb2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gbm9kZXNcbiAqIEByZXR1cm4ge0lzbGFuZE5vZGV8Ym9vbGVhbn0gVGhlIG5vZGUgaWYgZm91bmQsIGVsc2UgZmFsc2UuXG4gKi9cbklzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZSA9IGZ1bmN0aW9uKG5vZGVzKXtcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmIG5vZGUuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBWaXNpdCBhIG5vZGUuXG4gKiBAbWV0aG9kIHZpc2l0XG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzXG4gKiBAcGFyYW0gIHtBcnJheX0gZXFzXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXF1YXRpb25zLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXF1YXRpb25zW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXsgLy8gQWxyZWFkeSBhZGRlZD9cbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgc2VhcmNoIGFsZ29yaXRobSwgc3RhcnRpbmcgYXQgYSByb290IG5vZGUuIFRoZSByZXN1bHRpbmcgYm9kaWVzIGFuZCBlcXVhdGlvbnMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAqIEBtZXRob2QgYmZzXG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSByb290IFRoZSBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSAge0FycmF5fSBiZHMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgQm9kaWVzIHRvLlxuICogQHBhcmFtICB7QXJyYXl9IGVxcyAgQW4gYXJyYXkgdG8gYXBwZW5kIHJlc3VsdGluZyBFcXVhdGlvbnMgdG8uXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLmJmcyA9IGZ1bmN0aW9uKHJvb3QsYmRzLGVxcyl7XG5cbiAgICAvLyBSZXNldCB0aGUgdmlzaXQgcXVldWVcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgcm9vdCBub2RlIHRvIHF1ZXVlXG4gICAgcXVldWUucHVzaChyb290KTtcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHRoaXMudmlzaXQocm9vdCxiZHMsZXFzKTtcblxuICAgIC8vIFByb2Nlc3MgYWxsIHF1ZXVlZCBub2Rlc1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuXG4gICAgICAgIC8vIEdldCBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gVmlzaXQgdW52aXNpdGVkIG5laWdoYm9yaW5nIG5vZGVzXG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGUubmVpZ2hib3JzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCxiZHMsZXFzKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIGlmIGl0J3MgZHluYW1pY1xuICAgICAgICAgICAgaWYoY2hpbGQuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgd29ybGQgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiAuaXNsYW5kcy5cbiAqIEBtZXRob2Qgc3BsaXRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9IFRoZSBnZW5lcmF0ZWQgaXNsYW5kc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBub2RlcyA9IHRoaXMubm9kZXMsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zO1xuXG4gICAgLy8gTW92ZSBvbGQgbm9kZXMgdG8gdGhlIG5vZGUgcG9vbFxuICAgIHdoaWxlKG5vZGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubm9kZVBvb2wucmVsZWFzZShub2Rlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlUG9vbC5nZXQoKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAvLyBpZih0aGlzLm5vZGVQb29sLmxlbmd0aCl7XG4gICAgICAgIC8vICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVBvb2wucG9wKCk7XG4gICAgICAgIC8vICAgICBub2RlLnJlc2V0KCk7XG4gICAgICAgIC8vICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIC8vICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgbm9kZXMucHVzaChuZXcgSXNsYW5kTm9kZShib2RpZXNbaV0pKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb25uZWN0aXZpdHkgZGF0YS4gRWFjaCBlcXVhdGlvbiBjb25uZWN0cyAyIGJvZGllcy5cbiAgICBmb3IodmFyIGs9MDsgayE9PWVxdWF0aW9ucy5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJvZHlBKSxcbiAgICAgICAgICAgIGo9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUIpLFxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcbiAgICAgICAgbmkubmVpZ2hib3JzLnB1c2gobmopO1xuICAgICAgICBuai5uZWlnaGJvcnMucHVzaChuaSk7XG4gICAgICAgIG5pLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgbmouZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgb2xkIGlzbGFuZHMgdG8gdGhlIGlzbGFuZCBwb29sXG4gICAgdmFyIGlzbGFuZHMgPSB0aGlzLmlzbGFuZHM7XG4gICAgZm9yKHZhciBpPTA7IGk8aXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuaXNsYW5kUG9vbC5yZWxlYXNlKGlzbGFuZHNbaV0pO1xuICAgIH1cbiAgICBpc2xhbmRzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBHZXQgaXNsYW5kc1xuICAgIHZhciBjaGlsZDtcbiAgICB3aGlsZSgoY2hpbGQgPSBJc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpc2xhbmRcbiAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kUG9vbC5nZXQoKTtcblxuICAgICAgICAvLyBHZXQgYWxsIGVxdWF0aW9ucyBhbmQgYm9kaWVzIGluIHRoaXMgaXNsYW5kXG4gICAgICAgIHRoaXMuYmZzKGNoaWxkLCBpc2xhbmQuYm9kaWVzLCBpc2xhbmQuZXF1YXRpb25zKTtcblxuICAgICAgICBpc2xhbmRzLnB1c2goaXNsYW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNsYW5kcztcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4vLi4vdXRpbHMvSXNsYW5kTm9kZVBvb2xcIjo1MCxcIi4vLi4vdXRpbHMvSXNsYW5kUG9vbFwiOjUxLFwiLi9Jc2xhbmRcIjo1OCxcIi4vSXNsYW5kTm9kZVwiOjYwfV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlO1xuXG4vKipcbiAqIEhvbGRzIGEgYm9keSBhbmQga2VlcHMgdHJhY2sgb2Ygc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgbmVlZGVkIGZvciBncmFwaCB0cmF2ZXJzYWwuXG4gKiBAY2xhc3MgSXNsYW5kTm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZShib2R5KXtcblxuXHQvKipcblx0ICogVGhlIGJvZHkgdGhhdCBpcyBjb250YWluZWQgaW4gdGhpcyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8qKlxuICAgICAqIE5laWdoYm9yaW5nIElzbGFuZE5vZGVzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbmVpZ2hib3JzXG4gICAgICovXG4gICAgdGhpcy5uZWlnaGJvcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG5vZGUgd2FzIHZpc2l0aW5nIGR1cmluZyB0aGUgZ3JhcGggdHJhdmVyc2FsLlxuICAgICAqIEBwcm9wZXJ0eSB2aXNpdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogQ2xlYW4gdGhpcyBub2RlIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZE5vZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHRoaXMubmVpZ2hib3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciAgR1NTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvR1NTb2x2ZXInKVxuLCAgICBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJylcbiwgICAgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gX2RlcmVxXygnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gX2RlcmVxXygnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IF9kZXJlcV8oJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gX2RlcmVxXygnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IF9kZXJlcV8oJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG4vKipcbiAqIFRoZSBkeW5hbWljcyB3b3JsZCwgd2hlcmUgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMgbGl2ZS5cbiAqXG4gKiBAY2xhc3MgV29ybGRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl0gRGVmYXVsdHMgdG8gR1NTb2x2ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5ncmF2aXR5XSBEZWZhdWx0cyB0byB5PS05Ljc4LlxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXSBEZWZhdWx0cyB0byBTQVBCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzbGFuZFNwbGl0PXRydWVdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtMTBdLFxuICogICAgICAgICBicm9hZHBoYXNlOiBuZXcgU0FQQnJvYWRwaGFzZSgpXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShuZXcgQm9keSgpKTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eSBpcyB6ZXJvLCBhbmQgLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5PXRydWUsIHRoZW4gc3dpdGNoIHRvIHVzaW5nIC5mcmljdGlvbkdyYXZpdHkgZm9yIGZyaWN0aW9uIGluc3RlYWQuIFRoaXMgZmFsbGJhY2sgaXMgdXNlZnVsIGZvciBncmF2aXR5bGVzcyBnYW1lcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnJvYWRwaGFzZVxuICAgICAqIEB0eXBlIHtCcm9hZHBoYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRwaGFzZSA9IG9wdGlvbnMuYnJvYWRwaGFzZSB8fCBuZXcgU0FQQnJvYWRwaGFzZSgpO1xuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHVtbXkgZGVmYXVsdCBtYXRlcmlhbCBpbiB0aGUgd29ybGQsIHVzZWQgaW4gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBkZWZhdWx0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbCB0byB1c2UsIGlmIG5vIGNvbnRhY3QgbWF0ZXJpYWwgd2FzIHNldCBmb3IgdGhlIGNvbGxpZGluZyBtYXRlcmlhbHMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0TWF0ZXJpYWx9IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKHRoaXMuZGVmYXVsdE1hdGVyaWFsLHRoaXMuZGVmYXVsdE1hdGVyaWFsKTtcblxuICAgIC8qKlxuICAgICAqIEZvciBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgdGltZSBzdGVwIHNpemUgd2UgdXNlZCBsYXN0IHN0ZXBcbiAgICAgKiBAcHJvcGVydHkgbGFzdFRpbWVTdGVwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBzcHJpbmcgZm9yY2VzIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlTcHJpbmdGb3JjZXNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseURhbXBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5R3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBjb25zdHJhaW50IHNvbHZpbmcgaW4gZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZUNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyBzdGVwKCkuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEJvZGllcyB0aGF0IGFyZSBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJvZGllc1RvQmVSZW1vdmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpc2xhbmQgc3BsaXR0aW5nLiBJc2xhbmQgc3BsaXR0aW5nIGNhbiBiZSBhbiBhZHZhbnRhZ2UgZm9yIGJvdGggcHJlY2lzaW9uIGFuZCBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZFNwbGl0ID0gdHlwZW9mKG9wdGlvbnMuaXNsYW5kU3BsaXQpIT09XCJ1bmRlZmluZWRcIiA/ICEhb3B0aW9ucy5pc2xhbmRTcGxpdCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbWl0SW1wYWN0RXZlbnQgPSB0cnVlO1xuXG4gICAgLy8gSWQgY291bnRlcnNcbiAgICB0aGlzLl9jb25zdHJhaW50SWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9ib2R5SWRDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGFmdGVyIHRoZSBzdGVwKCkuXG4gICAgICogQGV2ZW50IHBvc3RTdGVwXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcEV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJwb3N0U3RlcFwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXG4gICAgICogQGV2ZW50IGltcGFjdFxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5pbXBhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJpbXBhY3RcIixcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbiA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxuICAgICAqIEluc2lkZSB0aGUgZXZlbnQgaGFuZGxlciwgeW91IGNhbiBtb2RpZnkgdGhlIHBhaXJzIGFycmF5IGFzIHlvdSBsaWtlLCB0b1xuICAgICAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIG9iamVjdHMgdGhhdCB5b3UgZG9uJ3Qgd2FudC5cbiAgICAgKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiBjb2xsaXNpb24gcGFpcnMuIElmIHRoaXMgYXJyYXkgaXMgW2JvZHkxLGJvZHkyLGJvZHkzLGJvZHk0XSwgdGhlbiB0aGUgYm9keSBwYWlycyAxLDIgYW5kIDMsNCB3b3VsZCBhZHZhbmNlIHRvIG5hcnJvd3BoYXNlLlxuICAgICAqL1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwb3N0QnJvYWRwaGFzZVwiLFxuICAgICAgICBwYWlyczogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xuICAgICAqL1xuICAgIHRoaXMuc2xlZXBNb2RlID0gV29ybGQuTk9fU0xFRVBJTkc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RhcnRzIHN0YXJ0IHRvIG92ZXJsYXAuIEZpcmVkIGluIHRoZSBuYXJyb3dwaGFzZSwgZHVyaW5nIHN0ZXAuXG4gICAgICogQGV2ZW50IGJlZ2luQ29udGFjdFxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5iZWdpbkNvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbCxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczogW11cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuZW5kQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBlcXVhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIgdG8gYmUgc29sdmVkLiBDYW4gYmUgdXNlZCB0byBjb250cm9sIHdoYXQgZXF1YXRpb25zIGdvZXMgaW50byB0aGUgc29sdmVyLlxuICAgICAqIEBldmVudCBwcmVTb2x2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnMgIEFuIGFycmF5IG9mIGNvbnRhY3RzIHRvIGJlIHNvbHZlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmcmljdGlvbkVxdWF0aW9ucyBBbiBhcnJheSBvZiBmcmljdGlvbiBlcXVhdGlvbnMgdG8gYmUgc29sdmVkLlxuICAgICAqL1xuICAgIHRoaXMucHJlU29sdmVFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwcmVTb2x2ZVwiLFxuICAgICAgICBjb250YWN0RXF1YXRpb25zOiBudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczogbnVsbFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtPdmVybGFwS2VlcGVyfSBvdmVybGFwS2VlcGVyXG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpe1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbn07XG5cbi8qKlxuICogQWRkIGEgQ29udGFjdE1hdGVyaWFsIHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjb250YWN0TWF0ZXJpYWxcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNvbnRhY3RNYXRlcmlhbCl7XG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWxcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjbSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29udGFjdE1hdGVyaWFscy5pbmRleE9mKGNtKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnRhY3RNYXRlcmlhbHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cbiAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWxBLG1hdGVyaWFsQil7XG4gICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT0wLCBOPWNtYXRzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBjbSA9IGNtYXRzW2ldO1xuICAgICAgICBpZiggKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxBLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEIuaWQpIHx8XG4gICAgICAgICAgICAoY20ubWF0ZXJpYWxBLmlkID09PSBtYXRlcmlhbEIuaWQpICYmIChjbS5tYXRlcmlhbEIuaWQgPT09IG1hdGVyaWFsQS5pZCkgKXtcbiAgICAgICAgICAgIHJldHVybiBjbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKlxuICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb25zdHJhaW50KXtcbiAgICB2YXIgaWR4ID0gdGhpcy5jb25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuY29uc3RyYWludHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbnZhciBzdGVwX3IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfcnVuaXQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdSA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9mID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX2ZoTWludiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfbWcgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhpdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHhqdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHplcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBpbnRlcnB2ZWxvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFNpbXBsZSBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIGZpeGVkVGltZVN0ZXAgPSAxIC8gNjA7XG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqXG4gKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCk7XG4gKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEZpeGVkIHRpbWVzdGVwcGluZyB3aXRoIGludGVycG9sYXRpb25cbiAqICAgICB2YXIgbWF4U3ViU3RlcHMgPSAxMDtcbiAqICAgICB2YXIgbGFzdFRpbWVTZWNvbmRzO1xuICpcbiAqICAgICBmdW5jdGlvbiBhbmltYXRlKHQpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHRpbWVTZWNvbmRzID0gdCAvIDEwMDA7XG4gKiAgICAgICAgIGxhc3RUaW1lU2Vjb25kcyA9IGxhc3RUaW1lU2Vjb25kcyB8fCB0aW1lU2Vjb25kcztcbiAqXG4gKiAgICAgICAgIGRlbHRhVGltZSA9IHRpbWVTZWNvbmRzIC0gbGFzdFRpbWVTZWNvbmRzO1xuICogICAgICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXAsIGRlbHRhVGltZSwgbWF4U3ViU3RlcHMpO1xuICpcbiAqICAgICAgICAgcmVuZGVyQm9keShib2R5LmludGVycG9sYXRlZFBvc2l0aW9uLCBib2R5LmludGVycG9sYXRlZEFuZ2xlKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBsb29wXG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICpcbiAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsdGltZVNpbmNlTGFzdENhbGxlZCxtYXhTdWJTdGVwcyl7XG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgaWYodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCl7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcblxuICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG4gICAgICAgIHZhciBzdWJzdGVwcyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHtcbiAgICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0O1xuICAgICAgICAgICAgc3Vic3RlcHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT10aGlzLmJvZGllcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xuICAgICAgICAgICAgdmVjMi5sZXJwKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbiwgYi5wb3NpdGlvbiwgdCk7XG4gICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5wcmV2aW91c0FuZ2xlICsgdCAqIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBlbmRPdmVybGFwcyA9IFtdO1xuXG4vKipcbiAqIE1ha2UgYSBmaXhlZCBzdGVwLlxuICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcbiAqIEBwcml2YXRlXG4gKi9cbldvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbihkdCl7XG4gICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxuICAgIGlmKHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkpe1xuICAgICAgICB2YXIgZ3Jhdml0eUxlbiA9IHZlYzIubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XG4gICAgICAgIGlmKCEoZ3Jhdml0eUxlbiA9PT0gMCAmJiB0aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkpKXtcbiAgICAgICAgICAgIC8vIE5vbnplcm8gZ3Jhdml0eS4gVXNlIGl0LlxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSBncmF2aXR5TGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXG4gICAgaWYodGhpcy5hcHBseUdyYXZpdHkpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBmaSA9IGIuZm9yY2U7XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuRFlOQU1JQyB8fCBiLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMi5zY2FsZShtZyxnLGIubWFzcypiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXG4gICAgICAgICAgICBhZGQoZmksZmksbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcbiAgICBpZih0aGlzLmFwcGx5U3ByaW5nRm9yY2VzKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1Oc3ByaW5nczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzID0gc3ByaW5nc1tpXTtcbiAgICAgICAgICAgIHMuYXBwbHlGb3JjZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5hcHBseURhbXBpbmcpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBiLmFwcGx5RGFtcGluZyhkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCcm9hZHBoYXNlXG4gICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XG5cbiAgICAvLyBSZW1vdmUgaWdub3JlZCBjb2xsaXNpb24gcGFpcnNcbiAgICB2YXIgaWdub3JlZFBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcbiAgICBmb3IodmFyIGk9aWdub3JlZFBhaXJzLmxlbmd0aC0yOyBpPj0wOyBpLT0yKXtcbiAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICBpZiggKGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgIChpZ25vcmVkUGFpcnNbaSsxXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbaisxXSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb25zdHJhaW5lZCBwYWlycyB3aXRoIGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2VcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XG4gICAgICAgIGlmKCFjLmNvbGxpZGVDb25uZWN0ZWQpe1xuICAgICAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSByZXN1bHRbal0gJiYgYy5ib2R5QiA9PT0gcmVzdWx0W2orMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvc3RCcm9hZHBoYXNlIGV2ZW50XG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQpO1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IG51bGw7XG5cbiAgICAvLyBOYXJyb3dwaGFzZVxuICAgIG5wLnJlc2V0KHRoaXMpO1xuICAgIGZvcih2YXIgaT0wLCBOcmVzdWx0cz1yZXN1bHQubGVuZ3RoOyBpIT09TnJlc3VsdHM7IGkrPTIpe1xuICAgICAgICB2YXIgYmkgPSByZXN1bHRbaV0sXG4gICAgICAgICAgICBiaiA9IHJlc3VsdFtpKzFdO1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxuICAgICAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ymkuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICAgICAgdmFyIHNpID0gYmkuc2hhcGVzW2tdLFxuICAgICAgICAgICAgICAgIHhpID0gc2kucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgYWkgPSBzaS5hbmdsZTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IHNqLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhaiA9IHNqLmFuZ2xlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG1wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OYXJyb3dwaGFzZShucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSx0aGlzLmZyaWN0aW9uR3Jhdml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2Upe1xuICAgICAgICAgICAgYm9keS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXG4gICAgaWYodGhpcy5oYXMoJ2VuZENvbnRhY3QnKSl7XG4gICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XG4gICAgICAgIHZhciBlID0gdGhpcy5lbmRDb250YWN0RXZlbnQ7XG4gICAgICAgIHZhciBsID0gZW5kT3ZlcmxhcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShsLS0pe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcbiAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XG4gICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xuICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XG4gICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcbiAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRPdmVybGFwcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHZhciBwcmVTb2x2ZUV2ZW50ID0gdGhpcy5wcmVTb2x2ZUV2ZW50O1xuICAgIHByZVNvbHZlRXZlbnQuY29udGFjdEVxdWF0aW9ucyA9IG5wLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIHRoaXMuZW1pdChwcmVTb2x2ZUV2ZW50KTtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBwcmVTb2x2ZUV2ZW50LmZyaWN0aW9uRXF1YXRpb25zID0gbnVsbDtcblxuICAgIC8vIHVwZGF0ZSBjb25zdHJhaW50IGVxdWF0aW9uc1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgY29uc3RyYWludHNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYobnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggfHwgbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIHx8IE5jb25zdHJhaW50cyl7XG4gICAgICAgIGlmKHRoaXMuaXNsYW5kU3BsaXQpe1xuICAgICAgICAgICAgLy8gU3BsaXQgaW50byBpc2xhbmRzXG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLnNwbGl0KHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWlzbGFuZE1hbmFnZXIuaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZCA9IGlzbGFuZE1hbmFnZXIuaXNsYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZUlzbGFuZChkdCxpc2xhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBBZGQgY29udGFjdCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5mcmljdGlvbkVxdWF0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB1c2VyLWRlZmluZWQgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNvbHZlQ29uc3RyYWludHMpe1xuICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCx0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCBmb3J3YXJkXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAvLyBpZihib2R5LnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keS50eXBlICE9PSBCb2R5LlNUQVRJQyl7XG4gICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGZvcmNlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICBib2RpZXNbaV0uc2V0WmVyb0ZvcmNlKCk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgdmFyIGJvZGllc1RvQmVSZW1vdmVkID0gdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1RvQmVSZW1vdmVkW2ldKTtcbiAgICB9XG4gICAgYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RTdGVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSdW5zIG5hcnJvd3BoYXNlIGZvciB0aGUgc2hhcGUgcGFpciBpIGFuZCBqLlxuICogQG1ldGhvZCBydW5OYXJyb3dwaGFzZVxuICogQHBhcmFtICB7TmFycm93cGhhc2V9IG5wXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7U2hhcGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICogQHBhcmFtICB7TnVtYmVyfSBtdVxuICovXG5Xb3JsZC5wcm90b3R5cGUucnVuTmFycm93cGhhc2UgPSBmdW5jdGlvbihucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSxnbGVuKXtcblxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXG4gICAgaWYoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHdvcmxkIHBvc2l0aW9uIGFuZCBhbmdsZSBvZiBlYWNoIHNoYXBlXG4gICAgdmVjMi5yb3RhdGUoeGl3LCB4aSwgYmkuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHhqdywgeGosIGJqLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh4aXcsIHhpdywgYmkucG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKHhqdywgeGp3LCBiai5wb3NpdGlvbik7XG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XG4gICAgdmFyIGFqdyA9IGFqICsgYmouYW5nbGU7XG5cbiAgICBucC5lbmFibGVGcmljdGlvbiA9IGNtLmZyaWN0aW9uID4gMDtcbiAgICBucC5mcmljdGlvbkNvZWZmaWNpZW50ID0gY20uZnJpY3Rpb247XG4gICAgdmFyIHJlZHVjZWRNYXNzO1xuICAgIGlmKGJpLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IGJpLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiai5tYXNzO1xuICAgIH0gZWxzZSBpZihiai50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiai50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmkubWFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y2VkTWFzcyA9IChiaS5tYXNzKmJqLm1hc3MpLyhiaS5tYXNzK2JqLm1hc3MpO1xuICAgIH1cbiAgICBucC5zbGlwRm9yY2UgPSBjbS5mcmljdGlvbipnbGVuKnJlZHVjZWRNYXNzO1xuICAgIG5wLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG4gICAgbnAuc3VyZmFjZVZlbG9jaXR5ID0gY20uc3VyZmFjZVZlbG9jaXR5O1xuICAgIG5wLmZyaWN0aW9uU3RpZmZuZXNzID0gY20uZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgbnAuZnJpY3Rpb25SZWxheGF0aW9uID0gY20uZnJpY3Rpb25SZWxheGF0aW9uO1xuICAgIG5wLnN0aWZmbmVzcyA9IGNtLnN0aWZmbmVzcztcbiAgICBucC5yZWxheGF0aW9uID0gY20ucmVsYXhhdGlvbjtcbiAgICBucC5jb250YWN0U2tpblNpemUgPSBjbS5jb250YWN0U2tpblNpemU7XG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgdmFyIHJlc29sdmVyID0gbnBbc2kudHlwZSB8IHNqLnR5cGVdLFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG4gICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBzZW5zb3IgPSBzaS5zZW5zb3IgfHwgc2ouc2Vuc29yO1xuICAgICAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaSxzaSx4aXcsYWl3LCBiaixzaix4ancsYWp3LCBzZW5zb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaixzaix4ancsYWp3LCBiaSxzaSx4aXcsYWl3LCBzZW5zb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1GcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCAtIG51bUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgICAgIGlmKG51bUNvbnRhY3RzKXtcblxuICAgICAgICAgICAgaWYoIGJpLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoYmoudmVsb2NpdHkpICsgTWF0aC5wb3coYmouYW5ndWxhclZlbG9jaXR5LDIpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIqMil7XG4gICAgICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJpLnZlbG9jaXR5KSArIE1hdGgucG93KGJpLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgICAgICBiai5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xuICAgICAgICAgICAgaWYodGhpcy5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHRoaXMub3ZlcmxhcEtlZXBlci5pc05ld092ZXJsYXAoc2ksIHNqKSl7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgbmV3IHNoYXBlIG92ZXJsYXBcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuYmVnaW5Db250YWN0RXZlbnQ7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUEgPSBzaTtcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IHNqO1xuICAgICAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGgtbnVtQ29udGFjdHM7IGk8bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMucHVzaChucC5jb250YWN0RXF1YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGl2aWRlIHRoZSBtYXggZnJpY3Rpb24gZm9yY2UgYnkgdGhlIG51bWJlciBvZiBjb250YWN0c1xuICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIgJiYgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPiAxKXsgLy8gV2h5IGRpdmlkZSBieSAxP1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT1ucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGgtbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGk8bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5wLmZyaWN0aW9uRXF1YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBmLnNldFNsaXBGb3JjZShmLmdldFNsaXBGb3JjZSgpIC8gbnVtRnJpY3Rpb25FcXVhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZFNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkU3ByaW5nID0gZnVuY3Rpb24oc3ByaW5nKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzcHJpbmcpO1xuICAgIHZhciBldnQgPSB0aGlzLmFkZFNwcmluZ0V2ZW50O1xuICAgIGV2dC5zcHJpbmcgPSBzcHJpbmc7XG4gICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgZXZ0LnNwcmluZyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNwcmluZ1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlU3ByaW5nXG4gKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVTcHJpbmcgPSBmdW5jdGlvbihzcHJpbmcpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzcHJpbmcpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5zcHJpbmdzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXG4gKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKiBAdG9kbyBXaGF0IGlmIHRoaXMgaXMgZG9uZSBkdXJpbmcgc3RlcD9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpID09PSAtMSl7XG4gICAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgICAgICB2YXIgZXZ0ID0gdGhpcy5hZGRCb2R5RXZlbnQ7XG4gICAgICAgIGV2dC5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgICAgIGV2dC5ib2R5ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi4gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZyBzdGVwKCksIHRoZSBib2R5IHJlbW92YWwgaXMgc2NoZWR1bGVkIHRvIGFmdGVyIHRoZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oYm9keSl7XG4gICAgaWYodGhpcy5zdGVwcGluZyl7XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQucHVzaChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LndvcmxkID0gbnVsbDtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmJvZGllcyxpZHgsMSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcbiAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQm9keUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGlzYWJsZUJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG4gICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlBLGJvZHlCKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBlbmFibGVCb2R5Q29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPTA7IGk8cGFpcnMubGVuZ3RoOyBpKz0yKXtcbiAgICAgICAgaWYoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpKzFdID09PSBib2R5QikgfHwgKHBhaXJzW2krMV0gPT09IGJvZHlBICYmIHBhaXJzW2ldID09PSBib2R5Qikpe1xuICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksMik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgV29ybGQsIHJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIHNwcmluZ3MuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50aW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG52YXIgaGl0VGVzdF90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBoaXRUZXN0X3plcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBoaXRUZXN0X3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBUZXN0IGlmIGEgd29ybGQgcG9pbnQgb3ZlcmxhcHMgYm9kaWVzXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSAge0FycmF5fSAgd29ybGRQb2ludCAgUG9pbnQgdG8gdXNlIGZvciBpbnRlcnNlY3Rpb24gdGVzdHNcbiAqIEBwYXJhbSAge0FycmF5fSAgYm9kaWVzICAgICAgQSBsaXN0IG9mIG9iamVjdHMgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBBcnJheSBvZiBib2RpZXMgdGhhdCBvdmVybGFwIHRoZSBwb2ludFxuICogQHRvZG8gU2hvdWxkIHVzZSBhbiBhcGkgc2ltaWxhciB0byB0aGUgcmF5Y2FzdCBmdW5jdGlvblxuICogQHRvZG8gU2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBhIC5jb250YWluc1BvaW50IG1ldGhvZCBmb3IgYWxsIHNoYXBlcy4gV291bGQgYmUgbW9yZSBlZmZpY2llbnRcbiAqIEB0b2RvIFNob3VsZCB1c2UgdGhlIGJyb2FkcGhhc2VcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MCwgTlM9Yi5zaGFwZXMubGVuZ3RoOyBqIT09TlM7IGorKyl7XG4gICAgICAgICAgICB2YXIgcyA9IGIuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcG9zaXRpb24gKyBhbmdsZVxuICAgICAgICAgICAgdmVjMi5yb3RhdGUoeCwgcy5wb3NpdGlvbiwgYi5hbmdsZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh4LCB4LCBiLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBhID0gcy5hbmdsZSArIGIuYW5nbGU7XG5cbiAgICAgICAgICAgIGlmKCAocyBpbnN0YW5jZW9mIENpcmNsZSAgICAmJiBuLmNpcmNsZVBhcnRpY2xlICAoYixzLHgsYSwgICAgIHBiLHBzLHB4LHBhLCB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENvbnZleCAgICAmJiBuLnBhcnRpY2xlQ29udmV4ICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBsYW5lICAgICAmJiBuLnBhcnRpY2xlUGxhbmUgICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENhcHN1bGUgICAmJiBuLnBhcnRpY2xlQ2Fwc3VsZSAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBhcnRpY2xlICAmJiB2ZWMyLnNxdWFyZWRMZW5ndGgodmVjMi5zdWIodG1wLHgsd29ybGRQb2ludCkpIDwgcHJlY2lzaW9uKnByZWNpc2lvbilcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdGlmZm5lc3MgZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb25zdHJhaW50c1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY29udGFjdE1hdGVyaWFscyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbGF4YXRpb24gZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsUmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xufTtcblxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xuICogICAgICAgICBtb2RlOiBSYXkuQ0xPU0VTVCwgLy8gb3IgQU5ZXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gKiAgICAgd29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XG4gKlxuICogICAgIC8vIEdldCB0aGUgaGl0IHBvaW50XG4gKiAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XG4gKiAgICAgY29uc29sZS5sb2coJ0hpdCBwb2ludDogJywgaGl0UG9pbnRbMF0sIGhpdFBvaW50WzFdLCAnIGF0IGRpc3RhbmNlICcgKyByZXN1bHQuZ2V0SGl0RGlzdGFuY2UocmF5KSk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XG4gKiAgICAgICAgIG1vZGU6IFJheS5BTEwsXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihyZXN1bHQpe1xuICpcbiAqICAgICAgICAgICAgIC8vIFByaW50IHNvbWUgaW5mbyBhYm91dCB0aGUgaGl0XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IGJvZHkgYW5kIHNoYXBlOiAnLCByZXN1bHQuYm9keSwgcmVzdWx0LnNoYXBlKTtcbiAqXG4gKiAgICAgICAgICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxuICogICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICAgICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChoaXRQb2ludCwgcmF5KTtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xuICpcbiAqICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgaGFwcHkgd2l0aCB0aGUgaGl0cyB5b3UgZ290IHRoaXMgZmFyLCB5b3UgY2FuIHN0b3AgdGhlIHRyYXZlcnNhbCBoZXJlOlxuICogICAgICAgICAgICAgcmVzdWx0LnN0b3AoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5KXtcblxuICAgIC8vIEdldCBhbGwgYm9kaWVzIHdpdGhpbiB0aGUgcmF5IEFBQkJcbiAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0aGlzLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHRoaXMsIHRtcEFBQkIsIHRtcEFycmF5KTtcbiAgICByYXkuaW50ZXJzZWN0Qm9kaWVzKHJlc3VsdCwgdG1wQXJyYXkpO1xuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gcmVzdWx0Lmhhc0hpdCgpO1xufTtcblxufSx7XCIuLi8uLi9wYWNrYWdlLmpzb25cIjo2LFwiLi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vY29sbGlzaW9uL05hcnJvd3BoYXNlXCI6MTAsXCIuLi9jb2xsaXNpb24vUmF5XCI6MTEsXCIuLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjEzLFwiLi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE0LFwiLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTUsXCIuLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE2LFwiLi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnRcIjoxNyxcIi4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOCxcIi4uL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjE5LFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI2LFwiLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjcsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI4LFwiLi4vbWF0aC92ZWMyXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4uL29iamVjdHMvTGluZWFyU3ByaW5nXCI6MzIsXCIuLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozMyxcIi4uL3NoYXBlcy9DYXBzdWxlXCI6MzgsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzksXCIuLi9zaGFwZXMvQ29udmV4XCI6NDAsXCIuLi9zaGFwZXMvTGluZVwiOjQyLFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDMsXCIuLi9zaGFwZXMvUGxhbmVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuLi91dGlscy9PdmVybGFwS2VlcGVyXCI6NTIsXCIuLi91dGlscy9VdGlsc1wiOjU3LFwiLi9Jc2xhbmRNYW5hZ2VyXCI6NTl9XX0se30sWzM2XSlcbigzNilcbn0pOyIsIi8qKlxuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAY29weXJpZ2h0ICAgIDIwMTYgUGhvdG9uIFN0b3JtIEx0ZC5cbiogQGxpY2Vuc2UgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL21hc3Rlci9saWNlbnNlLnR4dHxNSVQgTGljZW5zZX1cbipcbiogQG92ZXJ2aWV3XG4qXG4qIFBoYXNlciAtIGh0dHA6Ly9waGFzZXIuaW9cbipcbiogdjIuNy43IFwiMjAxNy0wNC0yMFwiIC0gQnVpbHQ6IFdlZCBBcHIgMTkgMjAxNyAyMTo1MTozMFxuKlxuKiBCeSBSaWNoYXJkIERhdmV5IGh0dHA6Ly93d3cucGhvdG9uc3Rvcm0uY29tIEBwaG90b25zdG9ybVxuKlxuKiBQaGFzZXIgaXMgYSBmdW4sIGZyZWUgYW5kIGZhc3QgMkQgZ2FtZSBmcmFtZXdvcmsgZm9yIG1ha2luZyBIVE1MNSBnYW1lc1xuKiBmb3IgZGVza3RvcCBhbmQgbW9iaWxlIHdlYiBicm93c2Vycywgc3VwcG9ydGluZyBDYW52YXMgYW5kIFdlYkdMIHJlbmRlcmluZy5cbipcbiogUGhhc2VyIHVzZXMgUGl4aS5qcyBmb3IgcmVuZGVyaW5nLCBjcmVhdGVkIGJ5IE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20gQERvb3JtYXQyM1xuKiBQaGFzZXIgdXNlcyBwMi5qcyBmb3IgZnVsbC1ib2R5IHBoeXNpY3MsIGNyZWF0ZWQgYnkgU3RlZmFuIEhlZG1hbiBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMgQHNjaHRlcHBlXG4qIFBoYXNlciBjb250YWlucyBhIHBvcnQgb2YgTisgUGh5c2ljcywgY29udmVydGVkIGJ5IFJpY2hhcmQgRGF2ZXksIG9yaWdpbmFsIGJ5IGh0dHA6Ly93d3cubWV0YW5ldHNvZnR3YXJlLmNvbVxuKlxuKiBNYW55IHRoYW5rcyB0byBBZGFtIFNhbHRzbWFuIChAQURBTUFUT01JQykgZm9yIHJlbGVhc2luZyBGbGl4ZWwsIGZyb20gd2hpY2ggYm90aCBQaGFzZXIgYW5kIG15IGxvdmUgb2YgZnJhbWV3b3JrIGRldmVsb3BtZW50IG9yaWdpbmF0ZS5cbipcbiogRm9sbG93IGRldmVsb3BtZW50IGF0IGh0dHA6Ly9waGFzZXIuaW8gYW5kIG9uIG91ciBmb3J1bVxuKlxuKiBcIklmIHlvdSB3YW50IHlvdXIgY2hpbGRyZW4gdG8gYmUgaW50ZWxsaWdlbnQsICByZWFkIHRoZW0gZmFpcnkgdGFsZXMuXCJcbiogXCJJZiB5b3Ugd2FudCB0aGVtIHRvIGJlIG1vcmUgaW50ZWxsaWdlbnQsIHJlYWQgdGhlbSBtb3JlIGZhaXJ5IHRhbGVzLlwiXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBBbGJlcnQgRWluc3RlaW5cbiovXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuKGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXM7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgW3BpeGkuanNdKGh0dHA6Ly93d3cucGl4aWpzLmNvbS8pIG1vZHVsZS9uYW1lc3BhY2UuXG4gKlxuICogQG1vZHVsZSBQSVhJXG4gKi9cbiBcbi8qKlxuICogTmFtZXNwYWNlLWNsYXNzIGZvciBbcGl4aS5qc10oaHR0cDovL3d3dy5waXhpanMuY29tLykuXG4gKlxuICogQ29udGFpbnMgYXNzb3J0ZWQgc3RhdGljIHByb3BlcnRpZXMgYW5kIGVudW1lcmF0aW9ucy5cbiAqXG4gKiBAY2xhc3MgUElYSVxuICogQHN0YXRpY1xuICovXG52YXIgUElYSSA9IFBJWEkgfHwge307XG5cbi8qKlxuKiBAYXV0aG9yICAgICAgIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20gQERvb3JtYXQyM1xuKiBAYXV0aG9yICAgICAgIFJpY2hhcmQgRGF2ZXkgPHJpY2hAcGhvdG9uc3Rvcm0uY29tPlxuKiBAbGljZW5zZSAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvbWFzdGVyL2xpY2Vuc2UudHh0fE1JVCBMaWNlbnNlfVxuKi9cblxuLyoqXG4qIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZC4gQ29udGFpbnMgcHJvcGVydGllcyBmb3IgcG9zaXRpb24sIHNjYWxpbmcsXG4qIHJvdGF0aW9uLCBtYXNrcyBhbmQgY2FjaGUgaGFuZGxpbmcuXG4qXG4qIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBvbiBpdHMgb3duLCByYXRoZXIgaXQgc2hvdWxkIGJlIGV4dGVuZGVkLlxuKlxuKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGxpa2VzIG9mIFBJWEkuU3ByaXRlLlxuKlxuKiBAY2xhc3MgRGlzcGxheU9iamVjdFxuKiBAY29uc3RydWN0b3JcbiovXG5QSVhJLkRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAqIFRoZSBjb29yZGluYXRlcywgaW4gcGl4ZWxzLCBvZiB0aGlzIERpc3BsYXlPYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgY29udGFpbmVyLlxuICAgICpcbiAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGRvZXMgbm90IHJlZmxlY3QgYW55IHBvc2l0aW9uaW5nIGhhcHBlbmluZyBmdXJ0aGVyIHVwIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgKiBUbyBvYnRhaW4gdGhhdCB2YWx1ZSBwbGVhc2Ugc2VlIHRoZSBgd29ybGRQb3NpdGlvbmAgcHJvcGVydHkuXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtQSVhJLlBvaW50fSBwb3NpdGlvblxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUElYSS5Qb2ludCgwLCAwKTtcblxuICAgIC8qKlxuICAgICogVGhlIHNjYWxlIG9mIHRoaXMgRGlzcGxheU9iamVjdC4gQSBzY2FsZSBvZiAxOjEgcmVwcmVzZW50cyB0aGUgRGlzcGxheU9iamVjdFxuICAgICogYXQgaXRzIGRlZmF1bHQgc2l6ZS4gQSB2YWx1ZSBvZiAwLjUgd291bGQgc2NhbGUgdGhpcyBEaXNwbGF5T2JqZWN0IGJ5IGhhbGYsIGFuZCBzbyBvbi5cbiAgICAqXG4gICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCByZWZsZWN0IGFueSBzY2FsaW5nIGhhcHBlbmluZyBmdXJ0aGVyIHVwIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgKiBUbyBvYnRhaW4gdGhhdCB2YWx1ZSBwbGVhc2Ugc2VlIHRoZSBgd29ybGRTY2FsZWAgcHJvcGVydHkuXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtQSVhJLlBvaW50fSBzY2FsZVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgUElYSS5Qb2ludCgxLCAxKTtcblxuICAgIC8qKlxuICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoaXMgRGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kLiBUaGUgdmFsdWVzIGFyZSBleHByZXNzZWRcbiAgICAqIGluIHBpeGVsIHZhbHVlcy5cbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5Qb2ludH0gcGl2b3RcbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLnBpdm90ID0gbmV3IFBJWEkuUG9pbnQoMCwgMCk7XG5cbiAgICAvKipcbiAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGlzIERpc3BsYXlPYmplY3QuIFRoZSB2YWx1ZSBpcyBnaXZlbiwgYW5kIGV4cHJlc3NlZCwgaW4gcmFkaWFucywgYW5kIGlzIGJhc2VkIG9uXG4gICAgKiBhIHJpZ2h0LWhhbmRlZCBvcmllbnRhdGlvbi5cbiAgICAqXG4gICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCByZWZsZWN0IGFueSByb3RhdGlvbiBoYXBwZW5pbmcgZnVydGhlciB1cCB0aGUgZGlzcGxheSBsaXN0LlxuICAgICogVG8gb2J0YWluIHRoYXQgdmFsdWUgcGxlYXNlIHNlZSB0aGUgYHdvcmxkUm90YXRpb25gIHByb3BlcnR5LlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgYWxwaGEgdmFsdWUgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LiBBIHZhbHVlIG9mIDEgaXMgZnVsbHkgb3BhcXVlLiBBIHZhbHVlIG9mIDAgaXMgdHJhbnNwYXJlbnQuXG4gICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGFuIG9iamVjdCB3aXRoIGFuIGFscGhhIHZhbHVlIG9mIDAgaXMgc2tpcHBlZCBkdXJpbmcgdGhlIHJlbmRlciBwYXNzLlxuICAgICpcbiAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGRvZXMgbm90IHJlZmxlY3QgYW55IGFscGhhIHZhbHVlcyBzZXQgZnVydGhlciB1cCB0aGUgZGlzcGxheSBsaXN0LlxuICAgICogVG8gb2J0YWluIHRoYXQgdmFsdWUgcGxlYXNlIHNlZSB0aGUgYHdvcmxkQWxwaGFgIHByb3BlcnR5LlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbHBoYVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGlzIERpc3BsYXlPYmplY3QuIEEgdmFsdWUgb2YgYGZhbHNlYCBtYWtlcyB0aGUgb2JqZWN0IGludmlzaWJsZS5cbiAgICAqIEEgdmFsdWUgb2YgYHRydWVgIG1ha2VzIGl0IHZpc2libGUuIFBsZWFzZSBub3RlIHRoYXQgYW4gb2JqZWN0IHdpdGggYSB2aXNpYmxlIHZhbHVlIG9mXG4gICAgKiBgZmFsc2VgIGlzIHNraXBwZWQgZHVyaW5nIHRoZSByZW5kZXIgcGFzcy4gRXF1YWxseSBhIERpc3BsYXlPYmplY3Qgd2l0aCB2aXNpYmxlIGZhbHNlIHdpbGxcbiAgICAqIG5vdCByZW5kZXIgYW55IG9mIGl0cyBjaGlsZHJlbi5cbiAgICAqXG4gICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCByZWZsZWN0IGFueSB2aXNpYmxlIHZhbHVlcyBzZXQgZnVydGhlciB1cCB0aGUgZGlzcGxheSBsaXN0LlxuICAgICogVG8gb2J0YWluIHRoYXQgdmFsdWUgcGxlYXNlIHNlZSB0aGUgYHdvcmxkVmlzaWJsZWAgcHJvcGVydHkuXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSB2aXNpYmxlXG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmluZWQgYXJlYSB0aGF0IHdpbGwgcGljayB1cCBtb3VzZSAvIHRvdWNoIGV2ZW50cy4gSXQgaXMgbnVsbCBieSBkZWZhdWx0LlxuICAgICAqIFNldHRpbmcgaXQgaXMgYSBuZWF0IHdheSBvZiBvcHRpbWlzaW5nIHRoZSBoaXRUZXN0IGZ1bmN0aW9uIHRoYXQgdGhlIGludGVyYWN0aW9uTWFuYWdlciB3aWxsIHVzZSAoYXMgaXQgd2lsbCBub3QgbmVlZCB0byBoaXQgdGVzdCBhbGwgdGhlIGNoaWxkcmVuKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhpdEFyZWFcbiAgICAgKiBAdHlwZSBSZWN0YW5nbGV8Q2lyY2xlfEVsbGlwc2V8UG9seWdvblxuICAgICAqL1xuICAgIHRoaXMuaGl0QXJlYSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIFNob3VsZCB0aGlzIERpc3BsYXlPYmplY3QgYmUgcmVuZGVyZWQgYnkgdGhlIHJlbmRlcmVyPyBBbiBvYmplY3Qgd2l0aCBhIHJlbmRlcmFibGUgdmFsdWUgb2ZcbiAgICAqIGBmYWxzZWAgaXMgc2tpcHBlZCBkdXJpbmcgdGhlIHJlbmRlciBwYXNzLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVuZGVyYWJsZVxuICAgICogQGRlZmF1bHRcbiAgICAqL1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgcGFyZW50IERpc3BsYXlPYmplY3RDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3QgaXMgYSBjaGlsZCBvZi5cbiAgICAqIEFsbCBEaXNwbGF5T2JqZWN0cyBtdXN0IGJlbG9uZyB0byBhIHBhcmVudCBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5cbiAgICAqIFRoZSByb290IHBhcmVudCBpcyB0aGUgU3RhZ2Ugb2JqZWN0LiBUaGlzIHByb3BlcnR5IGlzIHNldCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlXG4gICAgKiBEaXNwbGF5T2JqZWN0IGlzIGFkZGVkIHRvLCBvciByZW1vdmVkIGZyb20sIGEgRGlzcGxheU9iamVjdENvbnRhaW5lci5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge1BJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50XG4gICAgKiBAZGVmYXVsdFxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIFRoZSBtdWx0aXBsaWVkIGFscGhhIHZhbHVlIG9mIHRoaXMgRGlzcGxheU9iamVjdC4gQSB2YWx1ZSBvZiAxIGlzIGZ1bGx5IG9wYXF1ZS4gQSB2YWx1ZSBvZiAwIGlzIHRyYW5zcGFyZW50LlxuICAgICogVGhpcyB2YWx1ZSBpcyB0aGUgY2FsY3VsYXRlZCB0b3RhbCwgYmFzZWQgb24gdGhlIGFscGhhIHZhbHVlcyBvZiBhbGwgcGFyZW50cyBvZiB0aGlzIERpc3BsYXlPYmplY3RzXG4gICAgKiBpbiB0aGUgZGlzcGxheSBsaXN0LlxuICAgICpcbiAgICAqIFRvIG9idGFpbiwgYW5kIHNldCwgdGhlIGxvY2FsIGFscGhhIHZhbHVlLCBzZWUgdGhlIGBhbHBoYWAgcHJvcGVydHkuXG4gICAgKlxuICAgICogTm90ZTogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHVwZGF0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYHVwZGF0ZVRyYW5zZm9ybWAgY2FsbCwgb25jZSBwZXIgcmVuZGVyLiBVbnRpbFxuICAgICogdGhhdCBoYXBwZW5zIHRoaXMgcHJvcGVydHkgd2lsbCBjb250YWluIHZhbHVlcyBiYXNlZCBvbiB0aGUgcHJldmlvdXMgZnJhbWUuIEJlIG1pbmRmdWwgb2YgdGhpcyBpZlxuICAgICogYWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgb3V0c2lkZSBvZiB0aGUgbm9ybWFsIGdhbWUgZmxvdywgaS5lLiBmcm9tIGFuIGFzeW5jaHJvbm91cyBldmVudCBjYWxsYmFjay5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd29ybGRBbHBoYVxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLndvcmxkQWxwaGEgPSAxO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgY3VycmVudCB0cmFuc2Zvcm0gb2YgdGhpcyBEaXNwbGF5T2JqZWN0LlxuICAgICpcbiAgICAqIFRoaXMgcHJvcGVydHkgY29udGFpbnMgdGhlIGNhbGN1bGF0ZWQgdG90YWwsIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm1zIG9mIGFsbCBwYXJlbnRzIG9mIHRoaXNcbiAgICAqIERpc3BsYXlPYmplY3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cbiAgICAqXG4gICAgKiBOb3RlOiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdXBkYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBgdXBkYXRlVHJhbnNmb3JtYCBjYWxsLCBvbmNlIHBlciByZW5kZXIuIFVudGlsXG4gICAgKiB0aGF0IGhhcHBlbnMgdGhpcyBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gdmFsdWVzIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBmcmFtZS4gQmUgbWluZGZ1bCBvZiB0aGlzIGlmXG4gICAgKiBhY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBvdXRzaWRlIG9mIHRoZSBub3JtYWwgZ2FtZSBmbG93LCBpLmUuIGZyb20gYW4gYXN5bmNocm9ub3VzIGV2ZW50IGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5NYXRyaXh9IHdvcmxkVHJhbnNmb3JtXG4gICAgKiBAcmVhZE9ubHlcbiAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgUElYSS5NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICogVGhlIGNvb3JkaW5hdGVzLCBpbiBwaXhlbHMsIG9mIHRoaXMgRGlzcGxheU9iamVjdCB3aXRoaW4gdGhlIHdvcmxkLlxuICAgICpcbiAgICAqIFRoaXMgcHJvcGVydHkgY29udGFpbnMgdGhlIGNhbGN1bGF0ZWQgdG90YWwsIGJhc2VkIG9uIHRoZSBwb3NpdGlvbnMgb2YgYWxsIHBhcmVudHMgb2YgdGhpc1xuICAgICogRGlzcGxheU9iamVjdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxuICAgICpcbiAgICAqIE5vdGU6IFRoaXMgcHJvcGVydHkgaXMgb25seSB1cGRhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGB1cGRhdGVUcmFuc2Zvcm1gIGNhbGwsIG9uY2UgcGVyIHJlbmRlci4gVW50aWxcbiAgICAqIHRoYXQgaGFwcGVucyB0aGlzIHByb3BlcnR5IHdpbGwgY29udGFpbiB2YWx1ZXMgYmFzZWQgb24gdGhlIHByZXZpb3VzIGZyYW1lLiBCZSBtaW5kZnVsIG9mIHRoaXMgaWZcbiAgICAqIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG91dHNpZGUgb2YgdGhlIG5vcm1hbCBnYW1lIGZsb3csIGkuZS4gZnJvbSBhbiBhc3luY2hyb25vdXMgZXZlbnQgY2FsbGJhY2suXG4gICAgKlxuICAgICogQHByb3BlcnR5IHtQSVhJLlBvaW50fSB3b3JsZFBvc2l0aW9uXG4gICAgKiBAcmVhZE9ubHlcbiAgICAqL1xuICAgIHRoaXMud29ybGRQb3NpdGlvbiA9IG5ldyBQSVhJLlBvaW50KDAsIDApO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgZ2xvYmFsIHNjYWxlIG9mIHRoaXMgRGlzcGxheU9iamVjdC5cbiAgICAqXG4gICAgKiBUaGlzIHByb3BlcnR5IGNvbnRhaW5zIHRoZSBjYWxjdWxhdGVkIHRvdGFsLCBiYXNlZCBvbiB0aGUgc2NhbGVzIG9mIGFsbCBwYXJlbnRzIG9mIHRoaXNcbiAgICAqIERpc3BsYXlPYmplY3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cbiAgICAqXG4gICAgKiBOb3RlOiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdXBkYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBgdXBkYXRlVHJhbnNmb3JtYCBjYWxsLCBvbmNlIHBlciByZW5kZXIuIFVudGlsXG4gICAgKiB0aGF0IGhhcHBlbnMgdGhpcyBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gdmFsdWVzIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBmcmFtZS4gQmUgbWluZGZ1bCBvZiB0aGlzIGlmXG4gICAgKiBhY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBvdXRzaWRlIG9mIHRoZSBub3JtYWwgZ2FtZSBmbG93LCBpLmUuIGZyb20gYW4gYXN5bmNocm9ub3VzIGV2ZW50IGNhbGxiYWNrLlxuICAgICpcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5Qb2ludH0gd29ybGRTY2FsZVxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLndvcmxkU2NhbGUgPSBuZXcgUElYSS5Qb2ludCgxLCAxKTtcblxuICAgIC8qKlxuICAgICogVGhlIHJvdGF0aW9uLCBpbiByYWRpYW5zLCBvZiB0aGlzIERpc3BsYXlPYmplY3QuXG4gICAgKlxuICAgICogVGhpcyBwcm9wZXJ0eSBjb250YWlucyB0aGUgY2FsY3VsYXRlZCB0b3RhbCwgYmFzZWQgb24gdGhlIHJvdGF0aW9ucyBvZiBhbGwgcGFyZW50cyBvZiB0aGlzXG4gICAgKiBEaXNwbGF5T2JqZWN0IGluIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgKlxuICAgICogTm90ZTogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHVwZGF0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYHVwZGF0ZVRyYW5zZm9ybWAgY2FsbCwgb25jZSBwZXIgcmVuZGVyLiBVbnRpbFxuICAgICogdGhhdCBoYXBwZW5zIHRoaXMgcHJvcGVydHkgd2lsbCBjb250YWluIHZhbHVlcyBiYXNlZCBvbiB0aGUgcHJldmlvdXMgZnJhbWUuIEJlIG1pbmRmdWwgb2YgdGhpcyBpZlxuICAgICogYWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgb3V0c2lkZSBvZiB0aGUgbm9ybWFsIGdhbWUgZmxvdywgaS5lLiBmcm9tIGFuIGFzeW5jaHJvbm91cyBldmVudCBjYWxsYmFjay5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gd29ybGRSb3RhdGlvblxuICAgICogQHJlYWRPbmx5XG4gICAgKi9cbiAgICB0aGlzLndvcmxkUm90YXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgcmVjdGFuZ3VsYXIgYXJlYSB1c2VkIGJ5IGZpbHRlcnMgd2hlbiByZW5kZXJpbmcgYSBzaGFkZXIgZm9yIHRoaXMgRGlzcGxheU9iamVjdC5cbiAgICAqXG4gICAgKiBAcHJvcGVydHkge1BJWEkuUmVjdGFuZ2xlfSBmaWx0ZXJBcmVhXG4gICAgKiBAdHlwZSBSZWN0YW5nbGVcbiAgICAqIEBkZWZhdWx0XG4gICAgKi9cbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gX3NyIC0gQ2FjaGVkIHJvdGF0aW9uIHZhbHVlLlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX3NyID0gMDtcblxuICAgIC8qKlxuICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9jciAtIENhY2hlZCByb3RhdGlvbiB2YWx1ZS5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9jciA9IDE7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5SZWN0YW5nbGV9IF9ib3VuZHMgLSBUaGUgY2FjaGVkIGJvdW5kcyBvZiB0aGlzIG9iamVjdC5cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5SZWN0YW5nbGV9IF9jdXJyZW50Qm91bmRzIC0gVGhlIG1vc3QgcmVjZW50bHkgY2FsY3VsYXRlZCBib3VuZHMgb2YgdGhpcyBvYmplY3QuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5SZWN0YW5nbGV9IF9tYXNrIC0gVGhlIGNhY2hlZCBtYXNrIG9mIHRoaXMgb2JqZWN0LlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IF9jYWNoZUFzQml0bWFwIC0gSW50ZXJuYWwgY2FjaGUgYXMgYml0bWFwIGZsYWcuXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IF9jYWNoZUlzRGlydHkgLSBJbnRlcm5hbCBkaXJ0eSBjYWNoZSBmbGFnLlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuX2NhY2hlSXNEaXJ0eSA9IGZhbHNlO1xuXG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5EaXNwbGF5T2JqZWN0O1xuXG5QSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgKiBEZXN0cm95IHRoaXMgRGlzcGxheU9iamVjdC5cbiAgICAqXG4gICAgKiBSZW1vdmVzIGFueSBjYWNoZWQgc3ByaXRlcywgc2V0cyByZW5kZXJhYmxlIGZsYWcgdG8gZmFsc2UsIGFuZCBudWxscyBmaWx0ZXJzLCBib3VuZHMgYW5kIG1hc2suXG4gICAgKlxuICAgICogQWxzbyBpdGVyYXRpdmVseSBjYWxscyBgZGVzdHJveWAgb24gYW55IGNoaWxkcmVuLlxuICAgICpcbiAgICAqIEBtZXRob2QgUElYSS5EaXNwbGF5T2JqZWN0I2Rlc3Ryb3lcbiAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaXRBcmVhID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWRTcHJpdGUoKTtcblxuICAgIH0sXG5cbiAgICAvKlxuICAgICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG1hdHJpeCB0aGlzIERpc3BsYXlPYmplY3QgdXNlcyBmb3IgcmVuZGVyaW5nLlxuICAgICpcbiAgICAqIElmIHRoZSBvYmplY3QgaGFzIG5vIHBhcmVudCwgYW5kIG5vIHBhcmVudCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0b1xuICAgICogUGhhc2VyLkdhbWUuV29ybGQgYXMgdGhlIHBhcmVudCB0cmFuc2Zvcm0gdG8gdXNlLiBJZiB0aGF0IGlzIHVuYXZhaWxhYmxlIHRoZSB0cmFuc2Zvcm0gZmFpbHMgdG8gdGFrZSBwbGFjZS5cbiAgICAqXG4gICAgKiBUaGUgYHBhcmVudGAgcGFyYW1ldGVyIGhhcyBwcmlvcml0eSBvdmVyIHRoZSBhY3R1YWwgcGFyZW50LiBVc2UgaXQgYXMgYSBwYXJlbnQgb3ZlcnJpZGUuXG4gICAgKiBTZXR0aW5nIGl0IGRvZXMgKipub3QqKiBjaGFuZ2UgdGhlIGFjdHVhbCBwYXJlbnQgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LlxuICAgICpcbiAgICAqIENhbGxpbmcgdGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgYHdvcmxkVHJhbnNmb3JtYCwgYHdvcmxkQWxwaGFgLCBgd29ybGRQb3NpdGlvbmAsIGB3b3JsZFNjYWxlYFxuICAgICogYW5kIGB3b3JsZFJvdGF0aW9uYCBwcm9wZXJ0aWVzLlxuICAgICpcbiAgICAqIElmIGEgYHRyYW5zZm9ybUNhbGxiYWNrYCBoYXMgYmVlbiBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mIHRoaXMgbWV0aG9kLCBhbmQgaXMgcGFzc2VkXG4gICAgKiB0aGUgbmV3LCB1cGRhdGVkLCB3b3JsZFRyYW5zZm9ybSBwcm9wZXJ0eSwgYWxvbmcgd2l0aCB0aGUgcGFyZW50IHRyYW5zZm9ybSB1c2VkLlxuICAgICpcbiAgICAqIEBtZXRob2QgUElYSS5EaXNwbGF5T2JqZWN0I3VwZGF0ZVRyYW5zZm9ybVxuICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXJ9IFtwYXJlbnRdIC0gT3B0aW9uYWwgcGFyZW50IHRvIGNhbGN1bGF0ZSB0aGlzIERpc3BsYXlPYmplY3RzIHRyYW5zZm9ybSBmcm9tLlxuICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSAtIEEgcmVmZXJlbmNlIHRvIHRoaXMgRGlzcGxheU9iamVjdC5cbiAgICAqL1xuICAgIHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKHBhcmVudCkge1xuXG4gICAgICAgIGlmICghcGFyZW50ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5nYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgcCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLmdhbWUud29ybGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc29tZSBtYXRyaXggcmVmcyBmb3IgZWFzeSBhY2Nlc3NcbiAgICAgICAgdmFyIHB0ID0gcC53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgbWF0cml4IHZhcmlhYmxlc1xuICAgICAgICB2YXIgYSwgYiwgYywgZCwgdHgsIHR5O1xuXG4gICAgICAgIC8vIHNvIGlmIHJvdGF0aW9uIGlzIGJldHdlZW4gMCB0aGVuIHdlIGNhbiBzaW1wbGlmeSB0aGUgbXVsdGlwbGljYXRpb24gcHJvY2Vzcy4uXG4gICAgICAgIGlmICh0aGlzLnJvdGF0aW9uICUgUGhhc2VyLk1hdGguUEkyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHJvdGF0aW9uIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByZW5kZXIuIFRoaXMgbWVhbnMgd2Ugb25seSBuZWVkIHRvIHVzZSBzaW4gYW5kIGNvcyB3aGVuIHJvdGF0aW9uIGFjdHVhbGx5IGNoYW5nZXNcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW9uICE9PSB0aGlzLnJvdGF0aW9uQ2FjaGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkNhY2hlID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zciA9IE1hdGguc2luKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyID0gTWF0aC5jb3ModGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgbWF0cml4IHZhbHVlcyBvZiB0aGUgZGlzcGxheW9iamVjdCBiYXNlZCBvbiBpdHMgdHJhbnNmb3JtIHByb3BlcnRpZXMuLlxuICAgICAgICAgICAgYSAgPSAgdGhpcy5fY3IgKiB0aGlzLnNjYWxlLng7XG4gICAgICAgICAgICBiICA9ICB0aGlzLl9zciAqIHRoaXMuc2NhbGUueDtcbiAgICAgICAgICAgIGMgID0gLXRoaXMuX3NyICogdGhpcy5zY2FsZS55O1xuICAgICAgICAgICAgZCAgPSAgdGhpcy5fY3IgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgICAgICB0eCA9ICB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgICAgICB0eSA9ICB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwaXZvdC4uIG5vdCBvZnRlbiB1c2VkIHNvIGdlYXJlZCB0b3dhcmRzIHRoYXQgZmFjdCFcbiAgICAgICAgICAgIGlmICh0aGlzLnBpdm90LnggfHwgdGhpcy5waXZvdC55KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR4IC09IHRoaXMucGl2b3QueCAqIGEgKyB0aGlzLnBpdm90LnkgKiBjO1xuICAgICAgICAgICAgICAgIHR5IC09IHRoaXMucGl2b3QueCAqIGIgKyB0aGlzLnBpdm90LnkgKiBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb25jYXQgdGhlIHBhcmVudCBtYXRyaXggd2l0aCB0aGUgb2JqZWN0cyB0cmFuc2Zvcm0uXG4gICAgICAgICAgICB3dC5hICA9IGEgICogcHQuYSArIGIgICogcHQuYztcbiAgICAgICAgICAgIHd0LmIgID0gYSAgKiBwdC5iICsgYiAgKiBwdC5kO1xuICAgICAgICAgICAgd3QuYyAgPSBjICAqIHB0LmEgKyBkICAqIHB0LmM7XG4gICAgICAgICAgICB3dC5kICA9IGMgICogcHQuYiArIGQgICogcHQuZDtcbiAgICAgICAgICAgIHd0LnR4ID0gdHggKiBwdC5hICsgdHkgKiBwdC5jICsgcHQudHg7XG4gICAgICAgICAgICB3dC50eSA9IHR4ICogcHQuYiArIHR5ICogcHQuZCArIHB0LnR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbGV0cyBkbyB0aGUgZmFzdCB2ZXJzaW9uIGFzIHdlIGtub3cgdGhlcmUgaXMgbm8gcm90YXRpb24uLlxuICAgICAgICAgICAgYSAgPSB0aGlzLnNjYWxlLng7XG4gICAgICAgICAgICBkICA9IHRoaXMuc2NhbGUueTtcblxuICAgICAgICAgICAgdHggPSB0aGlzLnBvc2l0aW9uLnggLSB0aGlzLnBpdm90LnggKiBhO1xuICAgICAgICAgICAgdHkgPSB0aGlzLnBvc2l0aW9uLnkgLSB0aGlzLnBpdm90LnkgKiBkO1xuXG4gICAgICAgICAgICB3dC5hICA9IGEgICogcHQuYTtcbiAgICAgICAgICAgIHd0LmIgID0gYSAgKiBwdC5iO1xuICAgICAgICAgICAgd3QuYyAgPSBkICAqIHB0LmM7XG4gICAgICAgICAgICB3dC5kICA9IGQgICogcHQuZDtcbiAgICAgICAgICAgIHd0LnR4ID0gdHggKiBwdC5hICsgdHkgKiBwdC5jICsgcHQudHg7XG4gICAgICAgICAgICB3dC50eSA9IHR4ICogcHQuYiArIHR5ICogcHQuZCArIHB0LnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRldGVybSA9IChhICogZCkgLSAoYiAqIGMpO1xuICAgICAgICB2YXIgVEFVID0gTWF0aC5QSSAqIDAuNTtcblxuICAgICAgICBpZiAoYSB8fCBiKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguc3FydCgoYSAqIGEpICsgKGIgKiBiKSk7XG5cbiAgICAgICAgICAgIHRoaXMud29ybGRSb3RhdGlvbiA9IChiID4gMCkgPyBNYXRoLmFjb3MoYSAvIHIpIDogLU1hdGguYWNvcyhhIC8gcik7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueCA9IHI7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueSA9IGRldGVybSAvIHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyB8fCBkKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguc3FydCgoYyAqIGMpICsgKGQgKiBkKSk7XG5cbiAgICAgICAgICAgIHRoaXMud29ybGRSb3RhdGlvbiA9IFRBVSAtICgoZCA+IDApID8gTWF0aC5hY29zKC1jIC8gcykgOiAtTWF0aC5hY29zKGMgLyBzKSk7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueCA9IGRldGVybSAvIHM7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueSA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueCA9IDA7XG4gICAgICAgICAgICB0aGlzLndvcmxkU2NhbGUueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgU2V0IHRoZSBXb3JsZCB2YWx1ZXNcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHAud29ybGRBbHBoYTtcbiAgICAgICAgdGhpcy53b3JsZFBvc2l0aW9uLnggPSB3dC50eDtcbiAgICAgICAgdGhpcy53b3JsZFBvc2l0aW9uLnkgPSB3dC50eTtcblxuICAgICAgICAvLyByZXNldCB0aGUgYm91bmRzIGVhY2ggdGltZSB0aGlzIGlzIGNhbGxlZCFcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG5cbiAgICAgICAgLy8gIEN1c3RvbSBjYWxsYmFjaz9cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtQ2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ2FsbGJhY2suY2FsbCh0aGlzLnRyYW5zZm9ybUNhbGxiYWNrQ29udGV4dCwgd3QsIHB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIHRoYXQgcmVxdWlyZSBpdC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBJWEkuRGlzcGxheU9iamVjdCNwcmVVcGRhdGVcbiAgICAqL1xuICAgIHByZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2VuZXJhdGVzIGEgUmVuZGVyVGV4dHVyZSBiYXNlZCBvbiB0aGlzIERpc3BsYXlPYmplY3QsIHdoaWNoIGNhbiB0aGV5IGJlIHVzZWQgdG8gdGV4dHVyZSBvdGhlciBTcHJpdGVzLlxuICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdXIgRGlzcGxheU9iamVjdCBpcyBzdGF0aWMsIG9yIGNvbXBsaWNhdGVkLCBhbmQgbmVlZHMgdG8gYmUgcmV1c2VkIG11bHRpcGxlIHRpbWVzLlxuICAgICpcbiAgICAqIFBsZWFzZSBub3RlIHRoYXQgbm8gZ2FyYmFnZSBjb2xsZWN0aW9uIHRha2VzIHBsYWNlIG9uIG9sZCB0ZXh0dXJlcy4gSXQgaXMgdXAgdG8geW91IHRvIGRlc3Ryb3kgb2xkIHRleHR1cmVzLFxuICAgICogYW5kIHJlZmVyZW5jZXMgdG8gdGhlbSwgc28gdGhleSBkb24ndCBsaW5nZXIgaW4gbWVtb3J5LlxuICAgICpcbiAgICAqIEBtZXRob2QgUElYSS5EaXNwbGF5T2JqZWN0I2dlbmVyYXRlVGV4dHVyZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZU1vZGU9UElYSS5zY2FsZU1vZGVzLkRFRkFVTFRdIC0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1QSVhJLnNjYWxlTW9kZXN7ey9jcm9zc0xpbmt9fSBmb3IgcG9zc2libGUgdmFsdWVzLlxuICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfFBJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cbiAgICAqIEByZXR1cm4ge1BoYXNlci5SZW5kZXJUZXh0dXJlfSAtIEEgUmVuZGVyVGV4dHVyZSBjb250YWluaW5nIGFuIGltYWdlIG9mIHRoaXMgRGlzcGxheU9iamVjdCBhdCB0aGUgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAqL1xuICAgIGdlbmVyYXRlVGV4dHVyZTogZnVuY3Rpb24gKHJlc29sdXRpb24sIHNjYWxlTW9kZSwgcmVuZGVyZXIpIHtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFBoYXNlci5SZW5kZXJUZXh0dXJlKHRoaXMuZ2FtZSwgYm91bmRzLndpZHRoIHwgMCwgYm91bmRzLmhlaWdodCB8IDAsIHJlbmRlcmVyLCBzY2FsZU1vZGUsIHJlc29sdXRpb24pO1xuXG4gICAgICAgIFBJWEkuRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeC50eCA9IC1ib3VuZHMueDtcbiAgICAgICAgUElYSS5EaXNwbGF5T2JqZWN0Ll90ZW1wTWF0cml4LnR5ID0gLWJvdW5kcy55O1xuXG4gICAgICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIFBJWEkuRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeCk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBJZiB0aGlzIERpc3BsYXlPYmplY3QgaGFzIGEgY2FjaGVkIFNwcml0ZSwgdGhpcyBtZXRob2QgZ2VuZXJhdGVzIGFuZCB1cGRhdGVzIGl0LlxuICAgICpcbiAgICAqIEBtZXRob2QgUElYSS5EaXNwbGF5T2JqZWN0I3VwZGF0ZUNhY2hlXG4gICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IC0gQSByZWZlcmVuY2UgdG8gdGhpcyBEaXNwbGF5T2JqZWN0LlxuICAgICovXG4gICAgdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoaXMgRGlzcGxheU9iamVjdCwgYmFzZWQgb24gdGhlIHBvc2l0aW9uIGdpdmVuLlxuICAgICpcbiAgICAqIEBtZXRob2QgUElYSS5EaXNwbGF5T2JqZWN0I3RvR2xvYmFsXG4gICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvc2l0aW9uIC0gVGhlIGdsb2JhbCBwb3NpdGlvbiB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIERpc3BsYXlPYmplY3QgYmFzZWQgb24gdGhlIGdsb2JhbCBwb3NpdGlvbiBnaXZlbi5cbiAgICAqL1xuICAgIHRvR2xvYmFsOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENhbGN1bGF0ZXMgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoaXMgRGlzcGxheU9iamVjdCwgcmVsYXRpdmUgdG8gYW5vdGhlciBwb2ludC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBJWEkuRGlzcGxheU9iamVjdCN0b0xvY2FsXG4gICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBbZnJvbV0gLSBBbiBvcHRpb25hbCBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXG4gICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBEaXNwbGF5T2JqZWN0IGJhc2VkIG9uIHRoZSBnbG9iYWwgcG9zaXRpb24gZ2l2ZW4uXG4gICAgKi9cbiAgICB0b0xvY2FsOiBmdW5jdGlvbiAocG9zaXRpb24sIGZyb20pIHtcblxuICAgICAgICBpZiAoZnJvbSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvc2l0aW9uKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEludGVybmFsIG1ldGhvZC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBJWEkuRGlzcGxheU9iamVjdCNfcmVuZGVyQ2FjaGVkU3ByaXRlXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IHJlbmRlclNlc3Npb24gLSBUaGUgcmVuZGVyIHNlc3Npb25cbiAgICAqL1xuICAgIF9yZW5kZXJDYWNoZWRTcHJpdGU6IGZ1bmN0aW9uIChyZW5kZXJTZXNzaW9uKSB7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICAgICAgaWYgKHJlbmRlclNlc3Npb24uZ2wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIFBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgUElYSS5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMuY2FsbCh0aGlzLl9jYWNoZWRTcHJpdGUsIHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAgKlxuICAgICogQG1ldGhvZCBQSVhJLkRpc3BsYXlPYmplY3QjX2dlbmVyYXRlQ2FjaGVkU3ByaXRlXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2dlbmVyYXRlQ2FjaGVkU3ByaXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG5cbiAgICAgICAgLy8gIFJvdW5kIGl0IG9mZiBhbmQgZm9yY2Ugbm9uLXplcm8gZGltZW5zaW9uc1xuICAgICAgICBib3VuZHMud2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoYm91bmRzLndpZHRoKSk7XG4gICAgICAgIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCkpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmIHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZSAmJiBQSVhJLl9lbmFibGVNdWx0aVRleHR1cmVUb2dnbGUpXG4gICAgICAgICAgICAgICAgdGV4dHVyZVVuaXQgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUudGV4dHVyZUluZGV4O1xuICAgICAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSBuZXcgUGhhc2VyLlJlbmRlclRleHR1cmUodGhpcy5nYW1lLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGV4dHVyZVVuaXQpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLnJlc2l6ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFJlbW92ZSBmaWx0ZXJzXG4gICAgICAgIHZhciB0ZW1wRmlsdGVycyA9IHRoaXMuX2ZpbHRlcnM7XG5cbiAgICAgICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5maWx0ZXJzID0gdGVtcEZpbHRlcnM7XG5cbiAgICAgICAgUElYSS5EaXNwbGF5T2JqZWN0Ll90ZW1wTWF0cml4LnR4ID0gLWJvdW5kcy54O1xuICAgICAgICBQSVhJLkRpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXgudHkgPSAtYm91bmRzLnk7XG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLnJlbmRlcih0aGlzLCBQSVhJLkRpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXgsIHRydWUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcnMgPSB0ZW1wRmlsdGVycztcblxuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIERlc3Ryb3lzIGEgY2FjaGVkIFNwcml0ZS5cbiAgICAqXG4gICAgKiBAbWV0aG9kIFBJWEkuRGlzcGxheU9iamVjdCNfZGVzdHJveUNhY2hlZFNwcml0ZVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9kZXN0cm95Q2FjaGVkU3ByaXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS50ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbnVsbDtcblxuICAgIH1cblxufTtcblxuLy8gIEFsaWFzIGZvciB1cGRhdGVUcmFuc2Zvcm0uIEFzIHVzZWQgaW4gRGlzcGxheU9iamVjdCBjb250YWluZXIsIGV0Yy5cblBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IFBJWEkuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhQSVhJLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAqIFRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0LCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgKiBJZiB5b3UgbmVlZCB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QsIHVzZSBgRGlzcGxheU9iamVjdC53b3JsZFBvc2l0aW9uYCBpbnN0ZWFkLlxuICAgICogQG5hbWUgUElYSS5EaXNwbGF5T2JqZWN0I3hcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QsIGluIHBpeGVscywgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cbiAgICAqL1xuICAgICd4Jzoge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XG5cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICogVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0LCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgKiBJZiB5b3UgbmVlZCB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QsIHVzZSBgRGlzcGxheU9iamVjdC53b3JsZFBvc2l0aW9uYCBpbnN0ZWFkLlxuICAgICogQG5hbWUgUElYSS5EaXNwbGF5T2JqZWN0I3lcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0LCBpbiBwaXhlbHMsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgKi9cbiAgICAneSc6IHtcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEluZGljYXRlcyBpZiB0aGlzIERpc3BsYXlPYmplY3QgaXMgdmlzaWJsZSwgYmFzZWQgb24gaXQsIGFuZCBhbGwgb2YgaXRzIHBhcmVudHMsIGB2aXNpYmxlYCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgKiBAbmFtZSBQSVhJLkRpc3BsYXlPYmplY3Qjd29ybGRWaXNpYmxlXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHdvcmxkVmlzaWJsZSAtIEluZGljYXRlcyBpZiB0aGlzIERpc3BsYXlPYmplY3QgaXMgdmlzaWJsZSwgYmFzZWQgb24gaXQsIGFuZCBhbGwgb2YgaXRzIHBhcmVudHMsIGB2aXNpYmxlYCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgKi9cbiAgICAnd29ybGRWaXNpYmxlJzoge1xuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpdGVtKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNldHMgYSBtYXNrIGZvciB0aGlzIERpc3BsYXlPYmplY3QuIEEgbWFzayBpcyBhbiBpbnN0YW5jZSBvZiBhIEdyYXBoaWNzIG9iamVjdC5cbiAgICAqIFdoZW4gYXBwbGllZCBpdCBsaW1pdHMgdGhlIHZpc2libGUgYXJlYSBvZiB0aGlzIERpc3BsYXlPYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrLlxuICAgICogVW5kZXIgYSBDYW52YXMgcmVuZGVyZXIgaXQgdXNlcyBzaGFwZSBjbGlwcGluZy4gVW5kZXIgYSBXZWJHTCByZW5kZXJlciBpdCB1c2VzIGEgU3RlbmNpbCBCdWZmZXIuXG4gICAgKiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAgKlxuICAgICogQG5hbWUgUElYSS5EaXNwbGF5T2JqZWN0I21hc2tcbiAgICAqIEBwcm9wZXJ0eSB7UElYSS5HcmFwaGljc30gbWFzayAtIFRoZSBtYXNrIGFwcGxpZWQgdG8gdGhpcyBEaXNwbGF5T2JqZWN0LiBTZXQgdG8gYG51bGxgIHRvIHJlbW92ZSBhbiBleGlzdGluZyBtYXNrLlxuICAgICovXG4gICAgJ21hc2snOiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX21hc2spXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5pc01hc2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFzay5pc01hc2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIGZpbHRlcnMgZm9yIHRoaXMgRGlzcGxheU9iamVjdC4gVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSwgYW5kIGlzIGlnbm9yZWQgYnkgdGhlIENhbnZhc1xuICAgICogUmVuZGVyZXIuIEEgZmlsdGVyIGlzIGEgc2hhZGVyIGFwcGxpZWQgdG8gdGhpcyBEaXNwbGF5T2JqZWN0LiBZb3UgY2FuIG1vZGlmeSB0aGUgcGxhY2VtZW50IG9mIHRoZSBmaWx0ZXJcbiAgICAqIHVzaW5nIGBEaXNwbGF5T2JqZWN0LmZpbHRlckFyZWFgLlxuICAgICpcbiAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAgKlxuICAgICogTm90ZTogWW91IGNhbm5vdCBoYXZlIGEgZmlsdGVyIHNldCwgYW5kIGEgTVVMVElQTFkgQmxlbmQgTW9kZSBhY3RpdmUsIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgYVxuICAgICogZmlsdGVyIHdpbGwgcmVzZXQgdGhpcyBEaXNwbGF5T2JqZWN0cyBibGVuZCBtb2RlIHRvIE5PUk1BTC5cbiAgICAqXG4gICAgKiBAbmFtZSBQSVhJLkRpc3BsYXlPYmplY3QjZmlsdGVyc1xuICAgICogQHByb3BlcnR5IHtBcnJheX0gZmlsdGVycyAtIEFuIEFycmF5IG9mIFBoYXNlci5GaWx0ZXIgb2JqZWN0cywgb3Igb2JqZWN0cyB0aGF0IGV4dGVuZCB0aGVtLlxuICAgICovXG4gICAgJ2ZpbHRlcnMnOiB7XG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJzO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICBQdXQgYWxsIHRoZSBwYXNzZXMgaW4gb25lIHBsYWNlLlxuICAgICAgICAgICAgICAgIHZhciBwYXNzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyUGFzc2VzID0gdmFsdWVbaV0ucGFzc2VzO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyUGFzc2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzZXMucHVzaChmaWx0ZXJQYXNzZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gIE5lZWRlZCBhbnkgbW9yZT9cbiAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJCbG9jayA9IHsgdGFyZ2V0OiB0aGlzLCBmaWx0ZXJQYXNzZXM6IHBhc3NlcyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAmJiB0aGlzLmJsZW5kTW9kZSA9PT0gUElYSS5ibGVuZE1vZGVzLk1VTFRJUExZKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxlbmRNb2RlID0gUElYSS5ibGVuZE1vZGVzLk5PUk1BTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBTZXRzIGlmIHRoaXMgRGlzcGxheU9iamVjdCBzaG91bGQgYmUgY2FjaGVkIGFzIGEgYml0bWFwLlxuICAgICpcbiAgICAqIFdoZW4gaW52b2tlZCBpdCB3aWxsIHRha2UgYSBzbmFwc2hvdCBvZiB0aGUgRGlzcGxheU9iamVjdCwgYXMgaXQgaXMgYXQgdGhhdCBtb21lbnQsIGFuZCBzdG9yZSBpdFxuICAgICogaW4gYSBSZW5kZXJUZXh0dXJlLiBUaGlzIGlzIHRoZW4gdXNlZCB3aGVuZXZlciB0aGlzIERpc3BsYXlPYmplY3QgaXMgcmVuZGVyZWQuIEl0IGNhbiBwcm92aWRlIGFcbiAgICAqIHBlcmZvcm1hbmNlIGJlbmVmaXQgZm9yIGNvbXBsZXgsIGJ1dCBzdGF0aWMsIERpc3BsYXlPYmplY3RzLiBJLmUuIHRob3NlIHdpdGggbG90cyBvZiBjaGlsZHJlbi5cbiAgICAqXG4gICAgKiBDYWNoZWQgQml0bWFwcyBkbyBub3QgdHJhY2sgdGhlaXIgcGFyZW50cy4gSWYgeW91IHVwZGF0ZSBhIHByb3BlcnR5IG9mIHRoaXMgRGlzcGxheU9iamVjdCwgaXQgd2lsbCBub3RcbiAgICAqIHJlLWdlbmVyYXRlIHRoZSBjYWNoZWQgYml0bWFwIGF1dG9tYXRpY2FsbHkuIFRvIGRvIHRoYXQgeW91IG5lZWQgdG8gY2FsbCBgRGlzcGxheU9iamVjdC51cGRhdGVDYWNoZWAuXG4gICAgKlxuICAgICogVG8gcmVtb3ZlIGEgY2FjaGVkIGJpdG1hcCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYG51bGxgLlxuICAgICpcbiAgICAqIEBuYW1lIFBJWEkuRGlzcGxheU9iamVjdCNjYWNoZUFzQml0bWFwXG4gICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhY2hlQXNCaXRtYXAgLSBDYWNoZSB0aGlzIERpc3BsYXlPYmplY3QgYXMgYSBCaXRtYXAuIFNldCB0byBgbnVsbGAgdG8gcmVtb3ZlIGFuIGV4aXN0aW5nIGNhY2hlZCBiaXRtYXAuXG4gICAgKi9cbiAgICAnY2FjaGVBc0JpdG1hcCc6IHtcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FjaGVkU3ByaXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbn0pO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogQSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRpc3BsYXkgb2JqZWN0cy5cbiAqIEl0IGlzIHRoZSBiYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgdGhhdCBhY3QgYXMgYSBjb250YWluZXIgZm9yIG90aGVyIG9iamVjdHMuXG4gKlxuICogQGNsYXNzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjaGlsZHJlblxuICAgICAqIEB0eXBlIEFycmF5KERpc3BsYXlPYmplY3QpXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgKiBJZiBgaWdub3JlQ2hpbGRJbnB1dGAgIGlzIGBmYWxzZWAgaXQgd2lsbCBhbGxvdyB0aGlzIG9iamVjdHMgX2NoaWxkcmVuXyB0byBiZSBjb25zaWRlcmVkIGFzIHZhbGlkIGZvciBJbnB1dCBldmVudHMuXG4gICAgKiBcbiAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgIHRoZW4gdGhlIGNoaWxkcmVuIHdpbGwgX25vdF8gYmUgY29uc2lkZXJlZCBhcyB2YWxpZCBmb3IgSW5wdXQgZXZlbnRzLlxuICAgICogXG4gICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpc24ndCByZWN1cnNpdmU6IG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIGFyZSBpbmZsdWVuY2VkLCBpdCBkb2Vzbid0IHNjYW4gZnVydGhlciBkb3duLlxuICAgICogQHByb3BlcnR5IHtib29sZWFufSBpZ25vcmVDaGlsZElucHV0XG4gICAgKiBAZGVmYXVsdFxuICAgICovXG4gICAgdGhpcy5pZ25vcmVDaGlsZElucHV0ID0gZmFsc2U7XG4gICAgXG59O1xuXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUElYSS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZSApO1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lcjtcblxuLyoqXG4gKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIGFkZENoaWxkXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgIHJldHVybiB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcblxufTtcblxuLyoqXG4gKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lciBhdCBhIHNwZWNpZmllZCBpbmRleC4gSWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqXG4gKiBAbWV0aG9kIGFkZENoaWxkQXRcbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRvIGFkZFxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBwbGFjZSB0aGUgY2hpbGQgaW5cbiAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAqL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5hZGRDaGlsZEF0ID0gZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoaWxkICsgJ2FkZENoaWxkQXQ6IFRoZSBpbmRleCAnKyBpbmRleCArJyBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzICcgKyB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gKlxuICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5cbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH1cbiAqIEBwYXJhbSBjaGlsZDIge0Rpc3BsYXlPYmplY3R9XG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkLCBjaGlsZDIpIHtcblxuICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHZhciBpbmRleDIgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQyKTtcblxuICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N3YXBDaGlsZHJlbjogQm90aCB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdHMgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDFdID0gY2hpbGQyO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgZ2V0Q2hpbGRJbmRleFxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB0byBpZGVudGlmeVxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdXBwbGllZCBEaXNwbGF5T2JqZWN0IG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgY2FsbGVyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuXG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAqXG4gKiBAbWV0aG9kIHNldENoaWxkSW5kZXhcbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIHJlc3VsdGluZyBpbmRleCBudW1iZXIgZm9yIHRoZSBjaGlsZCBkaXNwbGF5IG9iamVjdFxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3VwcGxpZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoY3VycmVudEluZGV4LCAxKTsgLy9yZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpOyAvL2FkZCBhdCBuZXcgcG9zaXRpb25cblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gKlxuICogQG1ldGhvZCBnZXRDaGlsZEF0XG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmdldENoaWxkQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoaWxkQXQ6IFN1cHBsaWVkIGluZGV4ICcrIGluZGV4ICsnIGRvZXMgbm90IGV4aXN0IGluIHRoZSBjaGlsZCBsaXN0LCBvciB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlcicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgICBcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KGluZGV4KTtcblxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblxuICAgIHZhciBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XG5cbiAgICBpZiAoY2hpbGQpXG4gICAge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcblxufTtcblxuLyoqXG4qIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBjb250YWluZXIgdGhhdCBhcmUgd2l0aGluIHRoZSBiZWdpbiBhbmQgZW5kIGluZGV4ZXMuXG4qXG4qIEBtZXRob2QgcmVtb3ZlQ2hpbGRyZW5cbiogQHBhcmFtIGJlZ2luSW5kZXgge051bWJlcn0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyAwLlxuKiBAcGFyYW0gZW5kSW5kZXgge051bWJlcn0gVGhlIGVuZGluZyBwb3NpdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyBzaXplIG9mIHRoZSBjb250YWluZXIuXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleCkge1xuXG4gICAgaWYgKGJlZ2luSW5kZXggPT09IHVuZGVmaW5lZCkgeyBiZWdpbkluZGV4ID0gMDsgfVxuICAgIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IGVuZEluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IH1cblxuICAgIHZhciByYW5nZSA9IGVuZEluZGV4IC0gYmVnaW5JbmRleDtcblxuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGJlZ2luSW5kZXgsIHJhbmdlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHJlbW92ZWRbaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggJ3JlbW92ZUNoaWxkcmVuOiBSYW5nZSBFcnJvciwgbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UnICk7XG4gICAgfVxuXG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUcmFuc2Zvcm1cbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLnZpc2libGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxufTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0Q29udGFpbmVyVXBkYXRlVHJhbnNmb3JtID0gUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBnbG9iYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0Q29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIGFsbCB2aXNpYmxlIGNoaWxkcmVuIGludG8gY29uc2lkZXJhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldEJvdW5kc1xuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5NYXRyaXh9IFt0YXJnZXRDb29yZGluYXRlU3BhY2VdIFJldHVybnMgYSByZWN0YW5nbGUgdGhhdCBkZWZpbmVzIHRoZSBhcmVhIG9mIHRoZSBkaXNwbGF5IG9iamVjdCByZWxhdGl2ZSB0byB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIHRhcmdldENvb3JkaW5hdGVTcGFjZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHRhcmdldENvb3JkaW5hdGVTcGFjZSkge1xuXG4gICAgdmFyIGlzVGFyZ2V0Q29vcmRpbmF0ZVNwYWNlRGlzcGxheU9iamVjdCA9ICh0YXJnZXRDb29yZGluYXRlU3BhY2UgJiYgdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlIGluc3RhbmNlb2YgUElYSS5EaXNwbGF5T2JqZWN0KTtcbiAgICB2YXIgaXNUYXJnZXRDb29yZGluYXRlU3BhY2VUaGlzT3JQYXJlbnQgPSB0cnVlO1xuXG4gICAgaWYgKCFpc1RhcmdldENvb3JkaW5hdGVTcGFjZURpc3BsYXlPYmplY3QpIFxuXHR7XG4gICAgICAgIHRhcmdldENvb3JkaW5hdGVTcGFjZSA9IHRoaXM7XG4gICAgfSBcblx0ZWxzZSBpZiAodGFyZ2V0Q29vcmRpbmF0ZVNwYWNlIGluc3RhbmNlb2YgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyKSBcblx0e1xuICAgICAgICBpc1RhcmdldENvb3JkaW5hdGVTcGFjZVRoaXNPclBhcmVudCA9IHRhcmdldENvb3JkaW5hdGVTcGFjZS5jb250YWlucyh0aGlzKTtcbiAgICB9IFxuXHRlbHNlIFxuXHR7XG4gICAgICAgIGlzVGFyZ2V0Q29vcmRpbmF0ZVNwYWNlVGhpc09yUGFyZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAoaXNUYXJnZXRDb29yZGluYXRlU3BhY2VEaXNwbGF5T2JqZWN0KVxuICAgIHtcbiAgICAgICAgdmFyIG1hdHJpeENhY2hlID0gdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgIHRhcmdldENvb3JkaW5hdGVTcGFjZS53b3JsZFRyYW5zZm9ybSA9IFBJWEkuaWRlbnRpdHlNYXRyaXg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhcmdldENvb3JkaW5hdGVTcGFjZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykgXG5cdFx0e1xuICAgICAgICAgICAgdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgY2hpbGRCb3VuZHM7XG4gICAgdmFyIGNoaWxkTWF4WDtcbiAgICB2YXIgY2hpbGRNYXhZO1xuXG4gICAgdmFyIGNoaWxkVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmICghY2hpbGQudmlzaWJsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZFZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIGNoaWxkQm91bmRzID0gdGhpcy5jaGlsZHJlbltpXS5nZXRCb3VuZHMoKTtcblxuICAgICAgICBtaW5YID0gKG1pblggPCBjaGlsZEJvdW5kcy54KSA/IG1pblggOiBjaGlsZEJvdW5kcy54O1xuICAgICAgICBtaW5ZID0gKG1pblkgPCBjaGlsZEJvdW5kcy55KSA/IG1pblkgOiBjaGlsZEJvdW5kcy55O1xuXG4gICAgICAgIGNoaWxkTWF4WCA9IGNoaWxkQm91bmRzLndpZHRoICsgY2hpbGRCb3VuZHMueDtcbiAgICAgICAgY2hpbGRNYXhZID0gY2hpbGRCb3VuZHMuaGVpZ2h0ICsgY2hpbGRCb3VuZHMueTtcblxuICAgICAgICBtYXhYID0gKG1heFggPiBjaGlsZE1heFgpID8gbWF4WCA6IGNoaWxkTWF4WDtcbiAgICAgICAgbWF4WSA9IChtYXhZID4gY2hpbGRNYXhZKSA/IG1heFkgOiBjaGlsZE1heFk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGlmICghY2hpbGRWaXNpYmxlKSBcblx0e1xuICAgICAgICBib3VuZHMgPSBuZXcgUElYSS5SZWN0YW5nbGUoKTtcblxuICAgICAgICB2YXIgdzAgPSBib3VuZHMueDtcbiAgICAgICAgdmFyIHcxID0gYm91bmRzLndpZHRoICsgYm91bmRzLng7XG5cbiAgICAgICAgdmFyIGgwID0gYm91bmRzLnk7XG4gICAgICAgIHZhciBoMSA9IGJvdW5kcy5oZWlnaHQgKyBib3VuZHMueTtcblxuICAgICAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICAgICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgICAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICAgICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuXG4gICAgICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICB2YXIgeTEgPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgICAgICB2YXIgeDIgPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICAgICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgdmFyIHgzID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIHZhciB4NCA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgICAgICB2YXIgeTQgPSBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICBtYXhYID0geDE7XG4gICAgICAgIG1heFkgPSB5MTtcblxuICAgICAgICBtaW5YID0geDE7XG4gICAgICAgIG1pblkgPSB5MTtcblxuICAgICAgICBtaW5YID0geDIgPCBtaW5YID8geDIgOiBtaW5YO1xuICAgICAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgICAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XG4gICAgICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICAgICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgICAgICBtYXhZID0geTIgPiBtYXhZID8geTIgOiBtYXhZO1xuICAgICAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgICAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuICAgIH1cblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMueSA9IG1pblk7XG4gICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgaWYgKGlzVGFyZ2V0Q29vcmRpbmF0ZVNwYWNlRGlzcGxheU9iamVjdCkgXG5cdHtcbiAgICAgICAgdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlLndvcmxkVHJhbnNmb3JtID0gbWF0cml4Q2FjaGU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhcmdldENvb3JkaW5hdGVTcGFjZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykgXG5cdFx0e1xuICAgICAgICAgICAgdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1RhcmdldENvb3JkaW5hdGVTcGFjZVRoaXNPclBhcmVudCkgXG5cdHtcbiAgICAgICAgdmFyIHRhcmdldENvb3JkaW5hdGVTcGFjZUJvdW5kcyA9IHRhcmdldENvb3JkaW5hdGVTcGFjZS5nZXRCb3VuZHMoKTtcblxuICAgICAgICBib3VuZHMueCAtPSB0YXJnZXRDb29yZGluYXRlU3BhY2VCb3VuZHMueDtcbiAgICAgICAgYm91bmRzLnkgLT0gdGFyZ2V0Q29vcmRpbmF0ZVNwYWNlQm91bmRzLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kcztcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIG5vbi1nbG9iYWwgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0Q29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlIHdpdGhvdXQgYW55IHRyYW5zZm9ybWF0aW9ucy4gVGhlIGNhbGN1bGF0aW9uIHRha2VzIGFsbCB2aXNpYmxlIGNoaWxkcmVuIGludG8gY29uc2lkZXJhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldExvY2FsQm91bmRzXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cblBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHModGhpcyk7XG5cbn07XG5cbi8qKlxuKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCBpcyBhIGNoaWxkIG9mIHRoZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGluc3RhbmNlIG9yIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4qXG4qIEBtZXRob2QgY29udGFpbnNcbiogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZFxuKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5QSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGNoaWxkKSB7XG5cbiAgICBpZiAoIWNoaWxkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZCA9PT0gdGhpcykgXG5cdHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgXG5cdHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoY2hpbGQucGFyZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyU2Vzc2lvbikge1xuXG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcClcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhY2hlZFNwcml0ZShyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaTtcblxuICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuX2ZpbHRlcnMpXG4gICAge1xuICAgICAgICAvLyBwdXNoIGZpbHRlciBmaXJzdCBhcyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXMgY29ycmVjdCBmb3IgYW55IG1hc2tpbmdcbiAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guZmx1c2goKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVyKHRoaXMuX2ZpbHRlckJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2guc3RvcCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2sodGhpcy5fbWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJzKSByZW5kZXJTZXNzaW9uLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG4gICAgICAgIFxuICAgICAgICByZW5kZXJTZXNzaW9uLnNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIHNpbXBsZSByZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJXZWJHTChyZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4qIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qXG4qIEBtZXRob2QgX3JlbmRlckNhbnZhc1xuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwcml2YXRlXG4qL1xuUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlclNlc3Npb24pIHtcblxuICAgIGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlIHx8IHRoaXMuYWxwaGEgPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXJDYWNoZWRTcHJpdGUocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFzaylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5fbWFzaywgcmVuZGVyU2Vzc2lvbik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyQ2FudmFzKHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBUaGUgd2lkdGggb2YgdGhlIGRpc3BsYXlPYmplY3RDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUsICd3aWR0aCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGggKiB0aGlzLnNjYWxlLng7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcblxuICAgICAgICBpZiAod2lkdGggIT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXlPYmplY3RDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IGhlaWdodFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIucHJvdG90eXBlLCAnaGVpZ2h0Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQgKiB0aGlzLnNjYWxlLnk7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcblxuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG5cbn0pO1xuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBUaGUgU3ByaXRlIG9iamVjdCBpcyB0aGUgYmFzZSBmb3IgYWxsIHRleHR1cmVkIG9iamVjdHMgdGhhdCBhcmUgcmVuZGVyZWQgdG8gdGhlIHNjcmVlblxuICpcbiAqIEBjbGFzcyBTcHJpdGVcbiAqIEBleHRlbmRzIERpc3BsYXlPYmplY3RDb250YWluZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIGZvciB0aGlzIHNwcml0ZVxuICovXG5QSVhJLlNwcml0ZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG5cbiAgICBQSVhJLkRpc3BsYXlPYmplY3RDb250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAqIFNldHRpbmcgdGhhbiBhbmNob3IgdG8gMC41LDAuNSBtZWFucyB0aGUgdGV4dHVyZXMgb3JpZ2luIGlzIGNlbnRlcmVkXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDEsMSB3b3VsZCBtZWFuIHRoZSB0ZXh0dXJlcyBvcmlnaW4gcG9pbnRzIHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBhbmNob3JcbiAgICAgKiBAdHlwZSBQb2ludFxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yID0gbmV3IFBJWEkuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVcbiAgICAgKiBAdHlwZSBUZXh0dXJlXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZSB8fCBQSVhJLlRleHR1cmUuZW1wdHlUZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBfd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IF9oZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRpbnRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjYWNoZWRUaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVkVGludCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQSBjYW52YXMgdGhhdCBjb250YWlucyB0aGUgdGludGVkIHZlcnNpb24gb2YgdGhlIFNwcml0ZSAoaW4gQ2FudmFzIG1vZGUsIFdlYkdMIGRvZXNuJ3QgcG9wdWxhdGUgdGhpcylcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW50ZWRUZXh0dXJlXG4gICAgICogQHR5cGUgQ2FudmFzXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRoaXMudGludGVkVGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFNldCB0byBQSVhJLmJsZW5kTW9kZXMuTk9STUFMIHRvIHJlbW92ZSBhbnkgYmxlbmQgbW9kZS5cbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IFlvdSBjYW5ub3QgaGF2ZSBhIGJsZW5kIG1vZGUgYW5kIGEgZmlsdGVyIGFjdGl2ZSBvbiB0aGUgc2FtZSBTcHJpdGUuIERvaW5nIHNvIHdpbGwgcmVuZGVyIHRoZSBzcHJpdGUgaW52aXNpYmxlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJsZW5kTW9kZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IFBJWEkuYmxlbmRNb2Rlcy5OT1JNQUw7XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBQSVhJLmJsZW5kTW9kZXMuTk9STUFMO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYWRlciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhpcyBTcHJpdGUuXG4gICAgICogU2V0IHRvIG51bGwgdG8gcmVtb3ZlIGEgY3VycmVudCBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2hhZGVyXG4gICAgICogQHR5cGUgUGhhc2VyLkZpbHRlclxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIENvbnRyb2xzIGlmIHRoaXMgU3ByaXRlIGlzIHByb2Nlc3NlZCBieSB0aGUgY29yZSBQaGFzZXIgZ2FtZSBsb29wcyBhbmQgR3JvdXAgbG9vcHMuXG4gICAgKlxuICAgICogQHByb3BlcnR5IGV4aXN0c1xuICAgICogQHR5cGUgQm9vbGVhblxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgdGhpcy5leGlzdHMgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICB0aGlzLm9uVGV4dHVyZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XG5cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBJWEkuRGlzcGxheU9iamVjdENvbnRhaW5lci5wcm90b3R5cGUpO1xuUElYSS5TcHJpdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TcHJpdGU7XG5cbi8qKlxuICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gKlxuICogQHByb3BlcnR5IHdpZHRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuU3ByaXRlLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG5cbn0pO1xuXG4vKipcbiAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAqXG4gKiBAcHJvcGVydHkgaGVpZ2h0XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBJWEkuU3ByaXRlLnByb3RvdHlwZSwgJ2hlaWdodCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMudGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogU2V0cyB0aGUgdGV4dHVyZSBvZiB0aGUgc3ByaXRlLiBCZSB3YXJuZWQgdGhhdCB0aGlzIGRvZXNuJ3QgcmVtb3ZlIG9yIGRlc3Ryb3kgdGhlIHByZXZpb3VzXG4gKiB0ZXh0dXJlIHRoaXMgU3ByaXRlIHdhcyB1c2luZy5cbiAqXG4gKiBAbWV0aG9kIHNldFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgUElYSSB0ZXh0dXJlIHRoYXQgaXMgZGlzcGxheWVkIGJ5IHRoZSBzcHJpdGVcbiAqIEBwYXJhbSBbZGVzdHJveT1mYWxzZV0ge2Jvb2xlYW59IENhbGwgVGV4dHVyZS5kZXN0cm95IG9uIHRoZSBjdXJyZW50IHRleHR1cmUgYmVmb3JlIHJlcGxhY2luZyBpdCB3aXRoIHRoZSBuZXcgb25lP1xuICovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUsIGRlc3Ryb3lCYXNlKVxue1xuICAgIGlmIChkZXN0cm95QmFzZSAhPT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyAgT3Zlci1yaWRkZW4gYnkgbG9hZFRleHR1cmUgYXMgbmVlZGVkXG4gICAgdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNraXBSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMudGV4dHVyZS52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5jYWNoZWRUaW50ID0gLTE7XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAqXG4gKiBAbWV0aG9kIG9uVGV4dHVyZVVwZGF0ZVxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUub25UZXh0dXJlVXBkYXRlID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIHNvIGlmIF93aWR0aCBpcyAwIHRoZW4gd2lkdGggd2FzIG5vdCBzZXQuLlxuICAgIGlmICh0aGlzLl93aWR0aCkgdGhpcy5zY2FsZS54ID0gdGhpcy5fd2lkdGggLyB0aGlzLnRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgaWYgKHRoaXMuX2hlaWdodCkgdGhpcy5zY2FsZS55ID0gdGhpcy5faGVpZ2h0IC8gdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIFNwcml0ZSBhcyBhIHJlY3RhbmdsZS5cbiogVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxuKlxuKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHRoZSB0cmFuc2Zvcm0gaXMgbm90IHVwZGF0ZWQgd2hlbiB5b3UgY2FsbCB0aGlzIG1ldGhvZC5cbiogU28gaWYgdGhpcyBTcHJpdGUgaXMgdGhlIGNoaWxkIG9mIGEgRGlzcGxheSBPYmplY3Qgd2hpY2ggaGFzIGhhZCBpdHMgdHJhbnNmb3JtXG4qIHVwZGF0ZWQgc2luY2UgdGhlIGxhc3QgcmVuZGVyIHBhc3MsIHRob3NlIGNoYW5nZXMgd2lsbCBub3QgeWV0IGhhdmUgYmVlbiBhcHBsaWVkXG4qIHRvIHRoaXMgU3ByaXRlcyB3b3JsZFRyYW5zZm9ybS4gSWYgeW91IG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIHBhcmVudCB0cmFuc2Zvcm1zXG4qIGFyZSBmYWN0b3JlZCBpbnRvIHRoaXMgZ2V0Qm91bmRzIG9wZXJhdGlvbiB0aGVuIHlvdSBzaG91bGQgY2FsbCBgdXBkYXRlVHJhbnNmb3JtYFxuKiBvbiB0aGUgcm9vdCBtb3N0IG9iamVjdCBpbiB0aGlzIFNwcml0ZXMgZGlzcGxheSBsaXN0IGZpcnN0LlxuKlxuKiBAbWV0aG9kIGdldEJvdW5kc1xuKiBAcGFyYW0gbWF0cml4IHtNYXRyaXh9IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHNwcml0ZVxuKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgpXG57XG4gICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMClcbiAgICB7XG4gICAgICAgIC8vIHNjYWxlIG1heSBiZSBuZWdhdGl2ZSFcbiAgICAgICAgaWYgKGEgPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBhICo9IC0xO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB3MDtcbiAgICAgICAgICAgIHcwID0gLXcxO1xuICAgICAgICAgICAgdzEgPSAtdGVtcDsgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGQgKj0gLTE7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGgwO1xuICAgICAgICAgICAgaDAgPSAtaDE7XG4gICAgICAgICAgICBoMSA9IC10ZW1wOyBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhlcmUgaXMgbm8gcm90YXRpb24gZ29pbmcgb24gcmlnaHQ/IFJJR0hUP1xuICAgICAgICAvLyBpZiB0aGF0cyB0aGUgY2FzZSB0aGVuIHdlIGNhbiBhdm9pZCBjaGVja2luZyB0aGUgYm91bmQgdmFsdWVzISB5YXkgICAgICAgICBcbiAgICAgICAgbWluWCA9IGEgKiB3MSArIHR4O1xuICAgICAgICBtYXhYID0gYSAqIHcwICsgdHg7XG4gICAgICAgIG1pblkgPSBkICogaDEgKyB0eTtcbiAgICAgICAgbWF4WSA9IGQgKiBoMCArIHR5O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICAgICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICBtaW5YID0geDEgPCBtaW5YID8geDEgOiBtaW5YO1xuICAgICAgICBtaW5YID0geDIgPCBtaW5YID8geDIgOiBtaW5YO1xuICAgICAgICBtaW5YID0geDMgPCBtaW5YID8geDMgOiBtaW5YO1xuICAgICAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgICAgIG1pblkgPSB5MSA8IG1pblkgPyB5MSA6IG1pblk7XG4gICAgICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgICAgIG1pblkgPSB5MyA8IG1pblkgPyB5MyA6IG1pblk7XG4gICAgICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICAgICAgbWF4WCA9IHgxID4gbWF4WCA/IHgxIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHgyID4gbWF4WCA/IHgyIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICAgICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgICAgICBtYXhZID0geTEgPiBtYXhZID8geTEgOiBtYXhZO1xuICAgICAgICBtYXhZID0geTIgPiBtYXhZID8geTIgOiBtYXhZO1xuICAgICAgICBtYXhZID0geTMgPiBtYXhZID8geTMgOiBtYXhZO1xuICAgICAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuICAgIH1cblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICBib3VuZHMueCA9IG1pblg7XG4gICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICBib3VuZHMueSA9IG1pblk7XG4gICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBub24tZ2xvYmFsIGxvY2FsIGJvdW5kcyBvZiB0aGUgU3ByaXRlIGFzIGEgcmVjdGFuZ2xlLiBUaGUgY2FsY3VsYXRpb24gdGFrZXMgYWxsIHZpc2libGUgY2hpbGRyZW4gaW50byBjb25zaWRlcmF0aW9uLlxuICpcbiAqIEBtZXRob2QgZ2V0TG9jYWxCb3VuZHNcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuUElYSS5TcHJpdGUucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hdHJpeENhY2hlID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBQSVhJLmlkZW50aXR5TWF0cml4O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhDYWNoZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRzO1xuXG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuKlxuKiBAbWV0aG9kIF9yZW5kZXJXZWJHTFxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn1cbiogQHBhcmFtIHtNYXRyaXh9IFttYXRyaXhdIC0gT3B0aW9uYWwgbWF0cml4LiBJZiBwcm92aWRlZCB0aGUgRGlzcGxheSBPYmplY3Qgd2lsbCBiZSByZW5kZXJlZCB1c2luZyB0aGlzIG1hdHJpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIGl0cyB3b3JsZFRyYW5zZm9ybS5cbiogQHByaXZhdGVcbiovXG5QSVhJLlNwcml0ZS5wcm90b3R5cGUuX3JlbmRlcldlYkdMID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbiwgbWF0cml4KVxue1xuICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLmFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkgcmV0dXJuO1xuXG4gICAgLy8gIFRoZXkgcHJvdmlkZWQgYW4gYWx0ZXJuYXRpdmUgcmVuZGVyaW5nIG1hdHJpeCwgc28gdXNlIGl0XG4gICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIGlmIChtYXRyaXgpXG4gICAge1xuICAgICAgICB3dCA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICAvLyAgQSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgaWYgKHRoaXMuX21hc2sgfHwgdGhpcy5fZmlsdGVycylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGVCYXRjaCA9IHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2g7XG5cbiAgICAgICAgLy8gcHVzaCBmaWx0ZXIgZmlyc3QgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIGNvcnJlY3QgZm9yIGFueSBtYXNraW5nXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBzcHJpdGVCYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGhpcy5fZmlsdGVyQmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNwcml0ZUJhdGNoLnN0b3AoKTtcbiAgICAgICAgICAgIHJlbmRlclNlc3Npb24ubWFza01hbmFnZXIucHVzaE1hc2sodGhpcy5tYXNrLCByZW5kZXJTZXNzaW9uKTtcbiAgICAgICAgICAgIHNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhpcyBzcHJpdGUgdG8gdGhlIGJhdGNoXG4gICAgICAgIHNwcml0ZUJhdGNoLnJlbmRlcih0aGlzKTtcblxuICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgbWFrZSBzdXJlIHRoZXkgZ2V0IHJlbmRlcmVkXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lIHRvIHN0b3AgdGhlIHNwcml0ZSBiYXRjaCBhcyBlaXRoZXIgYSBtYXNrIGVsZW1lbnQgb3IgYSBmaWx0ZXIgZHJhdyB3aWxsIGhhcHBlbiBuZXh0XG4gICAgICAgIHNwcml0ZUJhdGNoLnN0b3AoKTtcblxuICAgICAgICBpZiAodGhpcy5fbWFzaykgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVycykgcmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuXG4gICAgICAgIHNwcml0ZUJhdGNoLnN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uc3ByaXRlQmF0Y2gucmVuZGVyKHRoaXMpO1xuXG4gICAgICAgIC8vICBSZW5kZXIgY2hpbGRyZW4hXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5fcmVuZGVyV2ViR0wocmVuZGVyU2Vzc2lvbiwgd3QpO1xuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQG1ldGhvZCBfcmVuZGVyQ2FudmFzXG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtSZW5kZXJTZXNzaW9ufVxuKiBAcGFyYW0ge01hdHJpeH0gW21hdHJpeF0gLSBPcHRpb25hbCBtYXRyaXguIElmIHByb3ZpZGVkIHRoZSBEaXNwbGF5IE9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIHRoaXMgbWF0cml4LCBvdGhlcndpc2UgaXQgd2lsbCB1c2UgaXRzIHdvcmxkVHJhbnNmb3JtLlxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbiwgbWF0cml4KVxue1xuICAgIC8vIElmIHRoZSBzcHJpdGUgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLmFscGhhID09PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUgfHwgdGhpcy50ZXh0dXJlLmNyb3Aud2lkdGggPD0gMCB8fCB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgLy8gIElmIHRoZXkgcHJvdmlkZWQgYW4gYWx0ZXJuYXRpdmUgcmVuZGVyaW5nIG1hdHJpeCB0aGVuIHVzZSBpdFxuICAgIGlmIChtYXRyaXgpXG4gICAge1xuICAgICAgICB3dCA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gUElYSS5ibGVuZE1vZGVzQ2FudmFzW3JlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnB1c2hNYXNrKHRoaXMuX21hc2ssIHJlbmRlclNlc3Npb24pO1xuICAgIH1cblxuICAgIC8vICBJZ25vcmUgbnVsbCBzb3VyY2VzXG4gICAgaWYgKCF0aGlzLnRleHR1cmUudmFsaWQpXG4gICAge1xuICAgICAgICAvLyAgVXBkYXRlIHRoZSBjaGlsZHJlbiBhbmQgbGVhdmVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJDYW52YXMocmVuZGVyU2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyU2Vzc2lvbi5tYXNrTWFuYWdlci5wb3BNYXNrKHJlbmRlclNlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb24gLyByZW5kZXJTZXNzaW9uLnJlc29sdXRpb247XG5cbiAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICAvLyAgSWYgc21vb3RoaW5nRW5hYmxlZCBpcyBzdXBwb3J0ZWQgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBzbW9vdGhpbmcgcHJvcGVydHkgZm9yIHRoaXMgdGV4dHVyZVxuICAgIGlmIChyZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5ICYmIHJlbmRlclNlc3Npb24uc2NhbGVNb2RlICE9PSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlKVxuICAgIHtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zY2FsZU1vZGUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlO1xuICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHRbcmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eV0gPSAocmVuZGVyU2Vzc2lvbi5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIpO1xuICAgIH1cblxuICAgIC8vICBJZiB0aGUgdGV4dHVyZSBpcyB0cmltbWVkIHdlIG9mZnNldCBieSB0aGUgdHJpbSB4L3ksIG90aGVyd2lzZSB3ZSB1c2UgdGhlIGZyYW1lIGRpbWVuc2lvbnNcbiAgICB2YXIgZHggPSAodGhpcy50ZXh0dXJlLnRyaW0pID8gdGhpcy50ZXh0dXJlLnRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0aGlzLnRleHR1cmUudHJpbS53aWR0aCA6IHRoaXMuYW5jaG9yLnggKiAtdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIHZhciBkeSA9ICh0aGlzLnRleHR1cmUudHJpbSkgPyB0aGlzLnRleHR1cmUudHJpbS55IC0gdGhpcy5hbmNob3IueSAqIHRoaXMudGV4dHVyZS50cmltLmhlaWdodCA6IHRoaXMuYW5jaG9yLnkgKiAtdGhpcy50ZXh0dXJlLmZyYW1lLmhlaWdodDtcblxuICAgIHZhciB0eCA9ICh3dC50eCAqIHJlbmRlclNlc3Npb24ucmVzb2x1dGlvbikgKyByZW5kZXJTZXNzaW9uLnNoYWtlWDtcbiAgICB2YXIgdHkgPSAod3QudHkgKiByZW5kZXJTZXNzaW9uLnJlc29sdXRpb24pICsgcmVuZGVyU2Vzc2lvbi5zaGFrZVk7XG5cbiAgICB2YXIgY3cgPSB0aGlzLnRleHR1cmUuY3JvcC53aWR0aDtcbiAgICB2YXIgY2ggPSB0aGlzLnRleHR1cmUuY3JvcC5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy50ZXh0dXJlLnJvdGF0ZWQpXG4gICAge1xuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciBlID0gY3c7XG4gICAgICAgIFxuICAgICAgICAvLyBPZmZzZXQgYmVmb3JlIHJvdGF0aW5nXG4gICAgICAgIHR4ID0gd3QuYyAqIGNoICsgdHg7XG4gICAgICAgIHR5ID0gd3QuZCAqIGNoICsgdHk7XG4gICAgICAgIFxuICAgICAgICAvLyBSb3RhdGUgbWF0cml4IGJ5IDkwIGRlZ3JlZXNcbiAgICAgICAgLy8gV2UgdXNlIHByZWNhbGN1bGF0ZWQgdmFsdWVzIGZvciBzaW5lIGFuZCBjb3NpbmUgb2YgcmFkKDkwKVxuICAgICAgICB3dC5hID0gYSAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNyArIC1jO1xuICAgICAgICB3dC5iID0gYiAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNyArIC1kO1xuICAgICAgICB3dC5jID0gYSArIGMgKiA2LjEyMzIzMzk5NTczNjc2NmUtMTc7XG4gICAgICAgIHd0LmQgPSBiICsgZCAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNztcblxuICAgICAgICAvLyBVcGRhdGUgY3JvcHBpbmcgZGltZW5zaW9ucy5cbiAgICAgICAgY3cgPSBjaDtcbiAgICAgICAgY2ggPSBlO1xuICAgIH1cblxuICAgIC8vICBBbGxvdyBmb3IgcGl4ZWwgcm91bmRpbmdcbiAgICBpZiAocmVuZGVyU2Vzc2lvbi5yb3VuZFBpeGVscylcbiAgICB7XG4gICAgICAgIHJlbmRlclNlc3Npb24uY29udGV4dC5zZXRUcmFuc2Zvcm0od3QuYSwgd3QuYiwgd3QuYywgd3QuZCwgdHggfCAwLCB0eSB8IDApO1xuICAgICAgICBkeCB8PSAwO1xuICAgICAgICBkeSB8PSAwO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuc2V0VHJhbnNmb3JtKHd0LmEsIHd0LmIsIHd0LmMsIHd0LmQsIHR4LCB0eSk7XG4gICAgfVxuXG4gICAgZHggLz0gcmVzb2x1dGlvbjtcbiAgICBkeSAvPSByZXNvbHV0aW9uO1xuXG4gICAgaWYgKHRoaXMudGludCAhPT0gMHhGRkZGRkYpXG4gICAge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlLnJlcXVpcmVzUmVUaW50IHx8IHRoaXMuY2FjaGVkVGludCAhPT0gdGhpcy50aW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpbnRlZFRleHR1cmUgPSBQSVhJLkNhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlKHRoaXMsIHRoaXMudGludCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IHRoaXMudGludDtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5yZXF1aXJlc1JlVGludCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnRpbnRlZFRleHR1cmUsIDAsIDAsIGN3LCBjaCwgZHgsIGR5LCBjdyAvIHJlc29sdXRpb24sIGNoIC8gcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMudGV4dHVyZS5jcm9wLng7XG4gICAgICAgIHZhciBjeSA9IHRoaXMudGV4dHVyZS5jcm9wLnk7XG4gICAgICAgIFxuICAgICAgICBjdyA9IE1hdGguZmxvb3IoY3cpXG4gICAgICAgIGNoID0gTWF0aC5mbG9vcihjaClcblxuICAgICAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGN4LCBjeSwgY3csIGNoLCBkeCwgZHksIGN3IC8gcmVzb2x1dGlvbiwgY2ggLyByZXNvbHV0aW9uKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLl9yZW5kZXJDYW52YXMocmVuZGVyU2Vzc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJTZXNzaW9uLm1hc2tNYW5hZ2VyLnBvcE1hc2socmVuZGVyU2Vzc2lvbik7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAbWV0aG9kIGluaXREZWZhdWx0U2hhZGVyc1xuKiBAc3RhdGljXG4qIEBwcml2YXRlXG4qL1xuUElYSS5pbml0RGVmYXVsdFNoYWRlcnMgPSBmdW5jdGlvbigpXG57XG59O1xuXG4vKipcbiogQG1ldGhvZCBDb21waWxlVmVydGV4U2hhZGVyXG4qIEBzdGF0aWNcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKiBAcGFyYW0gc2hhZGVyU3JjIHtBcnJheX1cbiogQHJldHVybiB7QW55fVxuKi9cblBJWEkuQ29tcGlsZVZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTcmMpXG57XG4gICAgcmV0dXJuIFBJWEkuX0NvbXBpbGVTaGFkZXIoZ2wsIHNoYWRlclNyYywgZ2wuVkVSVEVYX1NIQURFUik7XG59O1xuXG4vKipcbiogQG1ldGhvZCBDb21waWxlRnJhZ21lbnRTaGFkZXJcbiogQHN0YXRpY1xuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qIEBwYXJhbSBzaGFkZXJTcmMge0FycmF5fVxuKiBAcmV0dXJuIHtBbnl9XG4qL1xuUElYSS5Db21waWxlRnJhZ21lbnRTaGFkZXIgPSBmdW5jdGlvbihnbCwgc2hhZGVyU3JjKVxue1xuICAgIHJldHVybiBQSVhJLl9Db21waWxlU2hhZGVyKGdsLCBzaGFkZXJTcmMsIGdsLkZSQUdNRU5UX1NIQURFUik7XG59O1xuXG4vKipcbiogQG1ldGhvZCBfQ29tcGlsZVNoYWRlclxuKiBAc3RhdGljXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHBhcmFtIHNoYWRlclNyYyB7QXJyYXl9XG4qIEBwYXJhbSBzaGFkZXJUeXBlIHtOdW1iZXJ9XG4qIEByZXR1cm4ge0FueX1cbiovXG5QSVhJLl9Db21waWxlU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNyYywgc2hhZGVyVHlwZSlcbntcbiAgICB2YXIgc3JjID0gc2hhZGVyU3JjO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2hhZGVyU3JjKSlcbiAgICB7XG4gICAgICAgIHNyYyA9IHNoYWRlclNyYy5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxuLyoqXG4qIEBtZXRob2QgY29tcGlsZVByb2dyYW1cbiogQHN0YXRpY1xuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qIEBwYXJhbSB2ZXJ0ZXhTcmMge0FycmF5fVxuKiBAcGFyYW0gZnJhZ21lbnRTcmMge0FycmF5fVxuKiBAcmV0dXJuIHtBbnl9XG4qL1xuUElYSS5jb21waWxlUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKVxue1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IFBJWEkuQ29tcGlsZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNyYyk7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IFBJWEkuQ29tcGlsZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U3JjKTtcblxuICAgIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXJQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSkpO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCJDb3VsZCBub3QgaW5pdGlhbGlzZSBzaGFkZXJzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJQcm9ncmFtO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqIEBhdXRob3IgUmljaGFyZCBEYXZleSBodHRwOi8vd3d3LnBob3RvbnN0b3JtLmNvbSBAcGhvdG9uc3Rvcm1cbiAqL1xuXG4vKipcbiogQGNsYXNzIFBpeGlTaGFkZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLlBpeGlTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgX1VJRFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fVUlEID0gUGhhc2VyLl9VSUQrKztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqIEBwcm9wZXJ0eSBwcm9ncmFtXG4gICAgICogQHR5cGUgQW55XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICogQHByb3BlcnR5IGZyYWdtZW50U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U3JjID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgdGV4dHVyZSBjb3VudGVyIGZvciBtdWx0aS10ZXh0dXJlIHNoYWRlcnMuXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVDb3VudFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgZmxhZ1xuICAgICAqIEBwcm9wZXJ0eSBmaXJzdFJ1blxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3RSdW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQSBkaXJ0eSBmbGFnXG4gICAgICogQHByb3BlcnR5IGRpcnR5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVW5pZm9ybSBhdHRyaWJ1dGVzIGNhY2hlLlxuICAgICAqIEBwcm9wZXJ0eSBhdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5QaXhpU2hhZGVyO1xuXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXRNdWx0aXRleFNoYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB2YXIgZHluYW1pY0lmcyA9ICdcXHRpZiAodlRleHR1cmVJbmRleCA9PSAwLjApIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlckFycmF5WzBdLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcXG4nXG4gICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IHRoaXMuTUFYX1RFWFRVUkVTOyArK2luZGV4KVxuICAgIHtcbiAgICAgICAgZHluYW1pY0lmcyArPSAnXFx0ZWxzZSBpZiAodlRleHR1cmVJbmRleCA9PSAnICsgXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICsgJy4wKSBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJBcnJheVsnICsgXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICsgJ10sIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xcbidcbiAgICB9XG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJy8vIFBpeGlTaGFkZXIgRnJhZ21lbnQgU2hhZGVyLicsXG4gICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAnYm9vbCBpc25hbiggZmxvYXQgdmFsICkgeyAgcmV0dXJuICggdmFsIDwgMC4wIHx8IDAuMCA8IHZhbCB8fCB2YWwgPT0gMC4wICkgPyBmYWxzZSA6IHRydWU7IH0nLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJbmRleDsnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJBcnJheVsnICsgdGhpcy5NQVhfVEVYVFVSRVMgKyAnXTsnLFxuICAgICAgICAvLyBCbHVlIGNvbG9yIG1lYW5zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gYm91bmRcbiAgICAgICAgLy8gYSB0ZXh0dXJlIG91dCBvZiB0aGUgbGltaXRzIG9mIHRoZSBoYXJkd2FyZS5cbiAgICAgICAgJ2NvbnN0IHZlYzQgQkxVRSA9IHZlYzQoMS4wLCAwLjAsIDEuMCwgMS4wKTsnLFxuICAgICAgICAvLyBJZiB5b3UgZ2V0IGEgcmVkIGNvbG9yIG1lYW5zIHlvdSBhcmUgb3V0IG9mIG1lbW9yeVxuICAgICAgICAvLyBvciBpbiBzb21lIHdheSBjb3JydXB0ZWQgdGhlIHZlcnRleCBidWZmZXIuXG4gICAgICAgICdjb25zdCB2ZWM0IFJFRCA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICBkeW5hbWljSWZzLFxuICAgICAgICAnICAgZWxzZSBpZih2VGV4dHVyZUluZGV4ID49ICcgKyB0aGlzLk1BWF9URVhUVVJFUyArICcuMCkgZ2xfRnJhZ0NvbG9yID0gQkxVRTsnLFxuICAgICAgICAnICAgZWxzZSBpZihpc25hbih2VGV4dHVyZUluZGV4KSkgZ2xfRnJhZ0NvbG9yID0gUkVEOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjIHx8IFBJWEkuUGl4aVNoYWRlci5kZWZhdWx0VmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcblxuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSB1bmlmb3JtcyBmb3IgdGhlIHNoYWRlclxuICAgIC8vdGhpcy51U2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcbiAgICB0aGlzLnVTYW1wbGVyQXJyYXkgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYW1wbGVyQXJyYXlbMF0nKTtcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdkaW1lbnNpb25zJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5hVGV4dHVyZUNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXh0dXJlQ29vcmQnKTtcbiAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuICAgIHRoaXMuYVRleHR1cmVJbmRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUluZGV4Jyk7XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIC8vIEhBQ0s6IHdlIGJpbmQgYW4gZW1wdHkgdGV4dHVyZSB0byBhdm9pZCBXZWJHTCB3YXJuaW5nIHNwYW0uXG4gICAgdmFyIHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMSwgMSwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTUFYX1RFWFRVUkVTOyArK2kpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSk7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICB9XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wudW5pZm9ybTFpdih0aGlzLnVTYW1wbGVyQXJyYXksIGluZGljZXMpO1xuXG4gICAgLy8gQmVnaW4gd29yc3QgaGFjayBldmEgLy9cblxuICAgIC8vIFdIWT8/PyBPTkxZIG9uIG15IGNocm9tZSBwaXhlbCB0aGUgbGluZSBhYm92ZSByZXR1cm5zIC0xIHdoZW4gdXNpbmcgZmlsdGVycz9cbiAgICAvLyBtYXliZSBpdHMgc29tZXRoaW5nIHRvIGRvIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdsIGNvbnRleHQuXG4gICAgLy8gSSdtIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgaWYodGhpcy5jb2xvckF0dHJpYnV0ZSA9PT0gLTEpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yQXR0cmlidXRlID0gMjtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbdGhpcy5hVmVydGV4UG9zaXRpb24sIHRoaXMuYVRleHR1cmVDb29yZCwgdGhpcy5jb2xvckF0dHJpYnV0ZSwgdGhpcy5hVGV4dHVyZUluZGV4XTtcblxuICAgIC8vIEVuZCB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gYWRkIHRob3NlIGN1c3RvbSBzaGFkZXJzIVxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB1bmlmb3JtIGxvY2F0aW9ucy4uXG4gICAgICAgIHRoaXMudW5pZm9ybXNba2V5XS51bmlmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwga2V5KTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRVbmlmb3JtcygpO1xuXG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbn07XG5cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuaW5pdERlZmF1bHRTaGFkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5mcmFnbWVudFNyYyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gW1xuICAgICAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUluZGV4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciA7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjIHx8IFBJWEkuUGl4aVNoYWRlci5kZWZhdWx0VmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcblxuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSB1bmlmb3JtcyBmb3IgdGhlIHNoYWRlclxuICAgIHRoaXMudVNhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYW1wbGVyJyk7XG4gICAgdGhpcy5wcm9qZWN0aW9uVmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdwcm9qZWN0aW9uVmVjdG9yJyk7XG4gICAgdGhpcy5vZmZzZXRWZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ29mZnNldFZlY3RvcicpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnZGltZW5zaW9ucycpO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYVZlcnRleFBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgIHRoaXMuYVRleHR1cmVDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgICB0aGlzLmFUZXh0dXJlSW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleHR1cmVJbmRleCcpO1xuXG5cbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gV0hZPz8/IE9OTFkgb24gbXkgY2hyb21lIHBpeGVsIHRoZSBsaW5lIGFib3ZlIHJldHVybnMgLTEgd2hlbiB1c2luZyBmaWx0ZXJzP1xuICAgIC8vIG1heWJlIGl0cyBzb21ldGhpbmcgdG8gZG8gd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2wgY29udGV4dC5cbiAgICAvLyBJJ20gY29udmluY2VkIHRoaXMgaXMgYSBidWcgaW4gdGhlIGNocm9tZSBicm93c2VyIGFzIHRoZXJlIGlzIE5PIHJlYXNvbiB3aHkgdGhpcyBzaG91bGQgYmUgcmV0dXJuaW5nIC0xIGVzcGVjaWFsbHkgYXMgaXQgb25seSBtYW5pZmVzdHMgb24gbXkgY2hyb21lIHBpeGVsXG4gICAgLy8gSWYgdGhlcmVzIGFueSB3ZWJHTCBwZW9wbGUgdGhhdCBrbm93IHdoeSBjb3VsZCBoYXBwZW4gcGxlYXNlIGhlbHAgOilcbiAgICBpZih0aGlzLmNvbG9yQXR0cmlidXRlID09PSAtMSlcbiAgICB7XG4gICAgICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSAyO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5hVGV4dHVyZUNvb3JkLCB0aGlzLmNvbG9yQXR0cmlidXRlLCB0aGlzLmFUZXh0dXJlSW5kZXhdO1xuXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICAvLyBhZGQgdGhvc2UgY3VzdG9tIHNoYWRlcnMhXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICAvLyBnZXQgdGhlIHVuaWZvcm0gbG9jYXRpb25zLi5cbiAgICAgICAgdGhpcy51bmlmb3Jtc1trZXldLnVuaWZvcm1Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFVuaWZvcm1zKCk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyLlxuKlxuKiBAbWV0aG9kIGluaXRcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih1c2luZ0ZpbHRlcilcbntcbiAgICBpZiAoUElYSS5fZW5hYmxlTXVsdGlUZXh0dXJlVG9nZ2xlICYmICF1c2luZ0ZpbHRlcikge1xuICAgICAgICB0aGlzLmluaXRNdWx0aXRleFNoYWRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHRTaGFkZXIoKTtcbiAgICB9ICBcbn07XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyIHVuaWZvcm0gdmFsdWVzLlxuKlxuKiBVbmlmb3JtcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBHTFNMX0VTIFNwZWNpZmljYXRpb246IGh0dHA6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC9cbiogaHR0cDovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS9nbGVzL3NwZWNzLzIuMC9HTFNMX0VTX1NwZWNpZmljYXRpb25fMS4wLjE3LnBkZlxuKlxuKiBAbWV0aG9kIGluaXRVbmlmb3Jtc1xuKi9cblBJWEkuUGl4aVNoYWRlci5wcm90b3R5cGUuaW5pdFVuaWZvcm1zID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMTtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciB1bmlmb3JtO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1trZXldO1xuXG4gICAgICAgIHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJylcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5faW5pdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodW5pZm9ybS52YWx1ZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTYW1wbGVyMkQodW5pZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21hdDInIHx8IHR5cGUgPT09ICdtYXQzJyB8fCB0eXBlID09PSAnbWF0NCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBUaGVzZSByZXF1aXJlIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xNYXRyaXggPSB0cnVlO1xuICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtYXQyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYyA9IGdsLnVuaWZvcm1NYXRyaXgyZnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbWF0MycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMgPSBnbC51bmlmb3JtTWF0cml4M2Z2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21hdDQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2wudW5pZm9ybU1hdHJpeDRmdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vICBHTCBmdW5jdGlvbiByZWZlcmVuY2VcbiAgICAgICAgICAgIHVuaWZvcm0uZ2xGdW5jID0gZ2xbJ3VuaWZvcm0nICsgdHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnMmYnIHx8IHR5cGUgPT09ICcyaScpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICczZicgfHwgdHlwZSA9PT0gJzNpJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsVmFsdWVMZW5ndGggPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJzRmJyB8fCB0eXBlID09PSAnNGknKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbFZhbHVlTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIGEgU2FtcGxlcjJEIHVuaWZvcm0gKHdoaWNoIG1heSBvbmx5IGJlIGF2YWlsYWJsZSBsYXRlciBvbiBhZnRlciBpbml0VW5pZm9ybXMgb25jZSB0aGUgdGV4dHVyZSBoYXMgbG9hZGVkKVxuKlxuKiBAbWV0aG9kIGluaXRTYW1wbGVyMkRcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLmluaXRTYW1wbGVyMkQgPSBmdW5jdGlvbih1bmlmb3JtKVxue1xuICAgIGlmICghdW5pZm9ybS52YWx1ZSB8fCAhdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZSB8fCAhdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIE5vIG5lZWQgdG8gZG8gc3RyaW5nIG1hbmlwdWxhdGlvbiBmb3IgdGhpcy5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy50ZXh0dXJlQ291bnQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIC8vICBFeHRlbmRlZCB0ZXh0dXJlIGRhdGFcbiAgICBpZiAodW5pZm9ybS50ZXh0dXJlRGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gdW5pZm9ybS50ZXh0dXJlRGF0YTtcblxuICAgICAgICAvLyBHTFRleHR1cmUgPSBtYWcgbGluZWFyLCBtaW4gbGluZWFyX21pcG1hcF9saW5lYXIsIHdyYXAgcmVwZWF0ICsgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIC8vIEdMVGV4dHVyZUxpbmVhciA9IG1hZy9taW4gbGluZWFyLCB3cmFwIGNsYW1wXG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3RSZXBlYXQgPSBtYWcvbWluIE5FQVJFU1QsIHdyYXAgcmVwZWF0XG4gICAgICAgIC8vIEdMVGV4dHVyZU5lYXJlc3QgPSBtYWcvbWluIG5lYXJlc3QsIHdyYXAgY2xhbXBcbiAgICAgICAgLy8gQXVkaW9UZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCA1MTIsIGhlaWdodCAyLCBib3JkZXIgMFxuICAgICAgICAvLyBLZXlUZXh0dXJlID0gd2hhdGV2ZXIgKyBsdW1pbmFuY2UgKyB3aWR0aCAyNTYsIGhlaWdodCAyLCBib3JkZXIgMFxuXG4gICAgICAgIC8vICBtYWdGaWx0ZXIgY2FuIGJlOiBnbC5MSU5FQVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIG9yIGdsLk5FQVJFU1RcbiAgICAgICAgLy8gIHdyYXBTL1QgY2FuIGJlOiBnbC5DTEFNUF9UT19FREdFIG9yIGdsLlJFUEVBVFxuXG4gICAgICAgIHZhciBtYWdGaWx0ZXIgPSAoZGF0YS5tYWdGaWx0ZXIpID8gZGF0YS5tYWdGaWx0ZXIgOiBnbC5MSU5FQVI7XG4gICAgICAgIHZhciBtaW5GaWx0ZXIgPSAoZGF0YS5taW5GaWx0ZXIpID8gZGF0YS5taW5GaWx0ZXIgOiBnbC5MSU5FQVI7XG4gICAgICAgIHZhciB3cmFwUyA9IChkYXRhLndyYXBTKSA/IGRhdGEud3JhcFMgOiBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICB2YXIgd3JhcFQgPSAoZGF0YS53cmFwVCkgPyBkYXRhLndyYXBUIDogZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IChkYXRhLmx1bWluYW5jZSkgPyBnbC5MVU1JTkFOQ0UgOiBnbC5SR0JBO1xuXG4gICAgICAgIGlmIChkYXRhLnJlcGVhdClcbiAgICAgICAge1xuICAgICAgICAgICAgd3JhcFMgPSBnbC5SRVBFQVQ7XG4gICAgICAgICAgICB3cmFwVCA9IGdsLlJFUEVBVDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsICEhZGF0YS5mbGlwWSk7XG5cbiAgICAgICAgaWYgKGRhdGEud2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IChkYXRhLndpZHRoKSA/IGRhdGEud2lkdGggOiA1MTI7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGRhdGEuaGVpZ2h0KSA/IGRhdGEuaGVpZ2h0IDogMjtcbiAgICAgICAgICAgIHZhciBib3JkZXIgPSAoZGF0YS5ib3JkZXIpID8gZGF0YS5ib3JkZXIgOiAwO1xuXG4gICAgICAgICAgICAvLyB2b2lkIHRleEltYWdlMkQoR0xlbnVtIHRhcmdldCwgR0xpbnQgbGV2ZWwsIEdMZW51bSBpbnRlcm5hbGZvcm1hdCwgR0xzaXplaSB3aWR0aCwgR0xzaXplaSBoZWlnaHQsIEdMaW50IGJvcmRlciwgR0xlbnVtIGZvcm1hdCwgR0xlbnVtIHR5cGUsIEFycmF5QnVmZmVyVmlldz8gcGl4ZWxzKTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyAgdm9pZCB0ZXhJbWFnZTJEKEdMZW51bSB0YXJnZXQsIEdMaW50IGxldmVsLCBHTGVudW0gaW50ZXJuYWxmb3JtYXQsIEdMZW51bSBmb3JtYXQsIEdMZW51bSB0eXBlLCBJbWFnZURhdGE/IHBpeGVscyk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIG1hZ0ZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW5GaWx0ZXIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB3cmFwUyk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBUKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtMWkodW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHRoaXMudGV4dHVyZUNvdW50KTtcblxuICAgIHVuaWZvcm0uX2luaXQgPSB0cnVlO1xuXG4gICAgdGhpcy50ZXh0dXJlQ291bnQrKztcblxufTtcblxuLyoqXG4qIFVwZGF0ZXMgdGhlIHNoYWRlciB1bmlmb3JtIHZhbHVlcy5cbipcbiogQG1ldGhvZCBzeW5jVW5pZm9ybXNcbiovXG5QSVhJLlBpeGlTaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLnRleHR1cmVDb3VudCA9IDE7XG4gICAgdmFyIHVuaWZvcm07XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vICBUaGlzIHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciBpbiBhbiBhcnJheSBhbmQgaXQgd291bGQgZ3VhcmFudGVlIGtleSBvcmRlclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNba2V5XTtcbiAgICAgICAgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0uZ2xNYXRyaXggPT09IHRydWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5nbFZhbHVlTGVuZ3RoID09PSAyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1bmlmb3JtLmdsRnVuYy5jYWxsKGdsLCB1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdW5pZm9ybS52YWx1ZS54LCB1bmlmb3JtLnZhbHVlLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUueCwgdW5pZm9ybS52YWx1ZS55LCB1bmlmb3JtLnZhbHVlLnopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWZvcm0uZ2xWYWx1ZUxlbmd0aCA9PT0gNClcbiAgICAgICAge1xuICAgICAgICAgICAgdW5pZm9ybS5nbEZ1bmMuY2FsbChnbCwgdW5pZm9ybS51bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0udmFsdWUueCwgdW5pZm9ybS52YWx1ZS55LCB1bmlmb3JtLnZhbHVlLnosIHVuaWZvcm0udmFsdWUudyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5pZm9ybS50eXBlID09PSAnc2FtcGxlcjJEJylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0uX2luaXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyB0aGlzLnRleHR1cmVDb3VudF0pO1xuXG4gICAgICAgICAgICAgICAgaWYodW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5fZGlydHlbZ2wuaWRdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgUElYSS5pbnN0YW5jZXNbZ2wuaWRdLnVwZGF0ZVRleHR1cmUodW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdIHx8IFBJWEkuY3JlYXRlV2ViR0xUZXh0dXJlKCB1bmlmb3JtLnZhbHVlLmJhc2VUZXh0dXJlLCBnbCkpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtLnVuaWZvcm1Mb2NhdGlvbiwgdGhpcy50ZXh0dXJlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2FtcGxlcjJEKHVuaWZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlci5cbipcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5QaXhpU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xufTtcblxuLyoqXG4qIFRoZSBEZWZhdWx0IFZlcnRleCBzaGFkZXIgc291cmNlLlxuKlxuKiBAcHJvcGVydHkgZGVmYXVsdFZlcnRleFNyY1xuKiBAdHlwZSBTdHJpbmdcbiovXG5QSVhJLlBpeGlTaGFkZXIuZGVmYXVsdFZlcnRleFNyYyA9IFtcbiAgICAnLy8gUGl4aVNoYWRlciBWZXJ0ZXggU2hhZGVyJyxcbiAgICAnLy8gV2l0aCBtdWx0aS10ZXh0dXJlIHJlbmRlcmluZycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuICAgICdhdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJbmRleDsnLFxuXG4gICAgJ3VuaWZvcm0gdmVjMiBwcm9qZWN0aW9uVmVjdG9yOycsXG4gICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcblxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJbmRleDsnLFxuXG4gICAgJ2NvbnN0IHZlYzIgY2VudGVyID0gdmVjMigtMS4wLCAxLjApOycsXG5cbiAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICcgICBpZiAoYVRleHR1cmVJbmRleCA+IDAuMCkgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuMCk7JyxcbiAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KCAoKGFWZXJ0ZXhQb3NpdGlvbiArIG9mZnNldFZlY3RvcikgLyBwcm9qZWN0aW9uVmVjdG9yKSArIGNlbnRlciAsIDAuMCwgMS4wKTsnLFxuICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuICAgICcgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpOycsXG4gICAgJyAgIHZUZXh0dXJlSW5kZXggPSBhVGV4dHVyZUluZGV4OycsXG4gICAgJ30nXG5dO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBQaXhpRmFzdFNoYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgX1VJRFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fVUlEID0gUGhhc2VyLl9VSUQrKztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqIEBwcm9wZXJ0eSBwcm9ncmFtXG4gICAgICogQHR5cGUgQW55XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIGlmIChQSVhJLl9lbmFibGVNdWx0aVRleHR1cmVUb2dnbGUpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgICAgICB2YXIgZHluYW1pY0lmcyA9ICdcXHRpZiAodlRleHR1cmVJbmRleCA9PSAwLjApIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlckFycmF5WzBdLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcXG4nXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCB0aGlzLk1BWF9URVhUVVJFUzsgKytpbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgZHluYW1pY0lmcyArPSAnXFx0ZWxzZSBpZiAodlRleHR1cmVJbmRleCA9PSAnICsgXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArICcuMCkgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyQXJyYXlbJyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKyAnXSwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgICAgICcvLyBQaXhpRmFzdFNoYWRlciBGcmFnbWVudCBTaGFkZXIuJyxcbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAgICAgJ2Jvb2wgaXNuYW4oIGZsb2F0IHZhbCApIHsgIHJldHVybiAoIHZhbCA8IDAuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCApID8gZmFsc2UgOiB0cnVlOyB9JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkNvbG9yOycsXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUluZGV4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJBcnJheVsnICsgdGhpcy5NQVhfVEVYVFVSRVMgKyAnXTsnLFxuICAgICAgICAgICAgLy8gQmx1ZSBjb2xvciBtZWFucyB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGJvdW5kXG4gICAgICAgICAgICAvLyBhIHRleHR1cmUgb3V0IG9mIHRoZSBsaW1pdHMgb2YgdGhlIGhhcmR3YXJlLlxuICAgICAgICAgICAgJ2NvbnN0IHZlYzQgQkxVRSA9IHZlYzQoMS4wLCAwLjAsIDEuMCwgMS4wKTsnLFxuICAgICAgICAgICAgLy8gSWYgeW91IGdldCBhIHJlZCBjb2xvciBtZWFucyB5b3UgYXJlIG91dCBvZiBtZW1vcnlcbiAgICAgICAgICAgIC8vIG9yIGluIHNvbWUgd2F5IGNvcnJ1cHRlZCB0aGUgdmVydGV4IGJ1ZmZlci5cbiAgICAgICAgICAgICdjb25zdCB2ZWM0IFJFRCA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsnLFxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgIGR5bmFtaWNJZnMsXG4gICAgICAgICAgICAnICAgZWxzZSBpZih2VGV4dHVyZUluZGV4ID49ICcgKyB0aGlzLk1BWF9URVhUVVJFUyArICcuMCkgZ2xfRnJhZ0NvbG9yID0gQkxVRTsnLFxuICAgICAgICAgICAgJyAgIGVsc2UgaWYoaXNuYW4odlRleHR1cmVJbmRleCkpIGdsX0ZyYWdDb2xvciA9IFJFRDsnLCAgICAgICBcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG4gICAgICAgICAgICAnLy8gUGl4aUZhc3RTaGFkZXIgRnJhZ21lbnQgU2hhZGVyLicsXG4gICAgICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkNvbG9yOycsXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUluZGV4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF07XG4gICAgfSAgICBcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0ZXhTcmNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjID0gW1xuICAgICAgICAnLy8gUGl4aUZhc3RTaGFkZXIgVmVydGV4IFNoYWRlci4nLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVNjYWxlOycsXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYUNvbG9yOycsXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJbmRleDsnLFxuXG4gICAgICAgICd1bmlmb3JtIHZlYzIgcHJvamVjdGlvblZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIG9mZnNldFZlY3RvcjsnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHVNYXRyaXg7JyxcblxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdkNvbG9yOycsXG4gICAgICAgICd2YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSW5kZXg7JyxcblxuICAgICAgICAnY29uc3QgdmVjMiBjZW50ZXIgPSB2ZWMyKC0xLjAsIDEuMCk7JyxcblxuICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAnICAgdmVjMiB2OycsXG4gICAgICAgICcgICB2ZWMyIHN2ID0gYVZlcnRleFBvc2l0aW9uICogYVNjYWxlOycsXG4gICAgICAgICcgICB2LnggPSAoc3YueCkgKiBjb3MoYVJvdGF0aW9uKSAtIChzdi55KSAqIHNpbihhUm90YXRpb24pOycsXG4gICAgICAgICcgICB2LnkgPSAoc3YueCkgKiBzaW4oYVJvdGF0aW9uKSArIChzdi55KSAqIGNvcyhhUm90YXRpb24pOycsXG4gICAgICAgICcgICB2ID0gKCB1TWF0cml4ICogdmVjMyh2ICsgYVBvc2l0aW9uQ29vcmQgLCAxLjApICkueHkgOycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoICggdiAvIHByb2plY3Rpb25WZWN0b3IpICsgY2VudGVyICwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAnICAgdlRleHR1cmVJbmRleCA9IGFUZXh0dXJlSW5kZXg7JyxcbiAgICAgICAgLy8gICcgICB2ZWMzIGNvbG9yID0gbW9kKHZlYzMoYUNvbG9yLnkvNjU1MzYuMCwgYUNvbG9yLnkvMjU2LjAsIGFDb2xvci55KSwgMjU2LjApIC8gMjU2LjA7JyxcbiAgICAgICAgJyAgIHZDb2xvciA9IGFDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQSBsb2NhbCB0ZXh0dXJlIGNvdW50ZXIgZm9yIG11bHRpLXRleHR1cmUgc2hhZGVycy5cbiAgICAgKiBAcHJvcGVydHkgdGV4dHVyZUNvdW50XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAwO1xuXG4gICAgdGhpcy5pbml0KCk7XG59O1xuXG5QSVhJLlBpeGlGYXN0U2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuUGl4aUZhc3RTaGFkZXI7XG5cbi8qKlxuICogSW5pdGlhbGlzZXMgdGhlIHNoYWRlci5cbiAqIFxuICogQG1ldGhvZCBpbml0XG4gKi9cblBJWEkuUGl4aUZhc3RTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBwcm9ncmFtID0gUElYSS5jb21waWxlUHJvZ3JhbShnbCwgdGhpcy52ZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xuXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IFBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlckFycmF5WzBdJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhbXBsZXInKTtcblxuICAgIGlmIChQSVhJLl9lbmFibGVNdWx0aVRleHR1cmVUb2dnbGUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgLy8gSEFDSzogd2UgYmluZCBhbiBlbXB0eSB0ZXh0dXJlIHRvIGF2b2lkIFdlYkdMIHdhcm5pbmcgc3BhbS5cbiAgICAgICAgdmFyIHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMSwgMSwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1BWF9URVhUVVJFUzsgKytpKSB7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLnVuaWZvcm0xaXYodGhpcy51U2FtcGxlciwgaW5kaWNlcyk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcbiAgICB0aGlzLnVNYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNYXRyaXgnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFQb3NpdGlvbkNvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbkNvb3JkJyk7XG5cbiAgICB0aGlzLmFTY2FsZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhU2NhbGUnKTtcbiAgICB0aGlzLmFSb3RhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUm90YXRpb24nKTtcblxuICAgIHRoaXMuYVRleHR1cmVDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUNvb3JkJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcblxuICAgIHRoaXMuYVRleHR1cmVJbmRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4dHVyZUluZGV4Jyk7XG5cbiAgICAvLyBCZWdpbiB3b3JzdCBoYWNrIGV2YSAvL1xuXG4gICAgLy8gV0hZPz8/IE9OTFkgb24gbXkgY2hyb21lIHBpeGVsIHRoZSBsaW5lIGFib3ZlIHJldHVybnMgLTEgd2hlbiB1c2luZyBmaWx0ZXJzP1xuICAgIC8vIG1heWJlIGl0cyBzb210aGluZyB0byBkbyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbCBjb250ZXh0LlxuICAgIC8vIEltIGNvbnZpbmNlZCB0aGlzIGlzIGEgYnVnIGluIHRoZSBjaHJvbWUgYnJvd3NlciBhcyB0aGVyZSBpcyBOTyByZWFzb24gd2h5IHRoaXMgc2hvdWxkIGJlIHJldHVybmluZyAtMSBlc3BlY2lhbGx5IGFzIGl0IG9ubHkgbWFuaWZlc3RzIG9uIG15IGNocm9tZSBwaXhlbFxuICAgIC8vIElmIHRoZXJlcyBhbnkgd2ViR0wgcGVvcGxlIHRoYXQga25vdyB3aHkgY291bGQgaGFwcGVuIHBsZWFzZSBoZWxwIDopXG4gICAgaWYgKHRoaXMuY29sb3JBdHRyaWJ1dGUgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29sb3JBdHRyaWJ1dGUgPSAyO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtcbiAgICAgICAgdGhpcy5hVmVydGV4UG9zaXRpb24sXG4gICAgICAgIHRoaXMuYVBvc2l0aW9uQ29vcmQsXG4gICAgICAgIHRoaXMuYVNjYWxlLFxuICAgICAgICB0aGlzLmFSb3RhdGlvbixcbiAgICAgICAgdGhpcy5hVGV4dHVyZUNvb3JkLFxuICAgICAgICB0aGlzLmNvbG9yQXR0cmlidXRlLFxuICAgICAgICB0aGlzLmFUZXh0dXJlSW5kZXhcbiAgICBdO1xuXG4gICAgLy8gRW5kIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgc2hhZGVyLlxuICogXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqL1xuUElYSS5QaXhpRmFzdFNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB0aGlzLnVuaWZvcm1zID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFN0cmlwU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5TdHJpcFNoYWRlciA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBfVUlEXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9VSUQgPSBQaGFzZXIuX1VJRCsrO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBnbFxuICAgICAqIEB0eXBlIFdlYkdMQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBXZWJHTCBwcm9ncmFtLlxuICAgICAqIEBwcm9wZXJ0eSBwcm9ncmFtXG4gICAgICogQHR5cGUgQW55XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIGlmIChQSVhJLl9lbmFibGVNdWx0aVRleHR1cmVUb2dnbGUpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgICAgICB2YXIgZHluYW1pY0lmcyA9ICdcXHRpZiAodlRleHR1cmVJbmRleCA9PSAwLjApIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlckFycmF5WzBdLCB2VGV4dHVyZUNvb3JkKTtcXG4nXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCB0aGlzLk1BWF9URVhUVVJFUzsgKytpbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgZHluYW1pY0lmcyArPSAnXFx0ZWxzZSBpZiAodlRleHR1cmVJbmRleCA9PSAnICsgXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArICcuMCkgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyQXJyYXlbJyArIFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKyAnXSwgdlRleHR1cmVDb29yZCkgO1xcbidcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgICAgICcvL1N0cmlwU2hhZGVyIEZyYWdtZW50IFNoYWRlci4nLFxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICAgICAnYm9vbCBpc25hbiggZmxvYXQgdmFsICkgeyAgcmV0dXJuICggdmFsIDwgMC4wIHx8IDAuMCA8IHZhbCB8fCB2YWwgPT0gMC4wICkgPyBmYWxzZSA6IHRydWU7IH0nLFxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUluZGV4OycsXG4gICAgICAgICAvLyAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlckFycmF5WycgKyB0aGlzLk1BWF9URVhUVVJFUyArICddOycsXG4gICAgICAgICAgICAvLyBCbHVlIGNvbG9yIG1lYW5zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gYm91bmRcbiAgICAgICAgICAgIC8vIGEgdGV4dHVyZSBvdXQgb2YgdGhlIGxpbWl0cyBvZiB0aGUgaGFyZHdhcmUuXG4gICAgICAgICAgICAnY29uc3QgdmVjNCBCTFVFID0gdmVjNCgxLjAsIDAuMCwgMS4wLCAxLjApOycsXG4gICAgICAgICAgICAvLyBJZiB5b3UgZ2V0IGEgcmVkIGNvbG9yIG1lYW5zIHlvdSBhcmUgb3V0IG9mIG1lbW9yeVxuICAgICAgICAgICAgLy8gb3IgaW4gc29tZSB3YXkgY29ycnVwdGVkIHRoZSB2ZXJ0ZXggYnVmZmVyLlxuICAgICAgICAgICAgJ2NvbnN0IHZlYzQgUkVEID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApOycsXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgZHluYW1pY0lmcyxcbiAgICAgICAgICAgICcgICBlbHNlIGlmKHZUZXh0dXJlSW5kZXggPj0gJyArIHRoaXMuTUFYX1RFWFRVUkVTICsgJy4wKSBnbF9GcmFnQ29sb3IgPSBCTFVFOycsXG4gICAgICAgICAgICAnICAgZWxzZSBpZihpc25hbih2VGV4dHVyZUluZGV4KSkgZ2xfRnJhZ0NvbG9yID0gUkVEOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXTsgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAgICAgKiBAdHlwZSBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgICAgICcvL1N0cmlwU2hhZGVyIEZyYWdtZW50IFNoYWRlci4nLFxuICAgICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSW5kZXg7JyxcbiAgICAgICAgIC8vICAgJ3ZhcnlpbmcgZmxvYXQgdkNvbG9yOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdOyBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGV4IHNoYWRlci5cbiAgICAgKiBAcHJvcGVydHkgdmVydGV4U3JjXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyAgPSBbXG4gICAgICAgICcvL1N0cmlwU2hhZGVyIFZlcnRleCBTaGFkZXIuJyxcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFUZXh0dXJlSW5kZXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcbiAgICAgIC8vICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgIC8vICd1bmlmb3JtIHZlYzMgdGludDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJbmRleDsnLFxuICAgICAgLy8gICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgdiA9IHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gLCAxLjApOycsXG4gICAgICAgICcgICB2IC09IG9mZnNldFZlY3Rvci54eXg7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggdi54IC8gcHJvamVjdGlvblZlY3Rvci54IC0xLjAsIHYueSAvIC1wcm9qZWN0aW9uVmVjdG9yLnkgKyAxLjAgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICcgICB2VGV4dHVyZUluZGV4ID0gYVRleHR1cmVJbmRleDsnLFxuICAgICAgIC8vICcgICB2Q29sb3IgPSBhQ29sb3IgKiB2ZWM0KHRpbnQgKiBhbHBoYSwgYWxwaGEpOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICB0aGlzLmluaXQoKTtcbn07XG5cblBJWEkuU3RyaXBTaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5TdHJpcFNoYWRlcjtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXIuXG4qIFxuKiBAbWV0aG9kIGluaXRcbiovXG5QSVhJLlN0cmlwU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIHByb2dyYW0gPSBQSVhJLmNvbXBpbGVQcm9ncmFtKGdsLCB0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIHVuaWZvcm1zIGZvciB0aGUgc2hhZGVyXG4gICAgdGhpcy51U2FtcGxlciA9IFBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlckFycmF5WzBdJykgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYW1wbGVyJyk7XG5cblxuICAgIGlmIChQSVhJLl9lbmFibGVNdWx0aVRleHR1cmVUb2dnbGUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgLy8gSEFDSzogd2UgYmluZCBhbiBlbXB0eSB0ZXh0dXJlIHRvIGF2b2lkIFdlYkdMIHdhcm5pbmcgc3BhbS5cbiAgICAgICAgdmFyIHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMSwgMSwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1BWF9URVhUVVJFUzsgKytpKSB7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLnVuaWZvcm0xaXYodGhpcy51U2FtcGxlciwgaW5kaWNlcyk7IFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICBcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgICB0aGlzLmFUZXh0dXJlSW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleHR1cmVJbmRleCcpO1xuICAgIC8vdGhpcy5kaW1lbnNpb25zID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2RpbWVuc2lvbnMnKTtcblxuICAgIC8vIGdldCBhbmQgc3RvcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLmFWZXJ0ZXhQb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICB0aGlzLmFUZXh0dXJlQ29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRleHR1cmVDb29yZCcpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW3RoaXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmFUZXh0dXJlQ29vcmQsIHRoaXMuYVRleHR1cmVJbmRleF07XG5cbiAgICB0aGlzLnRyYW5zbGF0aW9uTWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd0cmFuc2xhdGlvbk1hdHJpeCcpO1xuICAgIHRoaXMuYWxwaGEgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2FscGhhJyk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBzaGFkZXIuXG4qIFxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLlN0cmlwU2hhZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSggdGhpcy5wcm9ncmFtICk7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuKiBAY2xhc3MgUHJpbWl0aXZlU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5QcmltaXRpdmVTaGFkZXIgPSBmdW5jdGlvbihnbClcbntcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgX1VJRFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fVUlEID0gUGhhc2VyLl9VSUQrKztcbiBcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAgKiBAcHJvcGVydHkgcHJvZ3JhbVxuICAgICAqIEB0eXBlIEFueVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxuICAgICAgICAnfSdcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICogQHByb3BlcnR5IHZlcnRleFNyY1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTcmMgID0gW1xuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZmxpcFk7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyB0aW50OycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgdiA9IHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gLCAxLjApOycsXG4gICAgICAgICcgICB2IC09IG9mZnNldFZlY3Rvci54eXg7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggdi54IC8gcHJvamVjdGlvblZlY3Rvci54IC0xLjAsICh2LnkgLyBwcm9qZWN0aW9uVmVjdG9yLnkgKiAtZmxpcFkpICsgZmxpcFkgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZDb2xvciA9IGFDb2xvciAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuUElYSS5QcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5QcmltaXRpdmVTaGFkZXI7XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyLlxuKiBcbiogQG1ldGhvZCBpbml0XG4qL1xuUElYSS5QcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBwcm9ncmFtID0gUElYSS5jb21waWxlUHJvZ3JhbShnbCwgdGhpcy52ZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSB1bmlmb3JtcyBmb3IgdGhlIHNoYWRlclxuICAgIHRoaXMucHJvamVjdGlvblZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAncHJvamVjdGlvblZlY3RvcicpO1xuICAgIHRoaXMub2Zmc2V0VmVjdG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdvZmZzZXRWZWN0b3InKTtcbiAgICB0aGlzLnRpbnRDb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndGludCcpO1xuICAgIHRoaXMuZmxpcFkgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2ZsaXBZJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAgdGhpcy5jb2xvckF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFt0aGlzLmFWZXJ0ZXhQb3NpdGlvbiwgdGhpcy5jb2xvckF0dHJpYnV0ZV07XG5cbiAgICB0aGlzLnRyYW5zbGF0aW9uTWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd0cmFuc2xhdGlvbk1hdHJpeCcpO1xuICAgIHRoaXMuYWxwaGEgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2FscGhhJyk7XG5cbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBzaGFkZXIuXG4qIFxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLlByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0oIHRoaXMucHJvZ3JhbSApO1xuICAgIHRoaXMudW5pZm9ybXMgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBDb21wbGV4UHJpbWl0aXZlU2hhZGVyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyID0gZnVuY3Rpb24oZ2wpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IF9VSURcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX1VJRCA9IFBoYXNlci5fVUlEKys7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgcHJvZ3JhbS5cbiAgICAgKiBAcHJvcGVydHkgcHJvZ3JhbVxuICAgICAqIEB0eXBlIEFueVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqIEBwcm9wZXJ0eSBmcmFnbWVudFNyY1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IFtcblxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7JyxcbiAgICAgICAgJ30nXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0ZXhTcmNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjICA9IFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAvLydhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHByb2plY3Rpb25WZWN0b3I7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiBvZmZzZXRWZWN0b3I7JyxcbiAgICAgICAgXG4gICAgICAgICd1bmlmb3JtIHZlYzMgdGludDsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBhbHBoYTsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGZsaXBZOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgJyAgIHZlYzMgdiA9IHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24gLCAxLjApOycsXG4gICAgICAgICcgICB2IC09IG9mZnNldFZlY3Rvci54eXg7JyxcbiAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCggdi54IC8gcHJvamVjdGlvblZlY3Rvci54IC0xLjAsICh2LnkgLyBwcm9qZWN0aW9uVmVjdG9yLnkgKiAtZmxpcFkpICsgZmxpcFkgLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZDb2xvciA9IHZlYzQoY29sb3IgKiBhbHBoYSAqIHRpbnQsIGFscGhhKTsnLC8vXCIgKiB2ZWM0KHRpbnQgKiBhbHBoYSwgYWxwaGEpOycsXG4gICAgICAgICd9J1xuICAgIF07XG5cbiAgICB0aGlzLmluaXQoKTtcbn07XG5cblBJWEkuQ29tcGxleFByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkNvbXBsZXhQcmltaXRpdmVTaGFkZXI7XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgc2hhZGVyLlxuKiBcbiogQG1ldGhvZCBpbml0XG4qL1xuUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IFBJWEkuY29tcGlsZVByb2dyYW0oZ2wsIHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gZ2V0IGFuZCBzdG9yZSB0aGUgdW5pZm9ybXMgZm9yIHRoZSBzaGFkZXJcbiAgICB0aGlzLnByb2plY3Rpb25WZWN0b3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Byb2plY3Rpb25WZWN0b3InKTtcbiAgICB0aGlzLm9mZnNldFZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnb2Zmc2V0VmVjdG9yJyk7XG4gICAgdGhpcy50aW50Q29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RpbnQnKTtcbiAgICB0aGlzLmNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdjb2xvcicpO1xuICAgIHRoaXMuZmxpcFkgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2ZsaXBZJyk7XG5cbiAgICAvLyBnZXQgYW5kIHN0b3JlIHRoZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hVmVydGV4UG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyk7XG4gICAvLyB0aGlzLmNvbG9yQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW3RoaXMuYVZlcnRleFBvc2l0aW9uLCB0aGlzLmNvbG9yQXR0cmlidXRlXTtcblxuICAgIHRoaXMudHJhbnNsYXRpb25NYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3RyYW5zbGF0aW9uTWF0cml4Jyk7XG4gICAgdGhpcy5hbHBoYSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnYWxwaGEnKTtcblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIHNoYWRlci5cbiogXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuQ29tcGxleFByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0oIHRoaXMucHJvZ3JhbSApO1xuICAgIHRoaXMudW5pZm9ybXMgPSBudWxsO1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG5QSVhJLmdsQ29udGV4dHMgPSBbXTsgLy8gdGhpcyBpcyB3aGVyZSB3ZSBzdG9yZSB0aGUgd2ViR0wgY29udGV4dHMgZm9yIGVhc3kgYWNjZXNzLlxuUElYSS5pbnN0YW5jZXMgPSBbXTtcblBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBXZWJHTFJlbmRlcmVyIGRyYXdzIHRoZSBzdGFnZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSB3ZWJHTCBlbmFibGVkIGNhbnZhcy4gVGhpcyByZW5kZXJlclxuICogc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB3ZWJHTC4gVGhpcyBSZW5kZXIgd29ya3MgYnkgYXV0b21hdGljYWxseSBtYW5hZ2luZyB3ZWJHTEJhdGNocy5cbiAqIFNvIG5vIG5lZWQgZm9yIFNwcml0ZSBCYXRjaGVzIG9yIFNwcml0ZSBDbG91ZHMuXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSB2aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3MgV2ViR0xSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZ2FtZSB7UGhhc2VyLkdhbWV9IEEgcmVmZXJlbmNlIHRvIHRoZSBQaGFzZXIgR2FtZSBpbnN0YW5jZVxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbihnYW1lKSB7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIEdhbWUgaW5zdGFuY2UuXG4gICAgKi9cbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgaWYgKCFQSVhJLmRlZmF1bHRSZW5kZXJlcilcbiAgICB7XG4gICAgICAgIFBJWEkuZGVmYXVsdFJlbmRlcmVyID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gUGhhc2VyLldFQkdMO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVzb2x1dGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSBnYW1lLnJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRyYW5zcGFyZW50XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBnYW1lLnRyYW5zcGFyZW50O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgc2hvdWxkIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGF1dG9SZXNpemVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5hdXRvUmVzaXplID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHByZXNlcnZlRHJhd2luZ0J1ZmZlciBmbGFnIGFmZmVjdHMgd2hldGhlciBvciBub3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyByZXRhaW5lZCBhZnRlciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZ2FtZS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgaWYgdGhlIFdlYkdMUmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY29udGV4dCB0ZXh0dXJlIG9yIG5vdCBiZWZvcmUgdGhlIG5ldyByZW5kZXIgcGFzcy4gSWYgdHJ1ZTpcbiAgICAgKiBJZiB0aGUgU3RhZ2UgaXMgTk9UIHRyYW5zcGFyZW50LCBQaXhpIHdpbGwgY2xlYXIgdG8gYWxwaGEgKDAsIDAsIDAsIDApLlxuICAgICAqIElmIHRoZSBTdGFnZSBpcyB0cmFuc3BhcmVudCwgUGl4aSB3aWxsIGNsZWFyIHRvIHRoZSB0YXJnZXQgU3RhZ2UncyBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAqIERpc2FibGUgdGhpcyBieSBzZXR0aW5nIHRoaXMgdG8gZmFsc2UuIEZvciBleGFtcGxlOiBpZiB5b3VyIGdhbWUgaGFzIGEgY2FudmFzIGZpbGxpbmcgYmFja2dyb3VuZCBpbWFnZSwgeW91IG9mdGVuIGRvbid0IG5lZWQgdGhpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2xlYXJCZWZvcmVSZW5kZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gZ2FtZS5jbGVhckJlZm9yZVJlbmRlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSBnYW1lLndpZHRoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZpZXdcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqL1xuICAgIHRoaXMudmlldyA9IGdhbWUuY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IF9jb250ZXh0T3B0aW9uc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICAgIGFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgICBhbnRpYWxpYXM6IGdhbWUuYW50aWFsaWFzLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRoaXMudHJhbnNwYXJlbnQgJiYgdGhpcy50cmFuc3BhcmVudCAhPT0gJ25vdE11bHRpcGxpZWQnLFxuICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBwcm9qZWN0aW9uXG4gICAgICogQHR5cGUgUG9pbnRcbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb24gPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG9mZnNldFxuICAgICAqIEB0eXBlIFBvaW50XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgUElYSS5Qb2ludCgpO1xuXG4gICAgLy8gdGltZSB0byBjcmVhdGUgdGhlIHJlbmRlciBtYW5hZ2VycyEgZWFjaCBvbmUgZm9jdXNlcyBvbiBtYW5hZ2luZyBhIHN0YXRlIGluIHdlYkdMXG5cbiAgICAvKipcbiAgICAgKiBEZWFscyB3aXRoIG1hbmFnaW5nIHRoZSBzaGFkZXIgcHJvZ3JhbXMgYW5kIHRoZWlyIGF0dHJpYnNcbiAgICAgKiBAcHJvcGVydHkgc2hhZGVyTWFuYWdlclxuICAgICAqIEB0eXBlIFdlYkdMU2hhZGVyTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMU2hhZGVyTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgcmVuZGVyaW5nIG9mIHNwcml0ZXNcbiAgICAgKiBAcHJvcGVydHkgc3ByaXRlQmF0Y2hcbiAgICAgKiBAdHlwZSBXZWJHTFNwcml0ZUJhdGNoXG4gICAgICovXG4gICAgdGhpcy5zcHJpdGVCYXRjaCA9IG5ldyBQSVhJLldlYkdMU3ByaXRlQmF0Y2goZ2FtZSk7XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBtYXNrcyB1c2luZyB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKiBAcHJvcGVydHkgbWFza01hbmFnZXJcbiAgICAgKiBAdHlwZSBXZWJHTE1hc2tNYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMTWFza01hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIGZpbHRlcnNcbiAgICAgKiBAcHJvcGVydHkgZmlsdGVyTWFuYWdlclxuICAgICAqIEB0eXBlIFdlYkdMRmlsdGVyTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMRmlsdGVyTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKiBAcHJvcGVydHkgc3RlbmNpbE1hbmFnZXJcbiAgICAgKiBAdHlwZSBXZWJHTFN0ZW5jaWxNYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIGJsZW5kTW9kZXNcbiAgICAgKiBAcHJvcGVydHkgYmxlbmRNb2RlTWFuYWdlclxuICAgICAqIEB0eXBlIFdlYkdMQmxlbmRNb2RlTWFuYWdlclxuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHJlbmRlclNlc3Npb25cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50QmF0Y2hlZFRleHR1cmVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRCYXRjaGVkVGV4dHVyZXMgPSBbXTtcblxuICAgIC8vICBOZWVkZWQ/XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmdhbWUgPSB0aGlzLmdhbWU7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlciA9IHRoaXMuc2hhZGVyTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ubWFza01hbmFnZXIgPSB0aGlzLm1hc2tNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5maWx0ZXJNYW5hZ2VyID0gdGhpcy5maWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyID0gdGhpcy5ibGVuZE1vZGVNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zcHJpdGVCYXRjaCA9IHRoaXMuc3ByaXRlQmF0Y2g7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnN0ZW5jaWxNYW5hZ2VyID0gdGhpcy5zdGVuY2lsTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ucmVuZGVyZXIgPSB0aGlzO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgLy8gdGltZSBpbml0IHRoZSBjb250ZXh0Li5cbiAgICB0aGlzLmluaXRDb250ZXh0KCk7XG5cbiAgICAvLyBtYXAgc29tZSB3ZWJHTCBibGVuZCBtb2Rlcy4uXG4gICAgdGhpcy5tYXBCbGVuZE1vZGVzKCk7XG5cbn07XG5cbi8vIGNvbnN0cnVjdG9yXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5XZWJHTFJlbmRlcmVyO1xuXG4vKipcbiogQG1ldGhvZCBpbml0Q29udGV4dFxuKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaW5pdENvbnRleHQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy52aWV3LmdldENvbnRleHQoJ3dlYmdsJywgdGhpcy5fY29udGV4dE9wdGlvbnMpIHx8IHRoaXMudmlldy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB0aGlzLl9jb250ZXh0T3B0aW9ucyk7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLm1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblxuICAgIHRoaXMuZ2xDb250ZXh0SWQgPSBnbC5pZCA9IFBJWEkuV2ViR0xSZW5kZXJlci5nbENvbnRleHRJZCsrO1xuXG4gICAgUElYSS5nbENvbnRleHRzW3RoaXMuZ2xDb250ZXh0SWRdID0gZ2w7XG5cbiAgICBQSVhJLmluc3RhbmNlc1t0aGlzLmdsQ29udGV4dElkXSA9IHRoaXM7XG5cbiAgICAvLyBzZXQgdXAgdGhlIGRlZmF1bHQgcGl4aSBzZXR0aW5ncy4uXG4gICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBjb250ZXh0IGZvciBhbGwgdGhlIG1hbmFnZXJzLi4uXG4gICAgdGhpcy5zaGFkZXJNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2guc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5tYXNrTWFuYWdlci5zZXRDb250ZXh0KGdsKTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIuc2V0Q29udGV4dChnbCk7XG4gICAgdGhpcy5ibGVuZE1vZGVNYW5hZ2VyLnNldENvbnRleHQoZ2wpO1xuICAgIHRoaXMuc3RlbmNpbE1hbmFnZXIuc2V0Q29udGV4dChnbCk7XG5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gbm93IHJlc2l6ZSBhbmQgd2UgYXJlIGdvb2QgdG8gZ28hXG4gICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgLy8gTG9hZCBXZWJHTCBleHRlbnNpb25cbiAgICB0aGlzLmV4dGVuc2lvbnMuY29tcHJlc3Npb24gPSB7fTtcblxuICAgIGV0YzEgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKTtcbiAgICBwdnJ0YyA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyk7XG4gICAgczN0YyA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpO1xuXG4gICAgaWYgKGV0YzEpIHRoaXMuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbi5FVEMxID0gZXRjMTtcbiAgICBpZiAocHZydGMpIHRoaXMuZXh0ZW5zaW9ucy5jb21wcmVzc2lvbi5QVlJUQyA9IHB2cnRjO1xuICAgIGlmIChzM3RjKSB0aGlzLmV4dGVuc2lvbnMuY29tcHJlc3Npb24uUzNUQyA9IHMzdGM7XG59O1xuXG4vKipcbiogSWYgTXVsdGkgVGV4dHVyZSBzdXBwb3J0IGhhcyBiZWVuIGVuYWJsZWQsIHRoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGVuYWJsZSBiYXRjaGluZyBvbiB0aGUgZ2l2ZW5cbiogdGV4dHVyZXMuIFRoZSB0ZXh0dXJlIGNvbGxlY3Rpb24gaXMgYW4gYXJyYXkgb2Yga2V5cywgdGhhdCBtYXAgdG8gUGhhc2VyLkNhY2hlIGltYWdlIGVudHJpZXMuXG4qXG4qIFRoZSBudW1iZXIgb2YgdGV4dHVyZXMgdGhhdCBjYW4gYmUgYmF0Y2hlZCBpcyBkZXBlbmRlbnQgb24gaGFyZHdhcmUuIElmIHlvdSBwcm92aWRlIG1vcmUgdGV4dHVyZXNcbiogdGhhbiBjYW4gYmUgYmF0Y2hlZCBieSB0aGUgR1BVLCB0aGVuIG9ubHkgdGhvc2UgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheSB3aWxsIGJlIHVzZWQuIEdlbmVyYWxseVxuKiB5b3Ugc2hvdWxkbid0IHByb3ZpZGUgbW9yZSB0aGFuIDE2IHRleHR1cmVzIHRvIHRoaXMgbWV0aG9kLiBZb3UgY2FuIGNoZWNrIHRoZSBoYXJkd2FyZSBsaW1pdCB2aWEgdGhlXG4qIGBtYXhUZXh0dXJlc2AgcHJvcGVydHkuXG4qXG4qIFlvdSBjYW4gYWxzbyBjaGVjayB0aGUgcHJvcGVydHkgYGN1cnJlbnRCYXRjaGVkVGV4dHVyZXNgIGF0IGFueSB0aW1lLCB0byBzZWUgd2hpY2ggdGV4dHVyZXMgYXJlIGN1cnJlbnRseVxuKiBiZWluZyBiYXRjaGVkLlxuKlxuKiBUbyBzdG9wIGFsbCB0ZXh0dXJlcyBmcm9tIGJlaW5nIGJhdGNoZWQsIGNhbGwgdGhpcyBtZXRob2QgYWdhaW4gd2l0aCBhbiBlbXB0eSBhcnJheS5cbipcbiogVG8gY2hhbmdlIHRoZSB0ZXh0dXJlcyBiZWluZyBiYXRjaGVkLCBjYWxsIHRoaXMgbWV0aG9kIHdpdGggYSBuZXcgYXJyYXkgb2YgaW1hZ2Uga2V5cy4gVGhlIG9sZCBvbmVzXG4qIHdpbGwgYWxsIGJlIHB1cmdlZCBvdXQgYW5kIG5vLWxvbmdlciBiYXRjaGVkLCBhbmQgdGhlIG5ldyBvbmVzIGVuYWJsZWQuXG4qIFxuKiBOb3RlOiBUaHJvd3MgYSB3YXJuaW5nIGlmIHlvdSBoYXZlbid0IGVuYWJsZWQgTXVsdGlwbGUgVGV4dHVyZSBiYXRjaGluZyBzdXBwb3J0IGluIHRoZSBQaGFzZXIgR2FtZSBjb25maWcuXG4qIFxuKiBAbWV0aG9kIHNldFRleHR1cmVQcmlvcml0eVxuKiBAcGFyYW0gdGV4dHVyZU5hbWVDb2xsZWN0aW9uIHtBcnJheX0gQW4gQXJyYXkgb2YgVGV4dHVyZSBDYWNoZSBrZXlzIHRvIHVzZSBmb3IgbXVsdGktdGV4dHVyZSBiYXRjaGluZy5cbiogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRleHR1cmUga2V5cyB0aGF0IHdlcmUgZW5hYmxlZCBmb3IgYmF0Y2hpbmcuXG4qL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0dXJlUHJpb3JpdHkgPSBmdW5jdGlvbiAodGV4dHVyZU5hbWVDb2xsZWN0aW9uKSB7XG5cbiAgICBpZiAoIVBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2Fybignc2V0VGV4dHVyZVByaW9yaXR5IGVycm9yOiBNdWx0aSBUZXh0dXJlIHN1cHBvcnQgaGFzblxcJ3QgYmVlbiBlbmFibGVkIGluIHRoZSBQaGFzZXIgR2FtZSBDb25maWcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsYW1wUG90ID0gZnVuY3Rpb24gKHBvdFNpemUpIHtcbiAgICAgICAgLS1wb3RTaXplO1xuICAgICAgICBwb3RTaXplIHw9IHBvdFNpemUgPj4gMTtcbiAgICAgICAgcG90U2l6ZSB8PSBwb3RTaXplID4+IDI7XG4gICAgICAgIHBvdFNpemUgfD0gcG90U2l6ZSA+PiA0O1xuICAgICAgICBwb3RTaXplIHw9IHBvdFNpemUgPj4gODtcbiAgICAgICAgcG90U2l6ZSB8PSBwb3RTaXplID4+IDE2O1xuICAgICAgICByZXR1cm4gKytwb3RTaXplO1xuICAgIH07XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICB2YXIgaW1hZ2VDYWNoZSA9IHRoaXMuZ2FtZS5jYWNoZS5fY2FjaGUuaW1hZ2U7XG4gICAgdmFyIGltYWdlTmFtZSA9IG51bGw7XG5cbiAgICAvLyAgQ2xlYXIgb3V0IGFsbCBwcmV2aW91c2x5IGJhdGNoZWQgdGV4dHVyZXMgYW5kIHJlc2V0IHRoZWlyIGZsYWdzLlxuICAgIC8vICBJZiB0aGUgYXJyYXkgaGFzIGJlZW4gbW9kaWZpZWQsIHRoZW4gdGhlIGRldmVsb3BlciB3aWxsIGhhdmUgdG9cbiAgICAvLyAgZGVhbCB3aXRoIHRoYXQgaW4gdGhlaXIgb3duIHdheS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VycmVudEJhdGNoZWRUZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGltYWdlTmFtZSA9IHRleHR1cmVOYW1lQ29sbGVjdGlvbltpbmRleF07XG5cbiAgICAgICAgaWYgKCEoaW1hZ2VOYW1lIGluIGltYWdlQ2FjaGUpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaW1hZ2VDYWNoZVtpbWFnZU5hbWVdLmJhc2UudGV4dHVyZUluZGV4ID0gMDtcbiAgICB9XG4gICAgdmFyIG1heFRleHR1cmVBdmFpbGFibGVTcGFjZSA9IChtYXhUZXh0dXJlU2l6ZSkgLSBjbGFtcFBvdChNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpO1xuICAgIHRoaXMuY3VycmVudEJhdGNoZWRUZXh0dXJlcy5sZW5ndGggPSAwO1xuICAgIC8vIFdlIHN0YXJ0IGZyb20gMSBiZWNhdXNlIGZyYW1lYnVmZmVyIHRleHR1cmUgdXNlcyB1bml0IDAuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRleHR1cmVOYW1lQ29sbGVjdGlvbi5sZW5ndGg7ICsraW5kZXgpXG4gICAge1xuICAgICAgICBpbWFnZU5hbWUgPSB0ZXh0dXJlTmFtZUNvbGxlY3Rpb25baW5kZXhdO1xuXG4gICAgICAgIGlmICghKGltYWdlTmFtZSBpbiBpbWFnZUNhY2hlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5pdCAwIGlzIHJlc2VydmVkIGZvciBQaXhpJ3MgZnJhbWVidWZmZXJcbiAgICAgICAgdmFyIGJhc2UgPSBpbWFnZUNhY2hlW2ltYWdlTmFtZV0uYmFzZTtcbiAgICAgICAgbWF4VGV4dHVyZUF2YWlsYWJsZVNwYWNlIC09IGNsYW1wUG90KE1hdGgubWF4KGJhc2Uud2lkdGgsIGJhc2UuaGVpZ2h0KSk7XG4gICAgICAgIGlmIChtYXhUZXh0dXJlQXZhaWxhYmxlU3BhY2UgPD0gMCkge1xuICAgICAgICAgICAgYmFzZS50ZXh0dXJlSW5kZXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZS50ZXh0dXJlSW5kZXggPSAoMSArIChpbmRleCAlIChtYXhUZXh0dXJlcyAtIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2hlZFRleHR1cmVzLnB1c2goaW1hZ2VOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmF0Y2hlZFRleHR1cmVzO1xuXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHN0YWdlIHRvIGl0cyB3ZWJHTCB2aWV3XG4gKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSBzdGFnZSB7U3RhZ2V9IHRoZSBTdGFnZSBlbGVtZW50IHRvIGJlIHJlbmRlcmVkXG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3RhZ2UpXG57XG4gICAgLy8gbm8gcG9pbnQgcmVuZGVyaW5nIGlmIG91ciBjb250ZXh0IGhhcyBiZWVuIGJsb3duIHVwIVxuICAgIGlmICh0aGlzLmNvbnRleHRMb3N0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyAtLSBEb2VzIHRoaXMgbmVlZCB0byBiZSBzZXQgZXZlcnkgZnJhbWU/IC0tIC8vXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBib3VuZCB0byB0aGUgbWFpbiBmcmFtZSBidWZmZXJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgaWYgKHRoaXMuZ2FtZS5jbGVhckJlZm9yZVJlbmRlcilcbiAgICB7XG4gICAgICAgIGdsLmNsZWFyQ29sb3Ioc3RhZ2UuX2JnQ29sb3Iuciwgc3RhZ2UuX2JnQ29sb3IuZywgc3RhZ2UuX2JnQ29sb3IuYiwgc3RhZ2UuX2JnQ29sb3IuYSk7XG5cbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQueCA9IHRoaXMuZ2FtZS5jYW1lcmEuX3NoYWtlLng7XG4gICAgdGhpcy5vZmZzZXQueSA9IHRoaXMuZ2FtZS5jYW1lcmEuX3NoYWtlLnk7XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qoc3RhZ2UsIHRoaXMucHJvamVjdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBEaXNwbGF5IE9iamVjdC5cbiAqXG4gKiBAbWV0aG9kIHJlbmRlckRpc3BsYXlPYmplY3RcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byByZW5kZXJcbiAqIEBwYXJhbSBwcm9qZWN0aW9uIHtQb2ludH0gVGhlIHByb2plY3Rpb25cbiAqIEBwYXJhbSBidWZmZXIge0FycmF5fSBhIHN0YW5kYXJkIFdlYkdMIGJ1ZmZlclxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpc3BsYXlPYmplY3QgPSBmdW5jdGlvbihkaXNwbGF5T2JqZWN0LCBwcm9qZWN0aW9uLCBidWZmZXIsIG1hdHJpeClcbntcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoUElYSS5ibGVuZE1vZGVzLk5PUk1BTCk7XG5cbiAgICAvLyByZXNldCB0aGUgcmVuZGVyIHNlc3Npb24gZGF0YS4uXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCA9IDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgdG8gZmxpcCB0aGUgWSBpZiB1c2luZyBhIHJlbmRlciB0ZXh0dXJlLi5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZmxpcFkgPSBidWZmZXIgPyAtMSA6IDE7XG5cbiAgICAvLyBzZXQgdGhlIGRlZmF1bHQgcHJvamVjdGlvblxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcblxuICAgIC8vc2V0IHRoZSBkZWZhdWx0IG9mZnNldFxuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5vZmZzZXQgPSB0aGlzLm9mZnNldDtcblxuICAgIC8vIHN0YXJ0IHRoZSBzcHJpdGUgYmF0Y2hcbiAgICB0aGlzLnNwcml0ZUJhdGNoLmJlZ2luKHRoaXMucmVuZGVyU2Vzc2lvbik7XG5cbiAgICAvLyBzdGFydCB0aGUgZmlsdGVyIG1hbmFnZXJcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIuYmVnaW4odGhpcy5yZW5kZXJTZXNzaW9uLCBidWZmZXIpO1xuXG4gICAgLy8gcmVuZGVyIHRoZSBzY2VuZSFcbiAgICBkaXNwbGF5T2JqZWN0Ll9yZW5kZXJXZWJHTCh0aGlzLnJlbmRlclNlc3Npb24sIG1hdHJpeCk7XG5cbiAgICAvLyBmaW5pc2ggdGhlIHNwcml0ZSBiYXRjaFxuICAgIHRoaXMuc3ByaXRlQmF0Y2guZW5kKCk7XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIHdlYkdMIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgd2ViR0wgdmlld1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgd2ViR0wgdmlld1xuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggLyB0aGlzLnJlc29sdXRpb24gKyAncHgnO1xuICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyB0aGlzLnJlc29sdXRpb24gKyAncHgnO1xuICAgIH1cblxuICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uLnggPSAgdGhpcy53aWR0aCAvIDIgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5wcm9qZWN0aW9uLnkgPSAgLXRoaXMuaGVpZ2h0IC8gMiAvIHRoaXMucmVzb2x1dGlvbjtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhbmQgY3JlYXRlcyBhIFdlYkdMIGNvbXByZXNzZWQgdGV4dHVyZSBmb3IgdGhlIHJlbmRlcmVycyBjb250ZXh0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlQ29tcHJlc3NlZFRleHR1cmVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB1cGRhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHRleHR1cmUgd2FzIHN1Y2Nlc3NmdWxseSBib3VuZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5QSVhJLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICBpZiAoIXRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciB0ZXh0dXJlTWV0YURhdGEgPSB0ZXh0dXJlLnNvdXJjZTtcblxuICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAge1xuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmUudGV4dHVyZUluZGV4KTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELCBcbiAgICAgICAgMCwgXG4gICAgICAgIHRleHR1cmVNZXRhRGF0YS5nbEV4dGVuc2lvbkZvcm1hdCwgXG4gICAgICAgIHRleHR1cmVNZXRhRGF0YS53aWR0aCwgXG4gICAgICAgIHRleHR1cmVNZXRhRGF0YS5oZWlnaHQsIFxuICAgICAgICAwLCBcbiAgICAgICAgdGV4dHVyZU1ldGFEYXRhLnRleHR1cmVEYXRhXG4gICAgKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuXG4gICAgaWYgKHRleHR1cmUubWlwbWFwICYmIFBoYXNlci5NYXRoLmlzUG93ZXJPZlR3byh0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCkpXG4gICAge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0dXJlLl9wb3dlck9mMilcbiAgICB7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgICB9XG4gICAgdGV4dHVyZS5fZGlydHlbZ2wuaWRdID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYW5kIENyZWF0ZXMgYSBXZWJHTCB0ZXh0dXJlIGZvciB0aGUgcmVuZGVyZXJzIGNvbnRleHQuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVUZXh0dXJlXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdXBkYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB0ZXh0dXJlIHdhcyBzdWNjZXNzZnVsbHkgYm91bmQsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICBpZiAoIXRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5zb3VyY2UuY29tcHJlc3Npb25BbGdvcml0aG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29tcHJlc3NlZFRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAge1xuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmUudGV4dHVyZUluZGV4KTtcblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlLnNvdXJjZSk7XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblxuICAgIGlmICh0ZXh0dXJlLm1pcG1hcCAmJiBQaGFzZXIuTWF0aC5pc1Bvd2VyT2ZUd28odGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQpKVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgIH1cblxuICAgIGlmICghdGV4dHVyZS5fcG93ZXJPZjIpXG4gICAge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLlJFUEVBVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgfVxuXG4gICAgdGV4dHVyZS5fZGlydHlbZ2wuaWRdID0gZmFsc2U7XG5cbiAgICAvLyByZXR1cm4gdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XG4gICAgcmV0dXJuIHRydWU7XG5cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIChldmVudCBsaXN0ZW5lcnMsIHNwcml0ZWJhdGNoLCBldGMuLi4pXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKi9cblBJWEkuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICBQSVhJLmdsQ29udGV4dHNbdGhpcy5nbENvbnRleHRJZF0gPSBudWxsO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9mZnNldCA9IG51bGw7XG5cbiAgICB0aGlzLnNoYWRlck1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLnNoYWRlck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuc3ByaXRlQmF0Y2ggPSBudWxsO1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG51bGw7XG5cbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24gPSBudWxsO1xuXG4gICAgUGhhc2VyLkNhbnZhc1Bvb2wucmVtb3ZlKHRoaXMpO1xuXG4gICAgUElYSS5pbnN0YW5jZXNbdGhpcy5nbENvbnRleHRJZF0gPSBudWxsO1xuXG4gICAgUElYSS5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkLS07XG59O1xuXG4vKipcbiAqIE1hcHMgUGl4aSBibGVuZCBtb2RlcyB0byBXZWJHTCBibGVuZCBtb2Rlcy5cbiAqXG4gKiBAbWV0aG9kIG1hcEJsZW5kTW9kZXNcbiAqL1xuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5tYXBCbGVuZE1vZGVzID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoIVBJWEkuYmxlbmRNb2Rlc1dlYkdMKVxuICAgIHtcbiAgICAgICAgdmFyIGIgPSBbXTtcbiAgICAgICAgdmFyIG1vZGVzID0gUElYSS5ibGVuZE1vZGVzO1xuXG4gICAgICAgIGJbbW9kZXMuTk9STUFMXSAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5BRERdICAgICAgICAgICA9IFtnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQV07XG4gICAgICAgIGJbbW9kZXMuTVVMVElQTFldICAgICAgPSBbZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5TQ1JFRU5dICAgICAgICA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV07XG4gICAgICAgIGJbbW9kZXMuT1ZFUkxBWV0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5EQVJLRU5dICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBiW21vZGVzLkxJR0hURU5dICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGJbbW9kZXMuQ09MT1JfRE9ER0VdICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5DT0xPUl9CVVJOXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBiW21vZGVzLkhBUkRfTElHSFRdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGJbbW9kZXMuU09GVF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5ESUZGRVJFTkNFXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBiW21vZGVzLkVYQ0xVU0lPTl0gICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGJbbW9kZXMuSFVFXSAgICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYlttb2Rlcy5TQVRVUkFUSU9OXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBiW21vZGVzLkNPTE9SXSAgICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGJbbW9kZXMuTFVNSU5PU0lUWV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcblxuICAgICAgICBQSVhJLmJsZW5kTW9kZXNXZWJHTCA9IGI7XG4gICAgfVxufTtcblxuUElYSS5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRNYXhUZXh0dXJlVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG59O1xuXG5QSVhJLmVuYWJsZU11bHRpVGV4dHVyZSA9IGZ1bmN0aW9uKCkge1xuICAgIFBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSA9IHRydWU7XG59O1xuXG5QSVhJLldlYkdMUmVuZGVyZXIuZ2xDb250ZXh0SWQgPSAwO1xuUElYSS5XZWJHTFJlbmRlcmVyLnRleHR1cmVBcnJheSA9IFtdO1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFdlYkdMQmxlbmRNb2RlTWFuYWdlclxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuKi9cblBJWEkuV2ViR0xCbGVuZE1vZGVNYW5hZ2VyID0gZnVuY3Rpb24oKVxue1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50QmxlbmRNb2RlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gOTk5OTk7XG59O1xuXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlcjtcblxuLyoqXG4gKiBTZXRzIHRoZSBXZWJHTCBDb250ZXh0LlxuICpcbiAqIEBtZXRob2Qgc2V0Q29udGV4dFxuICogQHBhcmFtIGdsIHtXZWJHTENvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICovXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcbn07XG5cbi8qKlxuKiBTZXRzLXVwIHRoZSBnaXZlbiBibGVuZE1vZGUgZnJvbSBXZWJHTCdzIHBvaW50IG9mIHZpZXcuXG4qIFxuKiBAbWV0aG9kIHNldEJsZW5kTW9kZSBcbiogQHBhcmFtIGJsZW5kTW9kZSB7TnVtYmVyfSB0aGUgYmxlbmRNb2RlLCBzaG91bGQgYmUgYSBQaXhpIGNvbnN0LCBzdWNoIGFzIFBJWEkuQmxlbmRNb2Rlcy5BRERcbiovXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24oYmxlbmRNb2RlKVxue1xuICAgIGlmKHRoaXMuY3VycmVudEJsZW5kTW9kZSA9PT0gYmxlbmRNb2RlKXJldHVybiBmYWxzZTtcblxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgICBcbiAgICB2YXIgYmxlbmRNb2RlV2ViR0wgPSBQSVhJLmJsZW5kTW9kZXNXZWJHTFt0aGlzLmN1cnJlbnRCbGVuZE1vZGVdO1xuXG4gICAgaWYgKGJsZW5kTW9kZVdlYkdMKVxuICAgIHtcbiAgICAgICAgdGhpcy5nbC5ibGVuZEZ1bmMoYmxlbmRNb2RlV2ViR0xbMF0sIGJsZW5kTW9kZVdlYkdMWzFdKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhpcyBvYmplY3QuXG4qIFxuKiBAbWV0aG9kIGRlc3Ryb3lcbiovXG5QSVhJLldlYkdMQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTE1hc2tNYW5hZ2VyXG4qIEBjb25zdHJ1Y3RvclxuKiBAcHJpdmF0ZVxuKi9cblBJWEkuV2ViR0xNYXNrTWFuYWdlciA9IGZ1bmN0aW9uKClcbntcbn07XG5cblBJWEkuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLldlYkdMTWFza01hbmFnZXI7XG5cbi8qKlxuKiBTZXRzIHRoZSBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXIuXG4qIFxuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG59O1xuXG4vKipcbiogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4qIFxuKiBAbWV0aG9kIHB1c2hNYXNrXG4qIEBwYXJhbSBtYXNrRGF0YSB7QXJyYXl9XG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtPYmplY3R9XG4qL1xuUElYSS5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uKG1hc2tEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHJlbmRlclNlc3Npb24uZ2w7XG5cbiAgICBpZiAobWFza0RhdGEuZGlydHkpXG4gICAge1xuICAgICAgICBQSVhJLldlYkdMR3JhcGhpY3MudXBkYXRlR3JhcGhpY3MobWFza0RhdGEsIGdsKTtcbiAgICB9XG5cbiAgICBpZiAobWFza0RhdGEuX3dlYkdMW2dsLmlkXSA9PT0gdW5kZWZpbmVkIHx8IG1hc2tEYXRhLl93ZWJHTFtnbC5pZF0uZGF0YSA9PT0gdW5kZWZpbmVkIHx8IG1hc2tEYXRhLl93ZWJHTFtnbC5pZF0uZGF0YS5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlci5wdXNoU3RlbmNpbChtYXNrRGF0YSwgbWFza0RhdGEuX3dlYkdMW2dsLmlkXS5kYXRhWzBdLCByZW5kZXJTZXNzaW9uKTtcbn07XG5cbi8qKlxuKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxuKiBcbiogQG1ldGhvZCBwb3BNYXNrXG4qIEBwYXJhbSBtYXNrRGF0YSB7QXJyYXl9XG4qIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgdXNlZnVsIHBhcmFtZXRlcnNcbiovXG5QSVhJLldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbihtYXNrRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYgKG1hc2tEYXRhLl93ZWJHTFtnbC5pZF0gPT09IHVuZGVmaW5lZCB8fCBtYXNrRGF0YS5fd2ViR0xbZ2wuaWRdLmRhdGEgPT09IHVuZGVmaW5lZCB8fCBtYXNrRGF0YS5fd2ViR0xbZ2wuaWRdLmRhdGEubGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIucG9wU3RlbmNpbChtYXNrRGF0YSwgbWFza0RhdGEuX3dlYkdMW2dsLmlkXS5kYXRhWzBdLCByZW5kZXJTZXNzaW9uKTtcblxufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrLlxuKiBcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZ2wgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiogQGNsYXNzIFdlYkdMU3RlbmNpbE1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwcml2YXRlXG4qL1xuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuc3RlbmNpbFN0YWNrID0gW107XG4gICAgdGhpcy5yZXZlcnNlID0gdHJ1ZTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbn07XG5cbi8qKlxuKiBTZXRzIHRoZSBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXIuXG4qIFxuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG59O1xuXG4vKipcbiogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4qIFxuKiBAbWV0aG9kIHB1c2hNYXNrXG4qIEBwYXJhbSBncmFwaGljcyB7R3JhcGhpY3N9XG4qIEBwYXJhbSB3ZWJHTERhdGEge0FycmF5fVxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7T2JqZWN0fVxuKi9cblBJWEkuV2ViR0xTdGVuY2lsTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWwgPSBmdW5jdGlvbihncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5iaW5kR3JhcGhpY3MoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbik7XG5cbiAgICBpZih0aGlzLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sucHVzaCh3ZWJHTERhdGEpO1xuXG4gICAgdmFyIGxldmVsID0gdGhpcy5jb3VudDtcblxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOVkVSVCk7XG5cbiAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcblxuICAgIGlmKHdlYkdMRGF0YS5tb2RlID09PSAxKVxuICAgIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG4gICAgICAgXG4gICAgICAgIGlmKHRoaXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSBsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgYSBxdWFkIHRvIGluY3JlbWVudC4uXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICBpZih0aGlzLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXZlcnNlID0gIXRoaXMucmV2ZXJzZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYoIXRoaXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSBsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICBpZighdGhpcy5yZXZlcnNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCsxKSwgMHhGRik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCsxLCAweEZGKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLktFRVApO1xuXG4gICAgdGhpcy5jb3VudCsrO1xufTtcblxuLyoqXG4gKiBUT0RPIHRoaXMgZG9lcyBub3QgYmVsb25nIGhlcmUhXG4gKiBcbiAqIEBtZXRob2QgYmluZEdyYXBoaWNzXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfVxuICogQHBhcmFtIHdlYkdMRGF0YSB7QXJyYXl9XG4gKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIucHJvdG90eXBlLmJpbmRHcmFwaGljcyA9IGZ1bmN0aW9uKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHJlbmRlclNlc3Npb24pXG57XG4gICAgLy9pZih0aGlzLl9jdXJyZW50R3JhcGhpY3MgPT09IGdyYXBoaWNzKXJldHVybjtcbiAgICB0aGlzLl9jdXJyZW50R3JhcGhpY3MgPSBncmFwaGljcztcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgLy8gYmluZCB0aGUgZ3JhcGhpY3Mgb2JqZWN0Li5cbiAgICB2YXIgcHJvamVjdGlvbiA9IHJlbmRlclNlc3Npb24ucHJvamVjdGlvbixcbiAgICAgICAgb2Zmc2V0ID0gcmVuZGVyU2Vzc2lvbi5vZmZzZXQsXG4gICAgICAgIHNoYWRlcjsvLyA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5wcmltaXRpdmVTaGFkZXI7XG5cbiAgICBpZih3ZWJHTERhdGEubW9kZSA9PT0gMSlcbiAgICB7XG4gICAgICAgIHNoYWRlciA9IHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5jb21wbGV4UHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgICAgIHJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoIHNoYWRlciApO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIuZmxpcFksIHJlbmRlclNlc3Npb24uZmxpcFkpO1xuICAgICAgIFxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci50cmFuc2xhdGlvbk1hdHJpeCwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCAtcHJvamVjdGlvbi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXQueCwgLW9mZnNldC55KTtcblxuICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci50aW50Q29sb3IsIFBoYXNlci5Db2xvci5oZXhUb1JHQkFycmF5KGdyYXBoaWNzLnRpbnQpKTtcbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIuY29sb3IsIHdlYkdMRGF0YS5jb2xvcik7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci5hbHBoYSwgZ3JhcGhpY3Mud29ybGRBbHBoYSAqIHdlYkdMRGF0YS5hbHBoYSk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5idWZmZXIpO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogMiwgMCk7XG5cblxuICAgICAgICAvLyBub3cgZG8gdGhlIHJlc3QuLlxuICAgICAgICAvLyBzZXQgdGhlIGluZGV4IGJ1ZmZlciFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy9yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIoKTtcbiAgICAgICAgc2hhZGVyID0gcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcbiAgICAgICAgcmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlciggc2hhZGVyICk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudHJhbnNsYXRpb25NYXRyaXgsIGZhbHNlLCBncmFwaGljcy53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLmZsaXBZLCByZW5kZXJTZXNzaW9uLmZsaXBZKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBwcm9qZWN0aW9uLngsIC1wcm9qZWN0aW9uLnkpO1xuICAgICAgICBnbC51bmlmb3JtMmYoc2hhZGVyLm9mZnNldFZlY3RvciwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnRpbnRDb2xvciwgUGhhc2VyLkNvbG9yLmhleFRvUkdCQXJyYXkoZ3JhcGhpY3MudGludCkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIuYWxwaGEsIGdyYXBoaWNzLndvcmxkQWxwaGEpO1xuICAgICAgICBcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5idWZmZXIpO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMCk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmNvbG9yQXR0cmlidXRlLCA0LCBnbC5GTE9BVCwgZmFsc2UsNCAqIDYsIDIgKiA0KTtcblxuICAgICAgICAvLyBzZXQgdGhlIGluZGV4IGJ1ZmZlciFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmluZGV4QnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcG9wU3RlbmNpbFxuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSB3ZWJHTERhdGEge0FycmF5fVxuICogQHBhcmFtIHJlbmRlclNlc3Npb24ge09iamVjdH1cbiAqL1xuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5wb3BTdGVuY2lsID0gZnVuY3Rpb24oZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyU2Vzc2lvbilcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnN0ZW5jaWxTdGFjay5wb3AoKTtcbiAgIFxuICAgIHRoaXMuY291bnQtLTtcblxuICAgIGlmKHRoaXMuc3RlbmNpbFN0YWNrLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIC8vIHRoZSBzdGFjayBpcyBlbXB0eSFcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5jb3VudDtcblxuICAgICAgICB0aGlzLmJpbmRHcmFwaGljcyhncmFwaGljcywgd2ViR0xEYXRhLCByZW5kZXJTZXNzaW9uKTtcblxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIFxuICAgICAgICBpZih3ZWJHTERhdGEubW9kZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZXZlcnNlID0gIXRoaXMucmV2ZXJzZTtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRyYXcgYSBxdWFkIHRvIGluY3JlbWVudC4uXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywwLDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTlZFUlQpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCF0aGlzLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwpLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCI8PD4+XCIpXG4gICAgICAgICAgICBpZighdGhpcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCksIDB4RkYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcblxuXG4gICAgfVxufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBtYXNrIHN0YWNrLlxuKiBcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTFN0ZW5jaWxNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuc3RlbmNpbFN0YWNrID0gbnVsbDtcbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTFNoYWRlck1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qIEBwcml2YXRlXG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG1heEF0dGlic1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMubWF4QXR0aWJzID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYXR0cmliU3RhdGVcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB0ZW1wQXR0cmliU3RhdGVcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF4QXR0aWJzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHN0YWNrXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLnN0YWNrID0gW107XG5cbn07XG5cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyO1xuXG4vKipcbiogSW5pdGlhbGlzZXMgdGhlIGNvbnRleHQgYW5kIHRoZSBwcm9wZXJ0aWVzLlxuKiBcbiogQG1ldGhvZCBzZXRDb250ZXh0IFxuKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4qL1xuUElYSS5XZWJHTFNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyBwcmltaXRpdmVzXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBuZXcgUElYSS5QcmltaXRpdmVTaGFkZXIoZ2wpO1xuXG4gICAgLy8gdGhlIG5leHQgb25lIGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0cmlhbmdsZSBzdHJpcHNcbiAgICB0aGlzLmNvbXBsZXhQcmltaXRpdmVTaGFkZXIgPSBuZXcgUElYSS5Db21wbGV4UHJpbWl0aXZlU2hhZGVyKGdsKTtcblxuICAgIC8vIHRoaXMgc2hhZGVyIGlzIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHNwcml0ZSByZW5kZXJpbmdcbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSBuZXcgUElYSS5QaXhpU2hhZGVyKGdsKTtcblxuICAgIC8vIHRoaXMgc2hhZGVyIGlzIHVzZWQgZm9yIHRoZSBmYXN0IHNwcml0ZSByZW5kZXJpbmdcbiAgICB0aGlzLmZhc3RTaGFkZXIgPSBuZXcgUElYSS5QaXhpRmFzdFNoYWRlcihnbCk7XG5cbiAgICAvLyB0aGUgbmV4dCBvbmUgaXMgdXNlZCBmb3IgcmVuZGVyaW5nIHRyaWFuZ2xlIHN0cmlwc1xuICAgIHRoaXMuc3RyaXBTaGFkZXIgPSBuZXcgUElYSS5TdHJpcFNoYWRlcihnbCk7XG5cbiAgICB0aGlzLnNldFNoYWRlcih0aGlzLmRlZmF1bHRTaGFkZXIpO1xufTtcblxuLyoqXG4qIFRha2VzIHRoZSBhdHRyaWJ1dGVzIGdpdmVuIGluIHBhcmFtZXRlcnMuXG4qIFxuKiBAbWV0aG9kIHNldEF0dHJpYnNcbiogQHBhcmFtIGF0dHJpYnMge0FycmF5fSBhdHRyaWJzIFxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRBdHRyaWJzID0gZnVuY3Rpb24oYXR0cmlicylcbntcbiAgICAvLyByZXNldCB0ZW1wIHN0YXRlXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IGF0dHJpYnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJJZCA9IGF0dHJpYnNbaV07XG4gICAgICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlW2F0dHJpYklkXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5hdHRyaWJTdGF0ZVtpXSAhPT0gdGhpcy50ZW1wQXR0cmliU3RhdGVbaV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmliU3RhdGVbaV0gPSB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXTtcblxuICAgICAgICAgICAgaWYodGhpcy50ZW1wQXR0cmliU3RhdGVbaV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4qIFNldHMgdGhlIGN1cnJlbnQgc2hhZGVyLlxuKiBcbiogQG1ldGhvZCBzZXRTaGFkZXJcbiogQHBhcmFtIHNoYWRlciB7QW55fVxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRTaGFkZXIgPSBmdW5jdGlvbihzaGFkZXIpXG57XG4gICAgaWYodGhpcy5fY3VycmVudElkID09PSBzaGFkZXIuX1VJRClyZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgdGhpcy5fY3VycmVudElkID0gc2hhZGVyLl9VSUQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG5cbiAgICB0aGlzLmdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2V0QXR0cmlicyhzaGFkZXIuYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuKiBEZXN0cm95cyB0aGlzIG9iamVjdC5cbiogXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuV2ViR0xTaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuYXR0cmliU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy50ZW1wQXR0cmliU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5jb21wbGV4UHJpbWl0aXZlU2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuZGVmYXVsdFNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmZhc3RTaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5zdHJpcFNoYWRlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLmdsID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKiBcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqIFxuICogSGVhdmlseSBpbnNwaXJlZCBieSBMaWJHRFgncyBXZWJHTFNwcml0ZUJhdGNoOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9XZWJHTFNwcml0ZUJhdGNoLmphdmFcbiAqL1xuXG4vKipcbiAqXG4gKiBAY2xhc3MgV2ViR0xTcHJpdGVCYXRjaFxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2ggPSBmdW5jdGlvbiAoZ2FtZSkge1xuXG4gICAgLyoqXG4gICAgKiBAcHJvcGVydHkge1BoYXNlci5HYW1lfSBnYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIGdhbWUuXG4gICAgKi9cbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHZlcnRTaXplXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy52ZXJ0U2l6ZSA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXNcbiAgICAgKiBAcHJvcGVydHkgc2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuc2l6ZSA9IDIwMDA7IC8vTWF0aC5wb3coMiwgMTYpIC8gIHRoaXMudmVydFNpemU7XG5cbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gb3VyIGJhdGNoXG4gICAgLy8gSW5jbHVkaW5nIHRleHR1cmUgaW5kZXg6XG4gICAgLy8gcG9zaXRpb24gKyB1diArIGNvbG9yICsgdGV4dHVyZUluZGV4XG4gICAgLy8gdmVjMiArIHZlYzIgKyAoY2hhciAqIDQpICsgZmxvYXRcbiAgICB0aGlzLnZlcnRleFNpemUgPSAoNCAqIDIpICsgKDQgKiAyKSArICg0KSArICg0KTtcbiAgICB2YXIgbnVtVmVydHMgPSB0aGlzLnZlcnRleFNpemUgKiB0aGlzLnNpemUgKiA0O1xuICAgIC8vdGhpcy5zaXplICogNCAqIDQgKiB0aGlzLnZlcnRTaXplO1xuICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBpbmRpY2VzIGluIG91ciBiYXRjaFxuICAgIHZhciBudW1JbmRpY2VzID0gdGhpcy5zaXplICogNjtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSB2ZXJ0aWNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUgQXJyYXlCdWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEFycmF5QnVmZmVyKG51bVZlcnRzKTtcblxuICAgIC8qKlxuICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgRmxvYXQzMkFycmF5XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25zXG4gICAgICogQHR5cGUgRmxvYXQzMkFycmF5XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBVaW50MzJBcnJheVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbG9yc1xuICAgICAqIEB0eXBlIFVpbnQzMkFycmF5XG4gICAgICovXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IGluZGljZXNcbiAgICAgKiBAdHlwZSBVaW50MTZBcnJheVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsYXN0SW5kZXhDb3VudFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMubGFzdEluZGV4Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpIHtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDFdID0gaiArIDE7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDRdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNV0gPSBqICsgMztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZHJhd2luZ1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmRyYXdpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50QmF0Y2hTaXplXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50QmFzZVRleHR1cmVcbiAgICAgKiBAdHlwZSBCYXNlVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBkaXJ0eVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJsZW5kTW9kZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYWRlcnNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNwcml0ZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRTaGFkZXJcbiAgICAgKiBAdHlwZSBQaGFzZXIuRmlsdGVyXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRDb250ZXh0XG4gKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChnbCkge1xuICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgaWYgKFBJWEkuX2VuYWJsZU11bHRpVGV4dHVyZVRvZ2dsZSkge1xuICAgICAgICB2YXIgZHluYW1pY0lmcyA9ICdcXHRpZiAodlRleHR1cmVJbmRleCA9PSAwLjApIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlckFycmF5WzBdLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcXG4nXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCB0aGlzLk1BWF9URVhUVVJFUzsgKytpbmRleCkge1xuICAgICAgICAgICAgZHluYW1pY0lmcyArPSAnXFx0ZWxzZSBpZiAodlRleHR1cmVJbmRleCA9PSAnICtcbiAgICAgICAgICAgICAgICBpbmRleCArICcuMCkgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyQXJyYXlbJyArXG4gICAgICAgICAgICAgICAgaW5kZXggKyAnXSwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxuJ1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdFNoYWRlciA9IG5ldyBQaGFzZXIuRmlsdGVyKFxuICAgICAgICAgICAgdGhpcy5nYW1lLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcvL1dlYkdMU3ByaXRlQmF0Y2ggRnJhZ21lbnQgU2hhZGVyLicsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbiBsb3dwIGZsb2F0OycsXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcbiAgICAgICAgICAgICAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUluZGV4OycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyQXJyYXlbJyArIHRoaXMuTUFYX1RFWFRVUkVTICsgJ107JyxcbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSWZzLFxuICAgICAgICAgICAgICAgICAgICAnXFx0ZWxzZSBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJBcnJheVswXSwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7JyxcbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSBuZXcgUGhhc2VyLkZpbHRlcihcbiAgICAgICAgICAgIHRoaXMuZ2FtZSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnLy9XZWJHTFNwcml0ZUJhdGNoIEZyYWdtZW50IFNoYWRlci4nLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJbmRleDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAgICAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7JyxcbiAgICAgICAgICAgICAgICAnfSdcbiAgICAgICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIGNvdXBsZSBvZiBidWZmZXJzXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyA2NTUzNSBpcyBtYXggaW5kZXgsIHNvIDY1NTM1IC8gNiA9IDEwOTIyLlxuXG4gICAgLy91cGxvYWQgdGhlIGluZGV4IGRhdGFcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5OTtcblxuICAgIHZhciBzaGFkZXIgPSBuZXcgUElYSS5QaXhpU2hhZGVyKGdsKTtcblxuICAgIHNoYWRlci5mcmFnbWVudFNyYyA9IHRoaXMuZGVmYXVsdFNoYWRlci5mcmFnbWVudFNyYztcbiAgICBzaGFkZXIudW5pZm9ybXMgPSB7fTtcbiAgICBzaGFkZXIuaW5pdCgpO1xuXG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGJlZ2luXG4gKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7T2JqZWN0fSBUaGUgUmVuZGVyU2Vzc2lvbiBvYmplY3RcbiAqL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uIChyZW5kZXJTZXNzaW9uKSB7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbiAgICB0aGlzLnNoYWRlciA9IHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXI7XG5cbiAgICB0aGlzLnN0YXJ0KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5kXG4gKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHNwcml0ZSB0byByZW5kZXIgd2hlbiB1c2luZyB0aGlzIHNwcml0ZWJhdGNoXG4gKiBAcGFyYW0ge01hdHJpeH0gW21hdHJpeF0gLSBPcHRpb25hbCBtYXRyaXguIElmIHByb3ZpZGVkIHRoZSBEaXNwbGF5IE9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIHRoaXMgbWF0cml4LCBvdGhlcndpc2UgaXQgd2lsbCB1c2UgaXRzIHdvcmxkVHJhbnNmb3JtLlxuICovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzcHJpdGUsIG1hdHJpeCkge1xuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLnRleHR1cmU7XG4gICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGlmIChQSVhJLldlYkdMUmVuZGVyZXIudGV4dHVyZUFycmF5W2Jhc2VUZXh0dXJlLnRleHR1cmVJbmRleF0gIT0gYmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgYmFzZVRleHR1cmUudGV4dHVyZUluZGV4KTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgUElYSS5XZWJHTFJlbmRlcmVyLnRleHR1cmVBcnJheVtiYXNlVGV4dHVyZS50ZXh0dXJlSW5kZXhdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgLy8gIFRoZXkgcHJvdmlkZWQgYW4gYWx0ZXJuYXRpdmUgcmVuZGVyaW5nIG1hdHJpeCwgc28gdXNlIGl0XG4gICAgdmFyIHd0ID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgICB3dCA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0ZXh0dXJlLi5cbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplID49IHRoaXMuc2l6ZSkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHV2cyBmb3IgdGhlIHRleHR1cmVcbiAgICB2YXIgdXZzID0gdGV4dHVyZS5fdXZzO1xuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIGlmICghdXZzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYVggPSBzcHJpdGUuYW5jaG9yLng7XG4gICAgdmFyIGFZID0gc3ByaXRlLmFuY2hvci55O1xuXG4gICAgdmFyIHcwLCB3MSwgaDAsIGgxO1xuXG4gICAgaWYgKHRleHR1cmUudHJpbSkge1xuICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy5cbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgdzEgPSB0cmltLnggLSBhWCAqIHRyaW0ud2lkdGg7XG4gICAgICAgIHcwID0gdzEgKyB0ZXh0dXJlLmNyb3Aud2lkdGg7XG5cbiAgICAgICAgaDEgPSB0cmltLnkgLSBhWSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICBoMCA9IGgxICsgdGV4dHVyZS5jcm9wLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3MCA9ICh0ZXh0dXJlLmZyYW1lLndpZHRoKSAqICgxIC0gYVgpO1xuICAgICAgICB3MSA9ICh0ZXh0dXJlLmZyYW1lLndpZHRoKSAqIC1hWDtcblxuICAgICAgICBoMCA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0ICogKDEgLSBhWSk7XG4gICAgICAgIGgxID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQgKiAtYVk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiB0aGlzLnZlcnRleFNpemU7IC8vNCAqIHRoaXMudmVydFNpemU7XG4gICAgdmFyIHRpT2Zmc2V0ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogNDtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICB2YXIgdGV4dHVyZUluZGV4ID0gdGV4dHVyZS5iYXNlVGV4dHVyZS50ZXh0dXJlSW5kZXg7XG5cbiAgICB2YXIgYSA9IHd0LmEgLyByZXNvbHV0aW9uO1xuICAgIHZhciBiID0gd3QuYiAvIHJlc29sdXRpb247XG4gICAgdmFyIGMgPSB3dC5jIC8gcmVzb2x1dGlvbjtcbiAgICB2YXIgZCA9IHd0LmQgLyByZXNvbHV0aW9uO1xuICAgIHZhciB0eCA9IHd0LnR4O1xuICAgIHZhciB0eSA9IHd0LnR5O1xuXG4gICAgdmFyIGN3ID0gdGV4dHVyZS5jcm9wLndpZHRoO1xuICAgIHZhciBjaCA9IHRleHR1cmUuY3JvcC5oZWlnaHQ7XG5cbiAgICBpZiAodGV4dHVyZS5yb3RhdGVkKVxuICAgIHtcbiAgICAgICAgdmFyIGEwID0gd3QuYTtcbiAgICAgICAgdmFyIGIwID0gd3QuYjtcbiAgICAgICAgdmFyIGMwID0gd3QuYztcbiAgICAgICAgdmFyIGQwID0gd3QuZDtcbiAgICAgICAgdmFyIF93MSA9IHcxO1xuICAgICAgICB2YXIgX3cwID0gdzA7XG5cbiAgICAgICAgLy8gT2Zmc2V0IGJlZm9yZSByb3RhdGluZ1xuICAgICAgICB0eCA9IHd0LmMgKiBjaCArIHR4O1xuICAgICAgICB0eSA9IHd0LmQgKiBjaCArIHR5O1xuICAgICAgICBcbiAgICAgICAgLy8gUm90YXRlIG1hdHJpeCBieSA5MCBkZWdyZWVzXG4gICAgICAgIC8vIFdlIHVzZSBwcmVjYWxjdWxhdGVkIHZhbHVlcyBmb3Igc2luZSBhbmQgY29zaW5lIG9mIHJhZCg5MClcbiAgICAgICAgYSA9IGEwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3ICsgLWMwO1xuICAgICAgICBiID0gYjAgKiA2LjEyMzIzMzk5NTczNjc2NmUtMTcgKyAtZDA7XG4gICAgICAgIGMgPSBhMCArIGMwICogNi4xMjMyMzM5OTU3MzY3NjZlLTE3O1xuICAgICAgICBkID0gYjAgKyBkMCAqIDYuMTIzMjMzOTk1NzM2NzY2ZS0xNztcblxuICAgICAgICAvLyBVcGRhdGUgVVYgY29vcmRpbmF0ZXNcbiAgICAgICAgdGV4dHVyZS5fdXBkYXRlVXZzSW52ZXJ0ZWQoKTtcblxuICAgICAgICAvLyBSb3RhdGUgZGltZW5zaW9uc1xuICAgICAgICB3MCA9IGgwO1xuICAgICAgICB3MSA9IGgxO1xuICAgICAgICBoMCA9IF93MDtcbiAgICAgICAgaDEgPSBfdzE7ICAgXG4gICAgfVxuXG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9ucztcbiAgICB2YXIgdGludCA9IHNwcml0ZS50aW50O1xuICAgIHZhciBjb2xvciA9ICh0aW50ID4+IDE2KSArICh0aW50ICYgMHhmZjAwKSArICgodGludCAmIDB4ZmYpIDw8IDE2KSArIChzcHJpdGUud29ybGRBbHBoYSAqIDI1NSA8PCAyNCk7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJTZXNzaW9uLnJvdW5kUGl4ZWxzKSB7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gYSAqIHcxICsgYyAqIGgxICsgdHggfCAwO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5IHwgMDtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueDA7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdXZzLnkwO1xuICAgICAgICBjb2xvcnNbaSsrXSA9IGNvbG9yO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHRleHR1cmVJbmRleDtcblxuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4IHwgMDtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSBkICogaDEgKyBiICogdzAgKyB0eSB8IDA7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdXZzLngxO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy55MTtcbiAgICAgICAgY29sb3JzW2krK10gPSBjb2xvcjtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB0ZXh0dXJlSW5kZXg7XG5cbiAgICAgICAgcG9zaXRpb25zW2krK10gPSBhICogdzAgKyBjICogaDAgKyB0eCB8IDA7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gZCAqIGgwICsgYiAqIHcwICsgdHkgfCAwO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MjtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueTI7XG4gICAgICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gYSAqIHcxICsgYyAqIGgwICsgdHggfCAwO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGQgKiBoMCArIGIgKiB3MSArIHR5IHwgMDtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueDM7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdXZzLnkzO1xuICAgICAgICBjb2xvcnNbaSsrXSA9IGNvbG9yO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHRleHR1cmVJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MDtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueTA7XG4gICAgICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdXZzLngxO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy55MTtcbiAgICAgICAgY29sb3JzW2krK10gPSBjb2xvcjtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB0ZXh0dXJlSW5kZXg7XG5cbiAgICAgICAgcG9zaXRpb25zW2krK10gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSBkICogaDAgKyBiICogdzAgKyB0eTtcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueDI7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdXZzLnkyO1xuICAgICAgICBjb2xvcnNbaSsrXSA9IGNvbG9yO1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHRleHR1cmVJbmRleDtcblxuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IGQgKiBoMCArIGIgKiB3MSArIHR5O1xuICAgICAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MztcbiAgICAgICAgcG9zaXRpb25zW2krK10gPSB1dnMueTM7XG4gICAgICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuICAgIH1cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc2l6ZVxuICAgIHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemUrK10gPSBzcHJpdGU7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBUaWxpbmdTcHJpdGUgdXNpbmcgdGhlIHNwcml0ZUJhdGNoLlxuICogXG4gKiBAbWV0aG9kIHJlbmRlclRpbGluZ1Nwcml0ZVxuICogQHBhcmFtIHNwcml0ZSB7VGlsaW5nU3ByaXRlfSB0aGUgc3ByaXRlIHRvIHJlbmRlclxuICovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnJlbmRlclRpbGluZ1Nwcml0ZSA9IGZ1bmN0aW9uIChzcHJpdGUpIHtcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50aWxpbmdUZXh0dXJlO1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgdGV4dHVyZUluZGV4ID0gc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUudGV4dHVyZUluZGV4O1xuICAgIGlmIChQSVhJLldlYkdMUmVuZGVyZXIudGV4dHVyZUFycmF5W3RleHR1cmVJbmRleF0gIT0gYmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZUluZGV4KTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgUElYSS5XZWJHTFJlbmRlcmVyLnRleHR1cmVBcnJheVt0ZXh0dXJlSW5kZXhdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGV4dHVyZS4uXG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSB0ZXh0dXJlcyB1dnMgdGVtcG9yYXJpbHlcbiAgICBpZiAoIXNwcml0ZS5fdXZzKSB7XG4gICAgICAgIHNwcml0ZS5fdXZzID0gbmV3IFBJWEkuVGV4dHVyZVV2cygpO1xuICAgIH1cblxuICAgIHZhciB1dnMgPSBzcHJpdGUuX3V2cztcblxuICAgIHZhciB3ID0gdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICB2YXIgaCA9IHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0O1xuXG4gICAgLy8gdmFyIHcgPSBzcHJpdGUuX2ZyYW1lLnNvdXJjZVNpemVXO1xuICAgIC8vIHZhciBoID0gc3ByaXRlLl9mcmFtZS5zb3VyY2VTaXplSDtcblxuICAgIC8vIHcgPSAxNjtcbiAgICAvLyBoID0gMTY7XG5cbiAgICBzcHJpdGUudGlsZVBvc2l0aW9uLnggJT0gdyAqIHNwcml0ZS50aWxlU2NhbGVPZmZzZXQueDtcbiAgICBzcHJpdGUudGlsZVBvc2l0aW9uLnkgJT0gaCAqIHNwcml0ZS50aWxlU2NhbGVPZmZzZXQueTtcblxuICAgIHZhciBvZmZzZXRYID0gc3ByaXRlLnRpbGVQb3NpdGlvbi54IC8gKHcgKiBzcHJpdGUudGlsZVNjYWxlT2Zmc2V0LngpO1xuICAgIHZhciBvZmZzZXRZID0gc3ByaXRlLnRpbGVQb3NpdGlvbi55IC8gKGggKiBzcHJpdGUudGlsZVNjYWxlT2Zmc2V0LnkpO1xuXG4gICAgdmFyIHNjYWxlWCA9IChzcHJpdGUud2lkdGggLyB3KSAvIChzcHJpdGUudGlsZVNjYWxlLnggKiBzcHJpdGUudGlsZVNjYWxlT2Zmc2V0LngpO1xuICAgIHZhciBzY2FsZVkgPSAoc3ByaXRlLmhlaWdodCAvIGgpIC8gKHNwcml0ZS50aWxlU2NhbGUueSAqIHNwcml0ZS50aWxlU2NhbGVPZmZzZXQueSk7XG5cbiAgICB1dnMueDAgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTAgPSAwIC0gb2Zmc2V0WTtcblxuICAgIHV2cy54MSA9ICgxICogc2NhbGVYKSAtIG9mZnNldFg7XG4gICAgdXZzLnkxID0gMCAtIG9mZnNldFk7XG5cbiAgICB1dnMueDIgPSAoMSAqIHNjYWxlWCkgLSBvZmZzZXRYO1xuICAgIHV2cy55MiA9ICgxICogc2NhbGVZKSAtIG9mZnNldFk7XG5cbiAgICB1dnMueDMgPSAwIC0gb2Zmc2V0WDtcbiAgICB1dnMueTMgPSAoMSAqIHNjYWxlWSkgLSBvZmZzZXRZO1xuXG4gICAgLy8gIEdldCB0aGUgc3ByaXRlcyBjdXJyZW50IGFscGhhIGFuZCB0aW50IGFuZCBjb21iaW5lIHRoZW0gaW50byBhIHNpbmdsZSBjb2xvclxuICAgIHZhciB0aW50ID0gc3ByaXRlLnRpbnQ7XG4gICAgdmFyIGNvbG9yID0gKHRpbnQgPj4gMTYpICsgKHRpbnQgJiAweGZmMDApICsgKCh0aW50ICYgMHhmZikgPDwgMTYpICsgKHNwcml0ZS53b3JsZEFscGhhICogMjU1IDw8IDI0KTtcblxuICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9ucztcbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XG5cbiAgICB2YXIgd2lkdGggPSBzcHJpdGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNwcml0ZS5oZWlnaHQ7XG5cbiAgICAvLyBUT0RPIHRyaW0/P1xuICAgIHZhciBhWCA9IHNwcml0ZS5hbmNob3IueDtcbiAgICB2YXIgYVkgPSBzcHJpdGUuYW5jaG9yLnk7XG4gICAgdmFyIHcwID0gd2lkdGggKiAoMSAtIGFYKTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC1hWDtcblxuICAgIHZhciBoMCA9IGhlaWdodCAqICgxIC0gYVkpO1xuICAgIHZhciBoMSA9IGhlaWdodCAqIC1hWTtcblxuICAgIHZhciBpID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogdGhpcy52ZXJ0ZXhTaXplOyAvLzQgKiB0aGlzLnZlcnRTaXplO1xuXG4gICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG5cbiAgICB2YXIgd3QgPSBzcHJpdGUud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHd0LmEgLyByZXNvbHV0aW9uO1xuICAgIHZhciBiID0gd3QuYiAvIHJlc29sdXRpb247XG4gICAgdmFyIGMgPSB3dC5jIC8gcmVzb2x1dGlvbjtcbiAgICB2YXIgZCA9IHd0LmQgLyByZXNvbHV0aW9uO1xuICAgIHZhciB0eCA9IHd0LnR4O1xuICAgIHZhciB0eSA9IHd0LnR5O1xuICAgIC8vIHh5XG4gICAgcG9zaXRpb25zW2krK10gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICBwb3NpdGlvbnNbaSsrXSA9IGQgKiBoMSArIGIgKiB3MSArIHR5O1xuICAgIC8vIHV2XG4gICAgcG9zaXRpb25zW2krK10gPSB1dnMueDA7XG4gICAgcG9zaXRpb25zW2krK10gPSB1dnMueTA7XG4gICAgLy8gY29sb3JcbiAgICBjb2xvcnNbaSsrXSA9IGNvbG9yO1xuICAgIC8vIHRleHR1cmUgaW5kZXhcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHRleHR1cmVJbmRleDtcblxuICAgIC8vIHh5XG4gICAgcG9zaXRpb25zW2krK10gPSAoYSAqIHcwICsgYyAqIGgxICsgdHgpO1xuICAgIHBvc2l0aW9uc1tpKytdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG4gICAgLy8gdXZcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MTtcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy55MTtcbiAgICAvLyBjb2xvclxuICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgLy8gdGV4dHVyZSBpbmRleFxuICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgLy8geHlcbiAgICBwb3NpdGlvbnNbaSsrXSA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHBvc2l0aW9uc1tpKytdID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG4gICAgLy8gdXZcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MjtcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy55MjtcbiAgICAvLyBjb2xvclxuICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgLy8gdGV4dHVyZSBpbmRleFxuICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgLy8geHlcbiAgICBwb3NpdGlvbnNbaSsrXSA9IGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgIHBvc2l0aW9uc1tpKytdID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgLy8gdXZcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy54MztcbiAgICBwb3NpdGlvbnNbaSsrXSA9IHV2cy55MztcbiAgICAvLyBjb2xvclxuICAgIGNvbG9yc1tpKytdID0gY29sb3I7XG4gICAgLy8gdGV4dHVyZSBpbmRleFxuICAgIHBvc2l0aW9uc1tpKytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNpemVcbiAgICB0aGlzLnNwcml0ZXNbdGhpcy5jdXJyZW50QmF0Y2hTaXplKytdID0gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICpcbiAqIEBtZXRob2QgZmx1c2hcbiAqL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJZiB0aGUgYmF0Y2ggaXMgbGVuZ3RoIDAgdGhlbiByZXR1cm4gYXMgdGhlcmUgaXMgbm90aGluZyB0byBkcmF3XG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHNoYWRlciA9IHRoaXMuZGVmYXVsdFNoYWRlci5zaGFkZXJzW2dsLmlkXTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgYnVmZmVyc1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBmb3IgZWFjaCBzaGFkZXI/XG4gICAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnZlcnRleFNpemU7IC8vdGhpcy52ZXJ0U2l6ZSAqIDQ7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgOCk7XG5cbiAgICAgICAgLy8gY29sb3IgYXR0cmlidXRlcyB3aWxsIGJlIGludGVycHJldGVkIGFzIHVuc2lnbmVkIGJ5dGVzIGFuZCBub3JtYWxpemVkXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmNvbG9yQXR0cmlidXRlLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBzdHJpZGUsIDE2KTtcblxuICAgICAgICAvLyBUZXh0dXJlIGluZGV4XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFUZXh0dXJlSW5kZXgsIDEsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyMCk7XG4gICAgfVxuXG4gICAgLy8gdXBsb2FkIHRoZSB2ZXJ0cyB0byB0aGUgYnVmZmVyICBcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplID4gKHRoaXMuc2l6ZSAqIDAuNSkpIHtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGljZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5wb3NpdGlvbnMuc3ViYXJyYXkoMCwgdGhpcy5jdXJyZW50QmF0Y2hTaXplICogdGhpcy52ZXJ0ZXhTaXplKTtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHZpZXcpO1xuICAgIH1cblxuICAgIHZhciBuZXh0VGV4dHVyZSwgbmV4dEJsZW5kTW9kZSwgbmV4dFNoYWRlcjtcbiAgICB2YXIgYmF0Y2hTaXplID0gMDtcbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgdmFyIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlO1xuICAgIHZhciBjdXJyZW50U2hhZGVyID0gbnVsbDtcblxuICAgIHZhciBibGVuZFN3YXAgPSBmYWxzZTtcbiAgICB2YXIgc2hhZGVyU3dhcCA9IGZhbHNlO1xuICAgIHZhciBzcHJpdGU7XG4gICAgdmFyIHRleHR1cmVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZTsgaSA8IGo7IGkrKykge1xuXG4gICAgICAgIHNwcml0ZSA9IHRoaXMuc3ByaXRlc1tpXTtcblxuICAgICAgICBpZiAoc3ByaXRlLnRpbGluZ1RleHR1cmUpIHtcbiAgICAgICAgICAgIG5leHRUZXh0dXJlID0gc3ByaXRlLnRpbGluZ1RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0VGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dEJsZW5kTW9kZSA9IHNwcml0ZS5ibGVuZE1vZGU7XG4gICAgICAgIG5leHRTaGFkZXIgPSBzcHJpdGUuc2hhZGVyIHx8IHRoaXMuZGVmYXVsdFNoYWRlcjtcblxuICAgICAgICBibGVuZFN3YXAgPSBjdXJyZW50QmxlbmRNb2RlICE9PSBuZXh0QmxlbmRNb2RlO1xuICAgICAgICBzaGFkZXJTd2FwID0gY3VycmVudFNoYWRlciAhPT0gbmV4dFNoYWRlcjsgLy8gc2hvdWxkIEkgdXNlIF9VSURTPz8/XG5cbiAgICAgICAgdmFyIHNraXAgPSBuZXh0VGV4dHVyZS5za2lwUmVuZGVyO1xuXG4gICAgICAgIGlmIChza2lwICYmIHNwcml0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKC8qKGN1cnJlbnRCYXNlVGV4dHVyZSAhPSBuZXh0VGV4dHVyZSAmJiAhc2tpcCkgfHwqL1xuICAgICAgICAgICAgYmxlbmRTd2FwIHx8XG4gICAgICAgICAgICBzaGFkZXJTd2FwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckJhdGNoKGN1cnJlbnRCYXNlVGV4dHVyZSwgYmF0Y2hTaXplLCBzdGFydCk7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGJhdGNoU2l6ZSA9IDA7XG4gICAgICAgICAgICBjdXJyZW50QmFzZVRleHR1cmUgPSBuZXh0VGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKGJsZW5kU3dhcCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZE1vZGUgPSBuZXh0QmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShjdXJyZW50QmxlbmRNb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRlclN3YXApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2hhZGVyID0gbmV4dFNoYWRlcjtcblxuICAgICAgICAgICAgICAgIHNoYWRlciA9IGN1cnJlbnRTaGFkZXIuc2hhZGVyc1tnbC5pZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNoYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIgPSBuZXcgUElYSS5QaXhpU2hhZGVyKGdsKTtcblxuICAgICAgICAgICAgICAgICAgICBzaGFkZXIuZnJhZ21lbnRTcmMgPSBjdXJyZW50U2hhZGVyLmZyYWdtZW50U3JjO1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMgPSBjdXJyZW50U2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIuaW5pdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaGFkZXIuc2hhZGVyc1tnbC5pZF0gPSBzaGFkZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHNoYWRlciBmdW5jdGlvbj8/P1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNoYWRlci5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZXIuc3luY1VuaWZvcm1zKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYm90aCB0aGVzZSBvbmx5IG5lZWQgdG8gYmUgc2V0IGlmIHRoZXkgYXJlIGNoYW5naW5nLi5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHByb2plY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucmVuZGVyU2Vzc2lvbi5wcm9qZWN0aW9uO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIucHJvamVjdGlvblZlY3RvciwgcHJvamVjdGlvbi54LCBwcm9qZWN0aW9uLnkpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIHRoaXMgaXMgdGVtcG9yYXJ5IVxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRWZWN0b3IgPSB0aGlzLnJlbmRlclNlc3Npb24ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZihzaGFkZXIub2Zmc2V0VmVjdG9yLCBvZmZzZXRWZWN0b3IueCwgb2Zmc2V0VmVjdG9yLnkpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBwb2ludGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmF0Y2hTaXplKys7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGJhdGNoU2l6ZSwgc3RhcnQpO1xuXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZW5kZXJCYXRjaFxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9XG4gKiBAcGFyYW0gc2l6ZSB7TnVtYmVyfVxuICogQHBhcmFtIHN0YXJ0SW5kZXgge051bWJlcn1cbiAqL1xuUElYSS5XZWJHTFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXJCYXRjaCA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzaXplLCBzdGFydEluZGV4KSB7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvLyBjaGVjayBpZiBhIHRleHR1cmUgaXMgZGlydHkuLlxuICAgIGlmICh0ZXh0dXJlLl9kaXJ0eVtnbC5pZF0pIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlclNlc3Npb24ucmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSkge1xuICAgICAgICAgICAgLy8gIElmIHVwZGF0ZVRleHR1cmUgcmV0dXJucyBmYWxzZSB0aGVuIHdlIGNhbm5vdCByZW5kZXIgaXQsIHNvIGJhaWwgb3V0IG5vd1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnRJbmRleCAqIDYgKiAyKTtcbiAgICAvLyBpbmNyZW1lbnQgdGhlIGRyYXcgY291bnRcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uZHJhd0NvdW50Kys7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc3RvcFxuICovXG5QSVhJLldlYkdMU3ByaXRlQmF0Y2gucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHN0YXJ0XG4gKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBTcHJpdGVCYXRjaC5cbiAqIFxuICogQG1ldGhvZCBkZXN0cm95XG4gKi9cblBJWEkuV2ViR0xTcHJpdGVCYXRjaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXNcbiAqIFxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgV2ViR0xTcHJpdGVCYXRjaDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvV2ViR0xTcHJpdGVCYXRjaC5qYXZhXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTEZhc3RTcHJpdGVCYXRjaFxuKiBAY29uc3RydWN0b3JcbiovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoID0gZnVuY3Rpb24oZ2wpXG57XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydFNpemVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRTaXplID0gMTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbWF4U2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMubWF4U2l6ZSA9IDYwMDA7Ly9NYXRoLnBvdygyLCAxNikgLyAgdGhpcy52ZXJ0U2l6ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBzaXplXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5zaXplID0gdGhpcy5tYXhTaXplO1xuXG4gICAgLy90aGUgdG90YWwgbnVtYmVyIG9mIGZsb2F0cyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtVmVydHMgPSB0aGlzLnNpemUgKiA0ICogIHRoaXMudmVydFNpemU7XG5cbiAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgaW5kaWNlcyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtSW5kaWNlcyA9IHRoaXMubWF4U2l6ZSAqIDY7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0ZXggZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIEZsb2F0MzJBcnJheVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVZlcnRzKTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IGRhdGFcbiAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAqIEB0eXBlIFVpbnQxNkFycmF5XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuICAgIFxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0ZXhCdWZmZXJcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5kZXhCdWZmZXJcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsYXN0SW5kZXhDb3VudFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMubGFzdEluZGV4Q291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGRyYXdpbmdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudEJhdGNoU2l6ZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEJhdGNoU2l6ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudEJhc2VUZXh0dXJlXG4gICAgICogQHR5cGUgQmFzZVRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGw7XG4gICBcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY3VycmVudEJsZW5kTW9kZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyU2Vzc2lvblxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IG51bGw7XG4gICAgXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYWRlclxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBtYXRyaXhcbiAgICAgKiBAdHlwZSBNYXRyaXhcbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG5cbiAgICB0aGlzLnNldENvbnRleHQoZ2wpO1xufTtcblxuUElYSS5XZWJHTEZhc3RTcHJpdGVCYXRjaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoO1xuXG4vKipcbiAqIFNldHMgdGhlIFdlYkdMIENvbnRleHQuXG4gKlxuICogQG1ldGhvZCBzZXRDb250ZXh0XG4gKiBAcGFyYW0gZ2wge1dlYkdMQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihnbClcbntcbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBjcmVhdGUgYSBjb3VwbGUgb2YgYnVmZmVyc1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cblxuICAgIC8vdXBsb2FkIHRoZSBpbmRleCBkYXRhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGJlZ2luXG4gKiBAcGFyYW0gc3ByaXRlQmF0Y2gge1dlYkdMU3ByaXRlQmF0Y2h9XG4gKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7T2JqZWN0fVxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKHNwcml0ZUJhdGNoLCByZW5kZXJTZXNzaW9uKVxue1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHJlbmRlclNlc3Npb247XG4gICAgdGhpcy5zaGFkZXIgPSB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5mYXN0U2hhZGVyO1xuXG4gICAgdGhpcy5tYXRyaXggPSBzcHJpdGVCYXRjaC53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuXG4gICAgdGhpcy5zdGFydCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuZFxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlbmRlclxuICogQHBhcmFtIHNwcml0ZUJhdGNoIHtXZWJHTFNwcml0ZUJhdGNofVxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ByaXRlQmF0Y2gpXG57XG4gICAgdmFyIGNoaWxkcmVuID0gc3ByaXRlQmF0Y2guY2hpbGRyZW47XG4gICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIFxuICAgIC8vIGNoZWNrIHRleHR1cmUuXG4gICAgaWYoIXNwcml0ZS50ZXh0dXJlLl91dnMpcmV0dXJuO1xuICAgXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBzcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgIC8vIGNoZWNrIGJsZW5kIG1vZGVcbiAgICBpZihzcHJpdGUuYmxlbmRNb2RlICE9PSB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5jdXJyZW50QmxlbmRNb2RlKVxuICAgIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24uYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoc3ByaXRlLmJsZW5kTW9kZSk7XG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaT0wLGo9IGNoaWxkcmVuLmxlbmd0aDsgaTxqOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlclNwcml0ZShjaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlbmRlclNwcml0ZVxuICogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfVxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5yZW5kZXJTcHJpdGUgPSBmdW5jdGlvbihzcHJpdGUpXG57XG4gICAgdmFyIHRleHR1cmUgPSBzcHJpdGUudGV4dHVyZTtcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIHRleHR1cmVJbmRleCA9IHNwcml0ZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnRleHR1cmVJbmRleDtcbiAgICBcbiAgICBpZiAoUElYSS5XZWJHTFJlbmRlcmVyLnRleHR1cmVBcnJheVt0ZXh0dXJlSW5kZXhdICE9IGJhc2VUZXh0dXJlICYmXG4gICAgICAgIGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSAmJiAhc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUuc2tpcFJlbmRlcikge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlSW5kZXgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuICAgICAgICBQSVhJLldlYkdMUmVuZGVyZXIudGV4dHVyZUFycmF5W3RleHR1cmVJbmRleF0gPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgaWYoIXNwcml0ZS50ZXh0dXJlLl91dnMpcmV0dXJuO1xuXG4gICAgfVxuICAgIC8vc3ByaXRlID0gY2hpbGRyZW5baV07XG4gICAgaWYoIXNwcml0ZS52aXNpYmxlKXJldHVybjtcbiAgICBcbiAgICB2YXIgdXZzLCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMsIHdpZHRoLCBoZWlnaHQsIHcwLCB3MSwgaDAsIGgxLCBpbmRleDtcblxuICAgIHV2cyA9IHNwcml0ZS50ZXh0dXJlLl91dnM7XG5cbiAgICB3aWR0aCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIGhlaWdodCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodDtcblxuICAgIGlmIChzcHJpdGUudGV4dHVyZS50cmltKVxuICAgIHtcbiAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxuICAgICAgICB2YXIgdHJpbSA9IHNwcml0ZS50ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgdzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiB0cmltLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgc3ByaXRlLnRleHR1cmUuY3JvcC53aWR0aDtcblxuICAgICAgICBoMSA9IHRyaW0ueSAtIHNwcml0ZS5hbmNob3IueSAqIHRyaW0uaGVpZ2h0O1xuICAgICAgICBoMCA9IGgxICsgc3ByaXRlLnRleHR1cmUuY3JvcC5oZWlnaHQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHcwID0gKHNwcml0ZS50ZXh0dXJlLmZyYW1lLndpZHRoICkgKiAoMS1zcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICB3MSA9IChzcHJpdGUudGV4dHVyZS5mcmFtZS53aWR0aCApICogLXNwcml0ZS5hbmNob3IueDtcblxuICAgICAgICBoMCA9IHNwcml0ZS50ZXh0dXJlLmZyYW1lLmhlaWdodCAqICgxLXNwcml0ZS5hbmNob3IueSk7XG4gICAgICAgIGgxID0gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcbiAgICB9XG5cbiAgICBpbmRleCA9IHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplO1xuICAgIC8vIHh5XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB3MTtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IGgxO1xuXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLng7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgIC8vcm90YXRpb25cbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5yb3RhdGlvbjtcblxuICAgIC8vIHV2XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB1dnMueDA7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB1dnMueTE7XG4gICAgLy8gY29sb3JcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5hbHBoYTtcbiAgICAvLyB0ZXh0dXJlIEluZGV4XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB0ZXh0dXJlSW5kZXg7XG4gXG5cbiAgICAvLyB4eVxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdzA7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBoMTtcblxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnBvc2l0aW9uLng7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueTtcblxuICAgIC8vc2NhbGVcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5zY2FsZS54O1xuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLnk7XG5cbiAgICAgLy9yb3RhdGlvblxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnJvdGF0aW9uO1xuXG4gICAgLy8gdXZcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHV2cy54MTtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHV2cy55MTtcbiAgICAvLyBjb2xvclxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLmFscGhhO1xuICAgIC8vIHRleHR1cmUgSW5kZXhcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHRleHR1cmVJbmRleDtcblxuICAgIC8vIHh5XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB3MDtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IGgwO1xuXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLng7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdXZzLngyO1xuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdXZzLnkyO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gICAgLy8gdGV4dHVyZSBJbmRleFxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdGV4dHVyZUluZGV4O1xuXG5cblxuICAgIC8vIHh5XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSB3MTtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IGgwO1xuXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucG9zaXRpb24ueDtcbiAgICB2ZXJ0aWNlc1tpbmRleCsrXSA9IHNwcml0ZS5wb3NpdGlvbi55O1xuXG4gICAgLy9zY2FsZVxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gc3ByaXRlLnNjYWxlLng7XG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUuc2NhbGUueTtcblxuICAgICAvL3JvdGF0aW9uXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUucm90YXRpb247XG5cbiAgICAvLyB1dlxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdXZzLngzO1xuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdXZzLnkzO1xuICAgIC8vIGNvbG9yXG4gICAgdmVydGljZXNbaW5kZXgrK10gPSBzcHJpdGUuYWxwaGE7XG4gICAgLy8gdGV4dHVyZSBJbmRleFxuICAgIHZlcnRpY2VzW2luZGV4KytdID0gdGV4dHVyZUluZGV4O1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBiYXRjaHNcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUrKztcblxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGZsdXNoXG4gKi9cblBJWEkuV2ViR0xGYXN0U3ByaXRlQmF0Y2gucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplPT09MClyZXR1cm47XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIFxuICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuXG4gICAgaWYoIXRoaXMuY3VycmVudEJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSkge1xuICAgICAgICB0aGlzLnJlbmRlclNlc3Npb24ucmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZSwgZ2wpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy9nbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmN1cnJlbnRCYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuXG4gICAgLy8gdXBsb2FkIHRoZSB2ZXJ0cyB0byB0aGUgYnVmZmVyXG4gICBcbiAgICBpZih0aGlzLmN1cnJlbnRCYXRjaFNpemUgPiAoIHRoaXMuc2l6ZSAqIDAuNSApIClcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuY3VycmVudEJhdGNoU2l6ZSAqIDQgKiB0aGlzLnZlcnRTaXplKTtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICBcbiAgICAvLyB0aGVuIHJlc2V0IHRoZSBiYXRjaCFcbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBkcmF3IGNvdW50XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2Qgc3RvcFxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzdGFydFxuICovXG5QSVhJLldlYkdMRmFzdFNwcml0ZUJhdGNoLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gYmluZCB0aGUgbWFpbiB0ZXh0dXJlXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAvLyBiaW5kIHRoZSBidWZmZXJzXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcblxuICAgIC8vIHNldCB0aGUgcHJvamVjdGlvblxuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgZ2wudW5pZm9ybTJmKHRoaXMuc2hhZGVyLnByb2plY3Rpb25WZWN0b3IsIHByb2plY3Rpb24ueCwgcHJvamVjdGlvbi55KTtcblxuICAgIC8vIHNldCB0aGUgbWF0cml4XG4gICAgZ2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLnNoYWRlci51TWF0cml4LCBmYWxzZSwgdGhpcy5tYXRyaXgpO1xuXG4gICAgLy8gc2V0IHRoZSBwb2ludGVyc1xuICAgIHZhciBzdHJpZGUgPSAgdGhpcy52ZXJ0U2l6ZSAqIDQ7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuYVBvc2l0aW9uQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hU2NhbGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA0ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hUm90YXRpb24sIDEsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA2ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgNyAqIDQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5zaGFkZXIuY29sb3JBdHRyaWJ1dGUsIDEsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCA5ICogNCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hVGV4dHVyZUluZGV4LCAxLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgMTAgKiA0KTtcbiAgICBcbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4qIEBjbGFzcyBXZWJHTEZpbHRlck1hbmFnZXJcbiogQGNvbnN0cnVjdG9yXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIgPSBmdW5jdGlvbigpXG57XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZpbHRlclN0YWNrXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlclN0YWNrID0gW107XG4gICAgXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG9mZnNldFhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG9mZnNldFlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFkgPSAwO1xufTtcblxuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5XZWJHTEZpbHRlck1hbmFnZXI7XG5cbi8qKlxuKiBJbml0aWFsaXNlcyB0aGUgY29udGV4dCBhbmQgdGhlIHByb3BlcnRpZXMuXG4qIFxuKiBAbWV0aG9kIHNldENvbnRleHQgXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGdsKVxue1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnRleHR1cmVQb29sID0gW107XG5cbiAgICB0aGlzLmluaXRTaGFkZXJCdWZmZXJzKCk7XG59O1xuXG4vKipcbiogQG1ldGhvZCBiZWdpblxuKiBAcGFyYW0gcmVuZGVyU2Vzc2lvbiB7UmVuZGVyU2Vzc2lvbn0gXG4qIEBwYXJhbSBidWZmZXIge0FycmF5QnVmZmVyfSBcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihyZW5kZXJTZXNzaW9uLCBidWZmZXIpXG57XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uID0gcmVuZGVyU2Vzc2lvbjtcbiAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSByZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlcjtcblxuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgdGhpcy53aWR0aCA9IHByb2plY3Rpb24ueCAqIDI7XG4gICAgdGhpcy5oZWlnaHQgPSAtcHJvamVjdGlvbi55ICogMjtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbn07XG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBmaWx0ZXIgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuKiBcbiogQG1ldGhvZCBwdXNoRmlsdGVyXG4qIEBwYXJhbSBmaWx0ZXJCbG9jayB7T2JqZWN0fSB0aGUgZmlsdGVyIHRoYXQgd2lsbCBiZSBwdXNoZWQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLnB1c2hGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXJCbG9jaylcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnJlbmRlclNlc3Npb24ucHJvamVjdGlvbjtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZW5kZXJTZXNzaW9uLm9mZnNldDtcblxuICAgIGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhID0gZmlsdGVyQmxvY2sudGFyZ2V0LmZpbHRlckFyZWEgfHwgZmlsdGVyQmxvY2sudGFyZ2V0LmdldEJvdW5kcygpO1xuICAgIFxuICAgIC8vID4+PiBtb2RpZnkgYnkgbmV4dGh0XG4gICAgZmlsdGVyQmxvY2suX3ByZXZpb3VzX3N0ZW5jaWxfbWdyID0gdGhpcy5yZW5kZXJTZXNzaW9uLnN0ZW5jaWxNYW5hZ2VyO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlciA9IG5ldyBQSVhJLldlYkdMU3RlbmNpbE1hbmFnZXIoKTtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIuc2V0Q29udGV4dChnbCk7XG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIC8vIDw8PCAgbW9kaWZ5IGJ5IG5leHRodCBcbiAgIFxuICAgIC8vIGZpbHRlciBwcm9ncmFtXG4gICAgLy8gT1BUSU1JU0FUSU9OIC0gdGhlIGZpcnN0IGZpbHRlciBpcyBmcmVlIGlmIGl0cyBhIHNpbXBsZSBjb2xvciBjaGFuZ2U/XG4gICAgdGhpcy5maWx0ZXJTdGFjay5wdXNoKGZpbHRlckJsb2NrKTtcblxuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbMF07XG5cbiAgICB0aGlzLm9mZnNldFggKz0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWEueDtcbiAgICB0aGlzLm9mZnNldFkgKz0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWEueTtcblxuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbC5wb3AoKTtcbiAgICBpZighdGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRleHR1cmUgPSBuZXcgUElYSS5GaWx0ZXJUZXh0dXJlKHRoaXMuZ2wsIHRoaXMud2lkdGggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRleHR1cmUucmVzaXplKHRoaXMud2lkdGggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG4gICAgfVxuXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRleHR1cmUudGV4dHVyZSk7XG5cbiAgICB2YXIgZmlsdGVyQXJlYSA9IGZpbHRlckJsb2NrLl9maWx0ZXJBcmVhOy8vIGZpbHRlckJsb2NrLnRhcmdldC5nZXRCb3VuZHMoKTsvLy9maWx0ZXJCbG9jay50YXJnZXQuZmlsdGVyQXJlYTtcblxuICAgIHZhciBwYWRkaW5nID0gZmlsdGVyLnBhZGRpbmc7XG4gICAgZmlsdGVyQXJlYS54IC09IHBhZGRpbmc7XG4gICAgZmlsdGVyQXJlYS55IC09IHBhZGRpbmc7XG4gICAgZmlsdGVyQXJlYS53aWR0aCArPSBwYWRkaW5nICogMjtcbiAgICBmaWx0ZXJBcmVhLmhlaWdodCArPSBwYWRkaW5nICogMjtcblxuICAgIC8vIGNhcCBmaWx0ZXIgdG8gc2NyZWVuIHNpemUuLlxuICAgIGlmKGZpbHRlckFyZWEueCA8IDApZmlsdGVyQXJlYS54ID0gMDtcbiAgICBpZihmaWx0ZXJBcmVhLndpZHRoID4gdGhpcy53aWR0aClmaWx0ZXJBcmVhLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZihmaWx0ZXJBcmVhLnkgPCAwKWZpbHRlckFyZWEueSA9IDA7XG4gICAgaWYoZmlsdGVyQXJlYS5oZWlnaHQgPiB0aGlzLmhlaWdodClmaWx0ZXJBcmVhLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICBmaWx0ZXJBcmVhLndpZHRoLCBmaWx0ZXJBcmVhLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZXh0dXJlLmZyYW1lQnVmZmVyKTtcblxuICAgIC8vIHNldCB2aWV3IHBvcnRcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBmaWx0ZXJBcmVhLndpZHRoICogdGhpcy5yZW5kZXJTZXNzaW9uLnJlc29sdXRpb24sIGZpbHRlckFyZWEuaGVpZ2h0ICogdGhpcy5yZW5kZXJTZXNzaW9uLnJlc29sdXRpb24pO1xuXG4gICAgcHJvamVjdGlvbi54ID0gZmlsdGVyQXJlYS53aWR0aC8yO1xuICAgIHByb2plY3Rpb24ueSA9IC1maWx0ZXJBcmVhLmhlaWdodC8yO1xuXG4gICAgb2Zmc2V0LnggPSAtZmlsdGVyQXJlYS54O1xuICAgIG9mZnNldC55ID0gLWZpbHRlckFyZWEueTtcblxuICAgIC8vIHVwZGF0ZSBwcm9qZWN0aW9uXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHJlZ3VsYXIgc2hhZGVyLi5cbiAgICAvLyB0aGlzLnJlbmRlclNlc3Npb24uc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIodGhpcy5kZWZhdWx0U2hhZGVyKTtcbiAgICAvL2dsLnVuaWZvcm0yZih0aGlzLmRlZmF1bHRTaGFkZXIucHJvamVjdGlvblZlY3RvciwgZmlsdGVyQXJlYS53aWR0aC8yLCAtZmlsdGVyQXJlYS5oZWlnaHQvMik7XG4gICAgLy9nbC51bmlmb3JtMmYodGhpcy5kZWZhdWx0U2hhZGVyLm9mZnNldFZlY3RvciwgLWZpbHRlckFyZWEueCwgLWZpbHRlckFyZWEueSk7XG5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLDAsMCwgMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlID0gdGV4dHVyZTtcblxufTtcblxuLyoqXG4qIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4qIFxuKiBAbWV0aG9kIHBvcEZpbHRlclxuKi9cblBJWEkuV2ViR0xGaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wb3BGaWx0ZXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgZmlsdGVyQmxvY2sgPSB0aGlzLmZpbHRlclN0YWNrLnBvcCgpO1xuICAgIHZhciBmaWx0ZXJBcmVhID0gZmlsdGVyQmxvY2suX2ZpbHRlckFyZWE7XG4gICAgdmFyIHRleHR1cmUgPSBmaWx0ZXJCbG9jay5fZ2xGaWx0ZXJUZXh0dXJlO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5yZW5kZXJTZXNzaW9uLnByb2plY3Rpb247XG4gICAgdmFyIG9mZnNldCA9IHRoaXMucmVuZGVyU2Vzc2lvbi5vZmZzZXQ7XG5cbiAgICBpZihmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXMubGVuZ3RoID4gMSlcbiAgICB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGZpbHRlckFyZWEud2lkdGggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgZmlsdGVyQXJlYS5oZWlnaHQgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcblxuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzBdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVsxXSA9IGZpbHRlckFyZWEuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbMl0gPSBmaWx0ZXJBcmVhLndpZHRoO1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzNdID0gZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhBcnJheVs0XSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbNV0gPSAwO1xuXG4gICAgICAgIHRoaXMudmVydGV4QXJyYXlbNl0gPSBmaWx0ZXJBcmVhLndpZHRoO1xuICAgICAgICB0aGlzLnZlcnRleEFycmF5WzddID0gMDtcblxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy52ZXJ0ZXhBcnJheSk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuICAgICAgICAvLyBub3cgc2V0IHRoZSB1dnMuLlxuICAgICAgICB0aGlzLnV2QXJyYXlbMl0gPSBmaWx0ZXJBcmVhLndpZHRoL3RoaXMud2lkdGg7XG4gICAgICAgIHRoaXMudXZBcnJheVs1XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnV2QXJyYXlbNl0gPSBmaWx0ZXJBcmVhLndpZHRoL3RoaXMud2lkdGg7XG4gICAgICAgIHRoaXMudXZBcnJheVs3XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuXG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnV2QXJyYXkpO1xuXG4gICAgICAgIHZhciBpbnB1dFRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB2YXIgb3V0cHV0VGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2wucG9wKCk7XG4gICAgICAgIGlmKCFvdXRwdXRUZXh0dXJlKW91dHB1dFRleHR1cmUgPSBuZXcgUElYSS5GaWx0ZXJUZXh0dXJlKHRoaXMuZ2wsIHRoaXMud2lkdGggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG4gICAgICAgIG91dHB1dFRleHR1cmUucmVzaXplKHRoaXMud2lkdGggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG5cbiAgICAgICAgLy8gbmVlZCB0byBjbGVhciB0aGlzIEZCTyBhcyBpdCBtYXkgaGF2ZSBzb21lIGxlZnQgb3ZlciBlbGVtZW50cyBmcm9tIGEgcHJldmlvdXMgZmlsdGVyLlxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG91dHB1dFRleHR1cmUuZnJhbWVCdWZmZXIgKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXMubGVuZ3RoLTE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpbHRlclBhc3MgPSBmaWx0ZXJCbG9jay5maWx0ZXJQYXNzZXNbaV07XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgb3V0cHV0VGV4dHVyZS5mcmFtZUJ1ZmZlciApO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGV4dHVyZS4uXG4gICAgICAgICAgICAvL2ZpbHRlclBhc3MuYXBwbHlGaWx0ZXJQYXNzKGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJQYXNzKGZpbHRlclBhc3MsIGZpbHRlckFyZWEsIGZpbHRlckFyZWEud2lkdGgsIGZpbHRlckFyZWEuaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gc3dhcCB0aGUgdGV4dHVyZXMuLlxuICAgICAgICAgICAgdmFyIHRlbXAgPSBpbnB1dFRleHR1cmU7XG4gICAgICAgICAgICBpbnB1dFRleHR1cmUgPSBvdXRwdXRUZXh0dXJlO1xuICAgICAgICAgICAgb3V0cHV0VGV4dHVyZSA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgIHRleHR1cmUgPSBpbnB1dFRleHR1cmU7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2wucHVzaChvdXRwdXRUZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyID0gZmlsdGVyQmxvY2suZmlsdGVyUGFzc2VzW2ZpbHRlckJsb2NrLmZpbHRlclBhc3Nlcy5sZW5ndGgtMV07XG5cbiAgICB0aGlzLm9mZnNldFggLT0gZmlsdGVyQXJlYS54O1xuICAgIHRoaXMub2Zmc2V0WSAtPSBmaWx0ZXJBcmVhLnk7XG5cbiAgICB2YXIgc2l6ZVggPSB0aGlzLndpZHRoO1xuICAgIHZhciBzaXplWSA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdmFyIG9mZnNldFggPSAwO1xuICAgIHZhciBvZmZzZXRZID0gMDtcblxuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblxuICAgIC8vIHRpbWUgdG8gcmVuZGVyIHRoZSBmaWx0ZXJzIHRleHR1cmUgdG8gdGhlIHByZXZpb3VzIHNjZW5lXG4gICAgaWYodGhpcy5maWx0ZXJTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7Ly90aGlzLnRyYW5zcGFyZW50KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGaWx0ZXIgPSB0aGlzLmZpbHRlclN0YWNrW3RoaXMuZmlsdGVyU3RhY2subGVuZ3RoLTFdO1xuICAgICAgICBmaWx0ZXJBcmVhID0gY3VycmVudEZpbHRlci5fZmlsdGVyQXJlYTtcblxuICAgICAgICBzaXplWCA9IGZpbHRlckFyZWEud2lkdGg7XG4gICAgICAgIHNpemVZID0gZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICAgICAgb2Zmc2V0WCA9IGZpbHRlckFyZWEueDtcbiAgICAgICAgb2Zmc2V0WSA9IGZpbHRlckFyZWEueTtcblxuICAgICAgICBidWZmZXIgPSAgY3VycmVudEZpbHRlci5fZ2xGaWx0ZXJUZXh0dXJlLmZyYW1lQnVmZmVyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gbmVlZCB0byByZW1vdmUgdGhlc2UgZ2xvYmFsIGVsZW1lbnRzLi5cbiAgICBwcm9qZWN0aW9uLnggPSBzaXplWC8yO1xuICAgIHByb2plY3Rpb24ueSA9IC1zaXplWS8yO1xuXG4gICAgb2Zmc2V0LnggPSBvZmZzZXRYO1xuICAgIG9mZnNldC55ID0gb2Zmc2V0WTtcblxuICAgIGZpbHRlckFyZWEgPSBmaWx0ZXJCbG9jay5fZmlsdGVyQXJlYTtcblxuICAgIHZhciB4ID0gZmlsdGVyQXJlYS54LW9mZnNldFg7XG4gICAgdmFyIHkgPSBmaWx0ZXJBcmVhLnktb2Zmc2V0WTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVycy4uXG4gICAgLy8gbWFrZSBzdXJlIHRvIGZsaXAgdGhlIHkhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbMF0gPSB4O1xuICAgIHRoaXMudmVydGV4QXJyYXlbMV0gPSB5ICsgZmlsdGVyQXJlYS5oZWlnaHQ7XG5cbiAgICB0aGlzLnZlcnRleEFycmF5WzJdID0geCArIGZpbHRlckFyZWEud2lkdGg7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheVszXSA9IHkgKyBmaWx0ZXJBcmVhLmhlaWdodDtcblxuICAgIHRoaXMudmVydGV4QXJyYXlbNF0gPSB4O1xuICAgIHRoaXMudmVydGV4QXJyYXlbNV0gPSB5O1xuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheVs2XSA9IHggKyBmaWx0ZXJBcmVhLndpZHRoO1xuICAgIHRoaXMudmVydGV4QXJyYXlbN10gPSB5O1xuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMudmVydGV4QXJyYXkpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuXG4gICAgdGhpcy51dkFycmF5WzJdID0gZmlsdGVyQXJlYS53aWR0aC90aGlzLndpZHRoO1xuICAgIHRoaXMudXZBcnJheVs1XSA9IGZpbHRlckFyZWEuaGVpZ2h0L3RoaXMuaGVpZ2h0O1xuICAgIHRoaXMudXZBcnJheVs2XSA9IGZpbHRlckFyZWEud2lkdGgvdGhpcy53aWR0aDtcbiAgICB0aGlzLnV2QXJyYXlbN10gPSBmaWx0ZXJBcmVhLmhlaWdodC90aGlzLmhlaWdodDtcblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnV2QXJyYXkpO1xuXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgc2l6ZVggKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiwgc2l6ZVkgKiB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbik7XG5cbiAgICAvLyBiaW5kIHRoZSBidWZmZXJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGJ1ZmZlciApO1xuXG4gICAgLy8gc2V0IHRoZSBibGVuZCBtb2RlISBcbiAgICAvL2dsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpXG5cbiAgICAvLyBzZXQgdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUudGV4dHVyZSk7XG5cbiAgICAvLyA+Pj4gbW9kaWZ5IGJ5IG5leHRodFxuICAgIGlmICh0aGlzLnJlbmRlclNlc3Npb24uc3RlbmNpbE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZXNzaW9uLnN0ZW5jaWxNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnN0ZW5jaWxNYW5hZ2VyID0gZmlsdGVyQmxvY2suX3ByZXZpb3VzX3N0ZW5jaWxfbWdyO1xuICAgIGZpbHRlckJsb2NrLl9wcmV2aW91c19zdGVuY2lsX21nciA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyU2Vzc2lvbi5zdGVuY2lsTWFuYWdlci5jb3VudCA+IDApIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfSAgICBcbiAgICAvLyA8PDwgbW9kaWZ5IGJ5IG5leHRodFxuXG4gICAgLy8gYXBwbHkhXG4gICAgdGhpcy5hcHBseUZpbHRlclBhc3MoZmlsdGVyLCBmaWx0ZXJBcmVhLCBzaXplWCwgc2l6ZVkpO1xuXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHJlZ3VsYXIgc2hhZGVyLi4gc2hvdWxkIGhhcHBlbiBhdXRvbWF0aWNhbGx5IG5vdy4uXG4gICAgLy8gdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHRoaXMuZGVmYXVsdFNoYWRlcik7XG4gICAgLy8gZ2wudW5pZm9ybTJmKHRoaXMuZGVmYXVsdFNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCBzaXplWC8yLCAtc2l6ZVkvMik7XG4gICAgLy8gZ2wudW5pZm9ybTJmKHRoaXMuZGVmYXVsdFNoYWRlci5vZmZzZXRWZWN0b3IsIC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHRleHR1cmUgdG8gdGhlIHBvb2xcbiAgICB0aGlzLnRleHR1cmVQb29sLnB1c2godGV4dHVyZSk7XG4gICAgZmlsdGVyQmxvY2suX2dsRmlsdGVyVGV4dHVyZSA9IG51bGw7XG59O1xuXG5cbi8qKlxuKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBhcmVhLlxuKiBcbiogQG1ldGhvZCBhcHBseUZpbHRlclBhc3NcbiogQHBhcmFtIGZpbHRlciB7UGhhc2VyLkZpbHRlcn0gdGhlIGZpbHRlciB0aGF0IG5lZWRzIHRvIGJlIGFwcGxpZWRcbiogQHBhcmFtIGZpbHRlckFyZWEge1RleHR1cmV9IFRPRE8gLSBtaWdodCBuZWVkIGFuIHVwZGF0ZVxuKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIGhvcml6b250YWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZmlsdGVyXG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyUGFzcyA9IGZ1bmN0aW9uKGZpbHRlciwgZmlsdGVyQXJlYSwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvLyB1c2UgcHJvZ3JhbVxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIHNoYWRlciA9IGZpbHRlci5zaGFkZXJzW2dsLmlkXTtcblxuICAgIGlmKCFzaGFkZXIpXG4gICAge1xuICAgICAgICBzaGFkZXIgPSBuZXcgUElYSS5QaXhpU2hhZGVyKGdsKTtcblxuICAgICAgICBzaGFkZXIuZnJhZ21lbnRTcmMgPSBmaWx0ZXIuZnJhZ21lbnRTcmM7XG4gICAgICAgIHNoYWRlci51bmlmb3JtcyA9IGZpbHRlci51bmlmb3JtcztcbiAgICAgICAgc2hhZGVyLmluaXQodHJ1ZSk7XG5cbiAgICAgICAgZmlsdGVyLnNoYWRlcnNbZ2wuaWRdID0gc2hhZGVyO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgc2hhZGVyXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XG5cbi8vICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuXG4gICAgZ2wudW5pZm9ybTJmKHNoYWRlci5wcm9qZWN0aW9uVmVjdG9yLCB3aWR0aC8yLCAtaGVpZ2h0LzIpO1xuICAgIGdsLnVuaWZvcm0yZihzaGFkZXIub2Zmc2V0VmVjdG9yLCAwLDApO1xuXG4gICAgaWYoZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMpXG4gICAge1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVswXSA9IHRoaXMud2lkdGg7Ly93aWR0aDtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMV0gPSB0aGlzLmhlaWdodDsvL2hlaWdodDtcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMl0gPSB0aGlzLnZlcnRleEFycmF5WzBdO1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVszXSA9IHRoaXMudmVydGV4QXJyYXlbNV07Ly9maWx0ZXJBcmVhLmhlaWdodDtcbiAgICB9XG5cbiAgICBzaGFkZXIuc3luY1VuaWZvcm1zKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFWZXJ0ZXhQb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QnVmZmVyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuY29sb3JCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmNvbG9yQXR0cmlidXRlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmRyYXdDb3VudCsrO1xufTtcblxuLyoqXG4qIEluaXRpYWxpc2VzIHRoZSBzaGFkZXIgYnVmZmVycy5cbiogXG4qIEBtZXRob2QgaW5pdFNoYWRlckJ1ZmZlcnNcbiovXG5QSVhJLldlYkdMRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuaW5pdFNoYWRlckJ1ZmZlcnMgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIGNyZWF0ZSBzb21lIGJ1ZmZlcnNcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMudXZCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmNvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gYmluZCBhbmQgdXBsb2FkIHRoZSB2ZXJ0ZXhzLi5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB2ZXJ0ZXhGbG9hdERhdGEuLlxuICAgIHRoaXMudmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCwgMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDEuMF0pO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gYmluZCBhbmQgdXBsb2FkIHRoZSB1diBidWZmZXJcbiAgICB0aGlzLnV2QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsIDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDEuMF0pO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudXZCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnV2QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEuMCwgMHhGRkZGRkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wLCAweEZGRkZGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEuMCwgMHhGRkZGRkZdKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbG9yQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5jb2xvckFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBiaW5kIGFuZCB1cGxvYWQgdGhlIGluZGV4XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAxLCAzLCAyXSksIGdsLlNUQVRJQ19EUkFXKTtcblxufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBmaWx0ZXIgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgZmlsdGVyIHN0YWNrLlxuKiBcbiogQG1ldGhvZCBkZXN0cm95XG4qL1xuUElYSS5XZWJHTEZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xuICAgIFxuICAgIHRoaXMub2Zmc2V0WCA9IDA7XG4gICAgdGhpcy5vZmZzZXRZID0gMDtcblxuICAgIC8vIGRlc3Ryb3kgdGV4dHVyZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dHVyZVBvb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMudGV4dHVyZVBvb2wgPSBudWxsO1xuXG4gICAgLy9kZXN0cm95IGJ1ZmZlcnMuLlxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudXZCdWZmZXIpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmNvbG9yQnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbmZ1bmN0aW9uIF9DcmVhdGVFbXB0eVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSkge1xuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBzY2FsZU1vZGUgPT09IFBJWEkuc2NhbGVNb2Rlcy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgc2NhbGVNb2RlID09PSBQSVhJLnNjYWxlTW9kZXMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cblxudmFyIF9mYkVycm9ycyA9IHtcbiAgICAzNjA1NDogJ0luY29tcGxldGUgYXR0YWNobWVudCcsXG4gICAgMzYwNTU6ICdNaXNzaW5nIGF0dGFjaG1lbnQnLFxuICAgIDM2MDU3OiAnSW5jb21wbGV0ZSBkaW1lbnNpb25zJyxcbiAgICAzNjA2MTogJ0ZyYW1lYnVmZmVyIHVuc3VwcG9ydGVkJ1xufTtcblxuZnVuY3Rpb24gX0NyZWF0ZUZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHRleHR1cmVVbml0KSB7XG4gICAgdmFyIGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB2YXIgZGVwdGhTdGVuY2lsQnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgdmFyIGNvbG9yQnVmZmVyID0gbnVsbDsgICBcbiAgICB2YXIgZmJTdGF0dXMgPSAwO1xuICAgIFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGRlcHRoU3RlbmNpbEJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcik7XG4gICAgY29sb3JCdWZmZXIgPSBfQ3JlYXRlRW1wdHlUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgY29sb3JCdWZmZXIsIDApOyAgICAgICAgXG4gICAgZmJTdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICBpZihmYlN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW5jb21wbGV0ZSBHTCBmcmFtZWJ1ZmZlci4gJywgX2ZiRXJyb3JzW2ZiU3RhdHVzXSk7XG4gICAgfVxuICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGg7XG4gICAgZnJhbWVidWZmZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGZyYW1lYnVmZmVyLnRhcmdldFRleHR1cmUgPSBjb2xvckJ1ZmZlcjtcbiAgICBmcmFtZWJ1ZmZlci5yZW5kZXJCdWZmZXIgPSBkZXB0aFN0ZW5jaWxCdWZmZXI7XG4gICAgcmV0dXJuIGZyYW1lYnVmZmVyO1xufVxuXG4vKipcbiogQGNsYXNzIEZpbHRlclRleHR1cmVcbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSBnbCB7V2ViR0xDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBob3Jpem9udGFsIHJhbmdlIG9mIHRoZSBmaWx0ZXJcbiogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNlZSB7eyNjcm9zc0xpbmsgXCJQSVhJL3NjYWxlTW9kZXM6cHJvcGVydHlcIn19UElYSS5zY2FsZU1vZGVze3svY3Jvc3NMaW5rfX0gZm9yIHBvc3NpYmxlIHZhbHVlc1xuKi9cblBJWEkuRmlsdGVyVGV4dHVyZSA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHRleHR1cmVVbml0KVxue1xuICAgIHRleHR1cmVVbml0ID0gdHlwZW9mIHRleHR1cmVVbml0ID09PSAnbnVtYmVyJyA/IHRleHR1cmVVbml0IDogMDtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZ2xcbiAgICAgKiBAdHlwZSBXZWJHTENvbnRleHRcbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgLy8gbmV4dCB0aW1lIHRvIGNyZWF0ZSBhIGZyYW1lIGJ1ZmZlciBhbmQgdGV4dHVyZVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyYW1lQnVmZmVyXG4gICAgICogQHR5cGUgQW55XG4gICAgICovXG4gICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBfQ3JlYXRlRnJhbWVidWZmZXIoZ2wsIHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSB8fCBQSVhJLnNjYWxlTW9kZXMuREVGQVVMVCwgdGV4dHVyZVVuaXQpO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlXG4gICAgICogQHR5cGUgQW55XG4gICAgICovXG4gICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuZnJhbWVCdWZmZXIudGFyZ2V0VGV4dHVyZTtcbiAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgdGhpcy5yZW5kZXJCdWZmZXIgPSB0aGlzLmZyYW1lQnVmZmVyLnJlbmRlckJ1ZmZlcjtcbn07XG5cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLkZpbHRlclRleHR1cmU7XG5cbi8qKlxuKiBDbGVhcnMgdGhlIGZpbHRlciB0ZXh0dXJlLlxuKiBcbiogQG1ldGhvZCBjbGVhclxuKi9cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBcbiAgICBnbC5jbGVhckNvbG9yKDAsMCwwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgdGV4dHVyZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAqXG4gKiBAbWV0aG9kIHJlc2l6ZVxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuUElYSS5GaWx0ZXJUZXh0dXJlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGlmKHRoaXMud2lkdGggPT09IHdpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBoZWlnaHQpIHJldHVybjtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgd2lkdGggLCBoZWlnaHQgLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAvLyB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXIpO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCB3aWR0aCAsIGhlaWdodCApO1xufTtcblxuLyoqXG4qIERlc3Ryb3lzIHRoZSBmaWx0ZXIgdGV4dHVyZS5cbiogXG4qIEBtZXRob2QgZGVzdHJveVxuKi9cblBJWEkuRmlsdGVyVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKCB0aGlzLmZyYW1lQnVmZmVyICk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSggdGhpcy50ZXh0dXJlICk7XG5cbiAgICB0aGlzLmZyYW1lQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2l6ZS5cbiAqXG4gKiBAY2xhc3MgQ2FudmFzQnVmZmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNCdWZmZXIgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgQ2FudmFzIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIENhbnZhcyBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ2FudmFzIG9iamVjdCB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBDYW52YXNCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2FudmFzXG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IFBoYXNlci5DYW52YXNQb29sLmNyZWF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cblBJWEkuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2FudmFzQnVmZmVyO1xuXG4vKipcbiAqIENsZWFycyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzcy5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNCdWZmZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIEZyZWVzIHRoZSBjYW52YXMgdXAgZm9yIHVzZSBhZ2Fpbi5cbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqL1xuUElYSS5DYW52YXNCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgUGhhc2VyLkNhbnZhc1Bvb2wucmVtb3ZlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIEEgc2V0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIGhhbmRsZSBtYXNraW5nLlxuICpcbiAqIEBjbGFzcyBDYW52YXNNYXNrTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBJWEkuQ2FudmFzTWFza01hbmFnZXIgPSBmdW5jdGlvbigpXG57XG59O1xuXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBJWEkuQ2FudmFzTWFza01hbmFnZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGFjayBvZiBtYXNrcy5cbiAqXG4gKiBAbWV0aG9kIHB1c2hNYXNrXG4gKiBAcGFyYW0gbWFza0RhdGEge09iamVjdH0gdGhlIG1hc2tEYXRhIHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAqIEBwYXJhbSByZW5kZXJTZXNzaW9uIHtPYmplY3R9IFRoZSByZW5kZXJTZXNzaW9uIHdob3NlIGNvbnRleHQgd2lsbCBiZSB1c2VkIGZvciB0aGlzIG1hc2sgbWFuYWdlci5cbiAqL1xuUElYSS5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbihtYXNrRGF0YSwgcmVuZGVyU2Vzc2lvbikge1xuXG5cdHZhciBjb250ZXh0ID0gcmVuZGVyU2Vzc2lvbi5jb250ZXh0O1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgXG4gICAgdmFyIGNhY2hlQWxwaGEgPSBtYXNrRGF0YS5hbHBoYTtcbiAgICB2YXIgdHJhbnNmb3JtID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgcmVzb2x1dGlvbiA9IHJlbmRlclNlc3Npb24ucmVzb2x1dGlvbjtcblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYiAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHggKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb24pO1xuXG4gICAgUElYSS5DYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljc01hc2sobWFza0RhdGEsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBtYXNrRGF0YS53b3JsZEFscGhhID0gY2FjaGVBbHBoYTtcbn07XG5cbi8qKlxuICogUmVzdG9yZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0IHRvIHRoZSBzdGF0ZSBpdCB3YXMgYmVmb3JlIHRoZSBtYXNrIHdhcyBhcHBsaWVkLlxuICpcbiAqIEBtZXRob2QgcG9wTWFza1xuICogQHBhcmFtIHJlbmRlclNlc3Npb24ge09iamVjdH0gVGhlIHJlbmRlclNlc3Npb24gd2hvc2UgY29udGV4dCB3aWxsIGJlIHVzZWQgZm9yIHRoaXMgbWFzayBtYW5hZ2VyLlxuICovXG5QSVhJLkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24ocmVuZGVyU2Vzc2lvbilcbntcbiAgICByZW5kZXJTZXNzaW9uLmNvbnRleHQucmVzdG9yZSgpO1xufTtcblxuLyoqXG4gKiBAYXV0aG9yIE1hdCBHcm92ZXMgaHR0cDovL21hdGdyb3Zlcy5jb20vIEBEb29ybWF0MjNcbiAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgU3ByaXRlL1RleHR1cmUgdGludGluZy5cbiAqXG4gKiBAY2xhc3MgQ2FudmFzVGludGVyXG4gKiBAc3RhdGljXG4gKi9cblBJWEkuQ2FudmFzVGludGVyID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBCYXNpY2FsbHkgdGhpcyBtZXRob2QganVzdCBuZWVkcyBhIHNwcml0ZSBhbmQgYSBjb2xvciBhbmQgdGludHMgdGhlIHNwcml0ZSB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAqIFxuICogQG1ldGhvZCBnZXRUaW50ZWRUZXh0dXJlIFxuICogQHN0YXRpY1xuICogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfSB0aGUgc3ByaXRlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7TnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHRpbnRlZCBjYW52YXNcbiAqL1xuUElYSS5DYW52YXNUaW50ZXIuZ2V0VGludGVkVGV4dHVyZSA9IGZ1bmN0aW9uKHNwcml0ZSwgY29sb3IpXG57XG4gICAgdmFyIGNhbnZhcyA9IHNwcml0ZS50aW50ZWRUZXh0dXJlIHx8IFBoYXNlci5DYW52YXNQb29sLmNyZWF0ZSh0aGlzKTtcbiAgICBcbiAgICBQSVhJLkNhbnZhc1RpbnRlci50aW50TWV0aG9kKHNwcml0ZS50ZXh0dXJlLCBjb2xvciwgY2FudmFzKTtcblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG4vKipcbiAqIFRpbnQgYSB0ZXh0dXJlIHVzaW5nIHRoZSBcIm11bHRpcGx5XCIgb3BlcmF0aW9uLlxuICogXG4gKiBAbWV0aG9kIHRpbnRXaXRoTXVsdGlwbHlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige051bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5QSVhJLkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5ID0gZnVuY3Rpb24odGV4dHVyZSwgY29sb3IsIGNhbnZhcylcbntcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICB2YXIgY3JvcCA9IHRleHR1cmUuY3JvcDtcbiAgICB2YXIgdyA9IGNyb3Aud2lkdGg7XG4gICAgdmFyIGggPSBjcm9wLmhlaWdodDtcblxuICAgIGlmICh0ZXh0dXJlLnJvdGF0ZWQpXG4gICAge1xuICAgICAgICB3ID0gaDtcbiAgICAgICAgaCA9IGNyb3Aud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gdyB8fCBjYW52YXMuaGVpZ2h0ICE9PSBoKVxuICAgIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI1wiICsgKFwiMDAwMDBcIiArIChjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcIm11bHRpcGx5XCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGNyb3AueCwgY3JvcC55LCB3LCBoLCAwLCAwLCB3LCBoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsIGNyb3AueCwgY3JvcC55LCB3LCBoLCAwLCAwLCB3LCBoKTtcblxufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSBwaXhlbCBwZXIgcGl4ZWwuXG4gKiBcbiAqIEBtZXRob2QgdGludFBlclBpeGVsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtOdW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqLyBcblBJWEkuQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWwgPSBmdW5jdGlvbih0ZXh0dXJlLCBjb2xvciwgY2FudmFzKVxue1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIHZhciBjcm9wID0gdGV4dHVyZS5jcm9wO1xuICAgIHZhciB3ID0gY3JvcC53aWR0aDtcbiAgICB2YXIgaCA9IGNyb3AuaGVpZ2h0O1xuXG4gICAgaWYgKHRleHR1cmUucm90YXRlZClcbiAgICB7XG4gICAgICAgIHcgPSBoO1xuICAgICAgICBoID0gY3JvcC53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB3IHx8IGNhbnZhcy5oZWlnaHQgIT09IGgpXG4gICAge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgICB9XG4gIFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSwgY3JvcC54LCBjcm9wLnksIHcsIGgsIDAsIDAsIHcsIGgpO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IFBoYXNlci5Db2xvci5oZXhUb1JHQkFycmF5KGNvbG9yKTtcbiAgICB2YXIgciA9IHJnYlZhbHVlc1swXSwgZyA9IHJnYlZhbHVlc1sxXSwgYiA9IHJnYlZhbHVlc1syXTtcblxuICAgIHZhciBwaXhlbERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcblxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgcGl4ZWxzW2kgKyAwXSAqPSByO1xuICAgICAgICBwaXhlbHNbaSArIDFdICo9IGc7XG4gICAgICAgIHBpeGVsc1tpICsgMl0gKj0gYjtcblxuICAgICAgICBpZiAoIVBJWEkuQ2FudmFzVGludGVyLmNhbkhhbmRsZUFscGhhKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXG4gICAgICAgICAgICBwaXhlbHNbaSArIDBdIC89IDI1NSAvIGFscGhhO1xuICAgICAgICAgICAgcGl4ZWxzW2kgKyAxXSAvPSAyNTUgLyBhbHBoYTtcbiAgICAgICAgICAgIHBpeGVsc1tpICsgMl0gLz0gMjU1IC8gYWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xufTtcblxuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBTdGFnZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgd2ViR0wuXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSBDYW52YXNSZW5kZXJlci52aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3MgQ2FudmFzUmVuZGVyZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdhbWUge1BoYXNlci5HYW1lfSBBIHJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIEdhbWUgaW5zdGFuY2VcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uIChnYW1lKSB7XG5cbiAgICAvKipcbiAgICAqIEBwcm9wZXJ0eSB7UGhhc2VyLkdhbWV9IGdhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgUGhhc2VyIEdhbWUgaW5zdGFuY2UuXG4gICAgKi9cbiAgICB0aGlzLmdhbWUgPSBnYW1lO1xuXG4gICAgaWYgKCFQSVhJLmRlZmF1bHRSZW5kZXJlcilcbiAgICB7XG4gICAgICAgIFBJWEkuZGVmYXVsdFJlbmRlcmVyID0gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gUGhhc2VyLkNBTlZBUztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVzb2x1dGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IGdhbWUucmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgc2V0cyBpZiB0aGUgQ2FudmFzUmVuZGVyZXIgd2lsbCBjbGVhciB0aGUgY2FudmFzIG9yIG5vdCBiZWZvcmUgdGhlIG5ldyByZW5kZXIgcGFzcy5cbiAgICAgKiBJZiB0aGUgU3RhZ2UgaXMgTk9UIHRyYW5zcGFyZW50IFBpeGkgd2lsbCB1c2UgYSBjYW52YXMgc2l6ZWQgZmlsbFJlY3Qgb3BlcmF0aW9uIGV2ZXJ5IGZyYW1lIHRvIHNldCB0aGUgY2FudmFzIGJhY2tncm91bmQgY29sb3IuXG4gICAgICogSWYgdGhlIFN0YWdlIGlzIHRyYW5zcGFyZW50IFBpeGkgd2lsbCB1c2UgY2xlYXJSZWN0IHRvIGNsZWFyIHRoZSBjYW52YXMgZXZlcnkgZnJhbWUuXG4gICAgICogRGlzYWJsZSB0aGlzIGJ5IHNldHRpbmcgdGhpcyB0byBmYWxzZS4gRm9yIGV4YW1wbGUgaWYgeW91ciBnYW1lIGhhcyBhIGNhbnZhcyBmaWxsaW5nIGJhY2tncm91bmQgaW1hZ2UgeW91IG9mdGVuIGRvbid0IG5lZWQgdGhpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2xlYXJCZWZvcmVSZW5kZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gZ2FtZS5jbGVhckJlZm9yZVJlbmRlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlbmRlciB2aWV3IGlzIHRyYW5zcGFyZW50XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHJhbnNwYXJlbnRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy50cmFuc3BhcmVudCA9IGdhbWUudHJhbnNwYXJlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBzaG91bGQgYmUgcmVzaXplZCBhdXRvbWF0aWNhbGx5XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXV0b1Jlc2l6ZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9SZXNpemUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDgwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSBnYW1lLndpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGdhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0by5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB2aWV3XG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSBnYW1lLmNhbnZhcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aFxuICAgICAqIEBwcm9wZXJ0eSBjb250ZXh0XG4gICAgICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy52aWV3LmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiB0aGlzLnRyYW5zcGFyZW50IH0gKTtcblxuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gZmxhZyBjb250cm9sbGluZyBjYW52YXMgcmVmcmVzaC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZWZyZXNoXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY291bnRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIGEgUElYSS5DYW52YXNNYXNrTWFuYWdlciwgaGFuZGxlcyBtYXNraW5nIHdoZW4gdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlclxuICAgICAqIEBwcm9wZXJ0eSBDYW52YXNNYXNrTWFuYWdlclxuICAgICAqIEB0eXBlIENhbnZhc01hc2tNYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBQSVhJLkNhbnZhc01hc2tNYW5hZ2VyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyIHNlc3Npb24gaXMganVzdCBhIGJ1bmNoIG9mIHBhcmFtZXRlciB1c2VkIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyU2Vzc2lvblxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IHtcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBtYXNrTWFuYWdlcjogdGhpcy5tYXNrTWFuYWdlcixcbiAgICAgICAgc2NhbGVNb2RlOiBudWxsLFxuICAgICAgICBzbW9vdGhQcm9wZXJ0eTogUGhhc2VyLkNhbnZhcy5nZXRTbW9vdGhpbmdQcmVmaXgodGhpcy5jb250ZXh0KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSBQaXhpIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcm91bmRQaXhlbHM6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMubWFwQmxlbmRNb2RlcygpO1xuICAgIFxuICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxufTtcblxuLy8gY29uc3RydWN0b3JcblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5DYW52YXNSZW5kZXJlcjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBEaXNwbGF5T2JqZWN0Q29udGFpbmVyLCB1c3VhbGx5IHRoZSBQaGFzZXIuU3RhZ2UsIHRvIHRoaXMgY2FudmFzIHZpZXcuXG4gKlxuICogQG1ldGhvZCByZW5kZXJcbiAqIEBwYXJhbSByb290IHtQaGFzZXIuU3RhZ2V8UElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyfSBUaGUgcm9vdCBlbGVtZW50IHRvIGJlIHJlbmRlcmVkLlxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICB0aGlzLnJlbmRlclNlc3Npb24uY3VycmVudEJsZW5kTW9kZSA9IDA7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWtlWCA9IHRoaXMuZ2FtZS5jYW1lcmEuX3NoYWtlLng7XG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLnNoYWtlWSA9IHRoaXMuZ2FtZS5jYW1lcmEuX3NoYWtlLnk7XG5cbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgIGlmIChuYXZpZ2F0b3IuaXNDb2Nvb25KUyAmJiB0aGlzLnZpZXcuc2NyZWVuY2FudmFzKVxuICAgIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyKCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNsZWFyQmVmb3JlUmVuZGVyKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvb3QuX2JnQ29sb3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSByb290Ll9iZ0NvbG9yLnJnYmE7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCAsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qocm9vdCk7XG5cbn07XG5cblBJWEkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHR1cmVQcmlvcml0eSA9IGZ1bmN0aW9uICh0ZXh0dXJlTmFtZUNvbGxlY3Rpb24pIHtcblxuICAgIC8vICBEb2VzIG5vdGhpbmcgb24gQ2FudmFzLCBidXQgaGVyZSB0byBhbGxvdyB5b3UgdG8gc2ltcGx5IHNldFxuICAgIC8vICBgZ2FtZS5yZW5kZXJlci5zZXRUZXh0dXJlUHJpb3JpdHkoKWAgd2l0aG91dCBoYXZpbmcgdG8gd29ycnkgYWJvdXRcbiAgICAvLyAgcnVubmluZyBpbiBXZWJHTCBvciBub3QuXG5cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSBbcmVtb3ZlVmlldz10cnVlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZVZpZXcpIHtcblxuICAgIGlmIChyZW1vdmVWaWV3ID09PSB1bmRlZmluZWQpIHsgcmVtb3ZlVmlldyA9IHRydWU7IH1cblxuICAgIGlmIChyZW1vdmVWaWV3ICYmIHRoaXMudmlldy5wYXJlbnQpXG4gICAge1xuICAgICAgICB0aGlzLnZpZXcucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmlldyk7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyU2Vzc2lvbiA9IG51bGw7XG5cbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQG1ldGhvZCByZXNpemVcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqL1xuUElYSS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcblxuICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggLyB0aGlzLnJlc29sdXRpb24gKyBcInB4XCI7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbiArIFwicHhcIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJTZXNzaW9uLnNtb290aFByb3BlcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W3RoaXMucmVuZGVyU2Vzc2lvbi5zbW9vdGhQcm9wZXJ0eV0gPSAodGhpcy5yZW5kZXJTZXNzaW9uLnNjYWxlTW9kZSA9PT0gUElYSS5zY2FsZU1vZGVzLkxJTkVBUik7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBkaXNwbGF5IG9iamVjdFxuICpcbiAqIEBtZXRob2QgcmVuZGVyRGlzcGxheU9iamVjdFxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIGNvbnRleHQgMmQgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqIEBwYXJhbSBbbWF0cml4XSB7TWF0cml4fSBPcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IGJlZm9yZSByZW5kZXJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gKGRpc3BsYXlPYmplY3QsIGNvbnRleHQsIG1hdHJpeCkge1xuXG4gICAgdGhpcy5yZW5kZXJTZXNzaW9uLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnJlbmRlclNlc3Npb24ucmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcbiAgICBkaXNwbGF5T2JqZWN0Ll9yZW5kZXJDYW52YXModGhpcy5yZW5kZXJTZXNzaW9uLCBtYXRyaXgpO1xuXG59O1xuXG4vKipcbiAqIE1hcHMgUGl4aSBibGVuZCBtb2RlcyB0byBjYW52YXMgYmxlbmQgbW9kZXMuXG4gKlxuICogQG1ldGhvZCBtYXBCbGVuZE1vZGVzXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5tYXBCbGVuZE1vZGVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCFQSVhJLmJsZW5kTW9kZXNDYW52YXMpXG4gICAge1xuICAgICAgICB2YXIgYiA9IFtdO1xuICAgICAgICB2YXIgbW9kZXMgPSBQSVhJLmJsZW5kTW9kZXM7XG4gICAgICAgIHZhciB1c2VOZXcgPSB0aGlzLmdhbWUuZGV2aWNlLmNhblVzZU11bHRpcGx5O1xuXG4gICAgICAgIGJbbW9kZXMuTk9STUFMXSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGJbbW9kZXMuQUREXSA9ICdsaWdodGVyJztcbiAgICAgICAgYlttb2Rlcy5NVUxUSVBMWV0gPSAodXNlTmV3KSA/ICdtdWx0aXBseScgOiAnc291cmNlLW92ZXInO1xuICAgICAgICBiW21vZGVzLlNDUkVFTl0gPSAodXNlTmV3KSA/ICdzY3JlZW4nIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5PVkVSTEFZXSA9ICh1c2VOZXcpID8gJ292ZXJsYXknIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5EQVJLRU5dID0gKHVzZU5ldykgPyAnZGFya2VuJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGJbbW9kZXMuTElHSFRFTl0gPSAodXNlTmV3KSA/ICdsaWdodGVuJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGJbbW9kZXMuQ09MT1JfRE9ER0VdID0gKHVzZU5ldykgPyAnY29sb3ItZG9kZ2UnIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5DT0xPUl9CVVJOXSA9ICh1c2VOZXcpID8gJ2NvbG9yLWJ1cm4nIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5IQVJEX0xJR0hUXSA9ICh1c2VOZXcpID8gJ2hhcmQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5TT0ZUX0xJR0hUXSA9ICh1c2VOZXcpID8gJ3NvZnQtbGlnaHQnIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5ESUZGRVJFTkNFXSA9ICh1c2VOZXcpID8gJ2RpZmZlcmVuY2UnIDogJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgYlttb2Rlcy5FWENMVVNJT05dID0gKHVzZU5ldykgPyAnZXhjbHVzaW9uJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGJbbW9kZXMuSFVFXSA9ICh1c2VOZXcpID8gJ2h1ZScgOiAnc291cmNlLW92ZXInO1xuICAgICAgICBiW21vZGVzLlNBVFVSQVRJT05dID0gKHVzZU5ldykgPyAnc2F0dXJhdGlvbicgOiAnc291cmNlLW92ZXInO1xuICAgICAgICBiW21vZGVzLkNPTE9SXSA9ICh1c2VOZXcpID8gJ2NvbG9yJyA6ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIGJbbW9kZXMuTFVNSU5PU0lUWV0gPSAodXNlTmV3KSA/ICdsdW1pbm9zaXR5JyA6ICdzb3VyY2Utb3Zlcic7XG5cbiAgICAgICAgUElYSS5ibGVuZE1vZGVzQ2FudmFzID0gYjtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2UuIEFsbCB0ZXh0dXJlcyBoYXZlIGEgYmFzZSB0ZXh0dXJlLlxuICpcbiAqIEBjbGFzcyBCYXNlVGV4dHVyZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc291cmNlIHtTdHJpbmd8Q2FudmFzfSB0aGUgc291cmNlIG9iamVjdCAoaW1hZ2Ugb3IgY2FudmFzKVxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTZWUge3sjY3Jvc3NMaW5rIFwiUElYSS9zY2FsZU1vZGVzOnByb3BlcnR5XCJ9fVBJWEkuc2NhbGVNb2Rlc3t7L2Nyb3NzTGlua319IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEBwYXJhbSBbcmVzb2x1dGlvbl0ge051bWJlcn0gdGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgKGZvciBIaURQSSBkaXNwbGF5cylcbiAqL1xuUElYSS5CYXNlVGV4dHVyZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBSZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlLiBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZXNvbHV0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCAxO1xuICAgIFxuICAgIC8qKlxuICAgICAqIFtyZWFkLW9ubHldIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gVGhlIGhlaWdodCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IHNjYWxlTW9kZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5zY2FsZU1vZGVzLkxJTkVBUlxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IFBJWEkuc2NhbGVNb2Rlcy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogW3JlYWQtb25seV0gU2V0IHRvIHRydWUgb25jZSB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBoYXNMb2FkZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzb3VyY2VcbiAgICAgKiBAdHlwZSBJbWFnZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgaWYgUkdCIGNoYW5uZWxzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCBieSBBbHBoYSAgKFdlYkdMIG9ubHkpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcHJlbXVsdGlwbGllZEFscGhhXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHRydWU7XG5cbiAgICAvLyB1c2VkIGZvciB3ZWJHTFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IF9nbFRleHR1cmVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsVGV4dHVyZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgYSBtaXBtYXAgb2YgdGhpcyB0ZXh0dXJlIG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHRoZSB0ZXh0dXJlIGlzIHVzZWRcbiAgICAgKiBBbHNvIHRoZSB0ZXh0dXJlIG11c3QgYmUgYSBwb3dlciBvZiB0d28gc2l6ZSB0byB3b3JrXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IG1pcG1hcFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG5cbiAgICAgLyoqXG4gICAgICogVGhlIG11bHRpIHRleHR1cmUgYmF0Y2hpbmcgaW5kZXggbnVtYmVyLlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlSW5kZXhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmVJbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgX2RpcnR5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RpcnR5ID0gW3RydWUsIHRydWUsIHRydWUsIHRydWVdO1xuXG4gICAgaWYgKCFzb3VyY2UpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLnNvdXJjZS5jb21wbGV0ZSB8fCB0aGlzLnNvdXJjZS5nZXRDb250ZXh0KSAmJiB0aGlzLnNvdXJjZS53aWR0aCAmJiB0aGlzLnNvdXJjZS5oZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnNvdXJjZS5uYXR1cmFsV2lkdGggfHwgdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5zb3VyY2UubmF0dXJhbEhlaWdodCB8fCB0aGlzLnNvdXJjZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZGlydHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIEJhc2VUZXh0dXJlIGNhbiBiZSBzZXQgdG8gc2tpcCB0aGUgcmVuZGVyaW5nIHBoYXNlIGluIHRoZSBXZWJHTCBTcHJpdGUgQmF0Y2guXG4gICAgICogXG4gICAgICogWW91IG1heSB3YW50IHRvIGRvIHRoaXMgaWYgeW91IGhhdmUgYSBwYXJlbnQgU3ByaXRlIHdpdGggbm8gdmlzaWJsZSB0ZXh0dXJlIChpLmUuIHVzZXMgdGhlIGludGVybmFsIGBfX2RlZmF1bHRgIHRleHR1cmUpXG4gICAgICogdGhhdCBoYXMgY2hpbGRyZW4gdGhhdCB5b3UgZG8gd2FudCB0byByZW5kZXIsIHdpdGhvdXQgY2F1c2luZyBhIGJhdGNoIGZsdXNoIGluIHRoZSBwcm9jZXNzLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBza2lwUmVuZGVyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuc2tpcFJlbmRlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IF9wb3dlck9mMlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Bvd2VyT2YyID0gZmFsc2U7XG5cbn07XG5cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUElYSS5CYXNlVGV4dHVyZTtcblxuLyoqXG4gKiBGb3JjZXMgdGhpcyBCYXNlVGV4dHVyZSB0byBiZSBzZXQgYXMgbG9hZGVkLCB3aXRoIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0LlxuICogVGhlbiBjYWxscyBCYXNlVGV4dHVyZS5kaXJ0eS5cbiAqIEltcG9ydGFudCBmb3Igd2hlbiB5b3UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlIHNvdXJjZSBvYmplY3QgYnkgZm9yY2luZyBpbiBgY29tcGxldGVgIG9yIGRpbWVuc2lvbiBwcm9wZXJ0aWVzIGl0IG1heSBub3QgaGF2ZS5cbiAqXG4gKiBAbWV0aG9kIGZvcmNlTG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIHRvIGZvcmNlIHRoZSBCYXNlVGV4dHVyZSB0byBiZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCB0byBmb3JjZSB0aGUgQmFzZVRleHR1cmUgdG8gYmUuXG4gKi9cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmZvcmNlTG9hZGVkID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHkoKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmVcbiAqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5zb3VyY2UpXG4gICAge1xuICAgICAgICBQaGFzZXIuQ2FudmFzUG9vbC5yZW1vdmVCeUNhbnZhcyh0aGlzLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy51bmxvYWRGcm9tR1BVKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHNvdXJjZSBpbWFnZSBvZiB0aGUgdGV4dHVyZVxuICpcbiAqIEBtZXRob2QgdXBkYXRlU291cmNlSW1hZ2VcbiAqIEBwYXJhbSBuZXdTcmMge1N0cmluZ30gdGhlIHBhdGggb2YgdGhlIGltYWdlXG4gKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFBoYXNlci5TcHJpdGUubG9hZFRleHR1cmUgaW5zdGVhZC5cbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlU291cmNlSW1hZ2UgPSBmdW5jdGlvbihuZXdTcmMpXG57XG4gICAgY29uc29sZS53YXJuKFwiUElYSS5CYXNlVGV4dHVyZS51cGRhdGVTb3VyY2VJbWFnZSBpcyBkZXByZWNhdGVkLiBVc2UgUGhhc2VyLlNwcml0ZS5sb2FkVGV4dHVyZSBpbnN0ZWFkLlwiKTtcbn07XG5cbi8qKlxuICogU2V0cyBhbGwgZ2xUZXh0dXJlcyB0byBiZSBkaXJ0eS5cbiAqXG4gKiBAbWV0aG9kIGRpcnR5XG4gKi9cblBJWEkuQmFzZVRleHR1cmUucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24oKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2xUZXh0dXJlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2RpcnR5W2ldID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBHUFUsIHVzZWZ1bCBmb3IgbWFuYWdpbmcgcmVzb3VyY2VzIG9uIHRoZSBHUFUuXG4gKiBBdGV4dHVyZSBpcyBzdGlsbCAxMDAlIHVzYWJsZSBhbmQgd2lsbCBzaW1wbHkgYmUgcmV1cGxvYWRlZCBpZiB0aGVyZSBpcyBhIHNwcml0ZSBvbiBzY3JlZW4gdGhhdCBpcyB1c2luZyBpdC5cbiAqXG4gKiBAbWV0aG9kIHVubG9hZEZyb21HUFVcbiAqL1xuUElYSS5CYXNlVGV4dHVyZS5wcm90b3R5cGUudW5sb2FkRnJvbUdQVSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmRpcnR5KCk7XG5cbiAgICAvLyBkZWxldGUgdGhlIHdlYkdMIHRleHR1cmVzIGlmIGFueS5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZ2xUZXh0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0aGlzLl9nbFRleHR1cmVzW2ldO1xuICAgICAgICB2YXIgZ2wgPSBQSVhJLmdsQ29udGV4dHNbaV07XG5cbiAgICAgICAgaWYoZ2wgJiYgZ2xUZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGdsVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgdGhpcy5fZ2xUZXh0dXJlcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5kaXJ0eSgpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyBlbGVtZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbUNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNlZSB7eyNjcm9zc0xpbmsgXCJQSVhJL3NjYWxlTW9kZXM6cHJvcGVydHlcIn19UElYSS5zY2FsZU1vZGVze3svY3Jvc3NMaW5rfX0gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHBhcmFtIFtyZXNvbHV0aW9uXSB7TnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZSAoZm9yIEhpRFBJIGRpc3BsYXlzKVxuICogQHJldHVybiB7QmFzZVRleHR1cmV9XG4gKi9cblBJWEkuQmFzZVRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGVNb2RlLCByZXNvbHV0aW9uKVxue1xuICAgIGlmIChjYW52YXMud2lkdGggPT09IDApXG4gICAge1xuICAgICAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIH1cblxuICAgIGlmIChjYW52YXMuaGVpZ2h0ID09PSAwKVxuICAgIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgMTtcblxuICAgIHJldHVybiBuZXcgUElYSS5CYXNlVGV4dHVyZShjYW52YXMsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbi8qKlxuICogVGV4dHVyZVNpbGVudEZhaWwgaXMgYSBib29sZWFuIHRoYXQgZGVmYXVsdHMgdG8gYGZhbHNlYC4gXG4gKiBJZiBgdHJ1ZWAgdGhlbiBgUElYSS5UZXh0dXJlLnNldEZyYW1lYCB3aWxsIG5vIGxvbmdlciB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdGV4dHVyZSBkaW1lbnNpb25zIGFyZSBpbmNvcnJlY3QuIFxuICogSW5zdGVhZCBgVGV4dHVyZS52YWxpZGAgd2lsbCBiZSBzZXQgdG8gYGZhbHNlYCAoIzE1NTYpXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblBJWEkuVGV4dHVyZVNpbGVudEZhaWwgPSBmYWxzZTtcblxuLyoqXG4gKiBBIHRleHR1cmUgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IHJlcHJlc2VudHMgYW4gaW1hZ2Ugb3IgcGFydCBvZiBhbiBpbWFnZS4gSXQgY2Fubm90IGJlIGFkZGVkXG4gKiB0byB0aGUgZGlzcGxheSBsaXN0IGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBpdCBhcyB0aGUgdGV4dHVyZSBmb3IgYSBQSVhJLlNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWQgdGhlbiB0aGUgd2hvbGUgaW1hZ2UgaXMgdXNlZC5cbiAqXG4gKiBAY2xhc3MgVGV4dHVyZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmFzZVRleHR1cmUge0Jhc2VUZXh0dXJlfSBUaGUgYmFzZSB0ZXh0dXJlIHNvdXJjZSB0byBjcmVhdGUgdGhlIHRleHR1cmUgZnJvbVxuICogQHBhcmFtIGZyYW1lIHtSZWN0YW5nbGV9IFRoZSByZWN0YW5nbGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2hvd1xuICogQHBhcmFtIFtjcm9wXSB7UmVjdGFuZ2xlfSBUaGUgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlIFxuICogQHBhcmFtIFt0cmltXSB7UmVjdGFuZ2xlfSBUcmltbWVkIHRleHR1cmUgcmVjdGFuZ2xlXG4gKi9cblBJWEkuVGV4dHVyZSA9IGZ1bmN0aW9uKGJhc2VUZXh0dXJlLCBmcmFtZSwgY3JvcCwgdHJpbSlcbntcbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5vRnJhbWVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG5cbiAgICBpZiAoIWZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwwLDEsMSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgUElYSS5UZXh0dXJlKVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYmFzZVRleHR1cmVcbiAgICAgKiBAdHlwZSBCYXNlVGV4dHVyZVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXNcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmFtZVxuICAgICAqIEB0eXBlIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRyaW0gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0cmltXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy50cmltID0gdHJpbTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZhbGlkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgYSB0aWxpbmcgdGV4dHVyZT8gQXMgdXNlZCBieSB0aGUgbGlrZXMgb2YgYSBUaWxpbmdTcHJpdGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNUaWxpbmdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5pc1RpbGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZCAodXNlZCBtYWlubHkgZm9yIHdlYkdMIHV2IHVwZGF0ZXMpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVxdWlyZXNVcGRhdGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRpbnRlZCBwYXJlbnQgaGFzIHVwZGF0ZWQgaXRzIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVxdWlyZXNSZVRpbnRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlc1JlVGludCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIFVWIGRhdGEgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgX3V2c1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdXZzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxuICAgICAqIGlycmVzcGVjdGl2ZSBvZiB0aGUgYWN0dWFsIGZyYW1lIHNpemUgb3IgcGxhY2VtZW50ICh3aGljaCBjYW4gYmUgaW5mbHVlbmNlZCBieSB0cmltbWVkIHRleHR1cmUgYXRsYXNlcylcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjcm9wXG4gICAgICogQHR5cGUgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5jcm9wID0gY3JvcCB8fCBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBjb250cm9scyBpZiB0aGlzIGZyYW1lIGlzIHJvdGF0ZWQgb3Igbm90LlxuICAgICAqIFJvdGF0aW9uIGFsbG93cyB5b3UgdG8gdXNlIHJvdGF0ZWQgZnJhbWVzIGluIHRleHR1cmUgYXRsYXMgcGFja2luZywgaXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aFxuICAgICAqIFNwcml0ZSByb3RhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByb3RhdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMucm90YXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIGZyYW1lID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNldEZyYW1lKGZyYW1lKTtcbiAgICB9XG5cbn07XG5cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQSVhJLlRleHR1cmU7XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyBsb2FkZWRcbiAqXG4gKiBAbWV0aG9kIG9uQmFzZVRleHR1cmVMb2FkZWRcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUub25CYXNlVGV4dHVyZUxvYWRlZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYmFzZVRleHR1cmUgPSB0aGlzLmJhc2VUZXh0dXJlO1xuXG4gICAgaWYgKHRoaXMubm9GcmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgUElYSS5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRGcmFtZSh0aGlzLmZyYW1lKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0gZGVzdHJveUJhc2Uge0Jvb2xlYW59IFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAqL1xuUElYSS5UZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZGVzdHJveUJhc2UpXG57XG4gICAgaWYgKGRlc3Ryb3lCYXNlKSB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcblxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSByZWdpb24gb2YgdGhlIGJhc2VUZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHdpbGwgdXNlLlxuICpcbiAqIEBtZXRob2Qgc2V0RnJhbWVcbiAqIEBwYXJhbSBmcmFtZSB7UmVjdGFuZ2xlfSBUaGUgZnJhbWUgb2YgdGhlIHRleHR1cmUgdG8gc2V0IGl0IHRvXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuc2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZSlcbntcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG5cbiAgICB0aGlzLmNyb3AueCA9IGZyYW1lLng7XG4gICAgdGhpcy5jcm9wLnkgPSBmcmFtZS55O1xuICAgIHRoaXMuY3JvcC53aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgIHRoaXMuY3JvcC5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXRoaXMudHJpbSAmJiAoZnJhbWUueCArIGZyYW1lLndpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS55ICsgZnJhbWUuaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpKVxuICAgIHtcbiAgICAgICAgaWYgKCFQSVhJLlRleHR1cmVTaWxlbnRGYWlsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgRXJyb3I6IGZyYW1lIGRvZXMgbm90IGZpdCBpbnNpZGUgdGhlIGJhc2UgVGV4dHVyZSBkaW1lbnNpb25zICcgKyB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG5cbiAgICBpZiAodGhpcy50cmltKVxuICAgIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudHJpbS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRyaW0uaGVpZ2h0O1xuICAgICAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy50cmltLndpZHRoO1xuICAgICAgICB0aGlzLmZyYW1lLmhlaWdodCA9IHRoaXMudHJpbS5oZWlnaHQ7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLnZhbGlkKSB0aGlzLl91cGRhdGVVdnMoKTtcblxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAqXG4gKiBAbWV0aG9kIF91cGRhdGVVdnNcbiAqIEBwcml2YXRlXG4gKi9cblBJWEkuVGV4dHVyZS5wcm90b3R5cGUuX3VwZGF0ZVV2cyA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5fdXZzKXRoaXMuX3V2cyA9IG5ldyBQSVhJLlRleHR1cmVVdnMoKTtcblxuICAgIHZhciBmcmFtZSA9IHRoaXMuY3JvcDtcbiAgICB2YXIgdHcgPSB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xuICAgIHZhciB0aCA9IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIFxuICAgIHRoaXMuX3V2cy54MCA9IGZyYW1lLnggLyB0dztcbiAgICB0aGlzLl91dnMueTAgPSBmcmFtZS55IC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDEgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xuICAgIHRoaXMuX3V2cy55MSA9IGZyYW1lLnkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgdGhpcy5fdXZzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgdGhpcy5fdXZzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZVV2c0ludmVydGVkXG4gKiBAcHJpdmF0ZVxuICovXG5QSVhJLlRleHR1cmUucHJvdG90eXBlLl91cGRhdGVVdnNJbnZlcnRlZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5fdXZzKSB7IHRoaXMuX3V2cyA9IG5ldyBQSVhJLlRleHR1cmVVdnMoKTsgfVxuXG4gICAgdmFyIGZyYW1lID0gdGhpcy5jcm9wO1xuICAgIHZhciB0dyA9IHRoaXMuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgdmFyIHRoID0gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQ7XG4gICAgXG4gICAgdGhpcy5fdXZzLngwID0gZnJhbWUueCAvIHR3O1xuICAgIHRoaXMuX3V2cy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MSA9IChmcmFtZS54ICsgZnJhbWUuaGVpZ2h0KSAvIHR3O1xuICAgIHRoaXMuX3V2cy55MSA9IGZyYW1lLnkgLyB0aDtcblxuICAgIHRoaXMuX3V2cy54MiA9IChmcmFtZS54ICsgZnJhbWUuaGVpZ2h0KSAvIHR3O1xuICAgIHRoaXMuX3V2cy55MiA9IChmcmFtZS55ICsgZnJhbWUud2lkdGgpIC8gdGg7XG5cbiAgICB0aGlzLl91dnMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgdGhpcy5fdXZzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS53aWR0aCkgLyB0aDtcblxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGEgVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tQ2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge051bWJlcn0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1QSVhJLnNjYWxlTW9kZXN7ey9jcm9zc0xpbmt9fSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5QSVhJLlRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGVNb2RlKVxue1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IFBJWEkuQmFzZVRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXMsIHNjYWxlTW9kZSk7XG5cbiAgICByZXR1cm4gbmV3IFBJWEkuVGV4dHVyZShiYXNlVGV4dHVyZSk7XG59O1xuXG5QSVhJLlRleHR1cmVVdnMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy54MCA9IDA7XG4gICAgdGhpcy55MCA9IDA7XG5cbiAgICB0aGlzLngxID0gMDtcbiAgICB0aGlzLnkxID0gMDtcblxuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuXG4gICAgdGhpcy54MyA9IDA7XG4gICAgdGhpcy55MyA9IDA7XG59O1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3ZlcyBodHRwOi8vbWF0Z3JvdmVzLmNvbS8gQERvb3JtYXQyM1xuICovXG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUElYSTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlBJWEkgPSBQSVhJO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ1BJWEknLCAoZnVuY3Rpb24oKSB7IHJldHVybiByb290LlBJWEkgPSBQSVhJOyB9KSgpICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QSVhJID0gUElYSTtcbiAgICB9XG5cbiAgICByZXR1cm4gUElYSTtcbn0pLmNhbGwodGhpcyk7Il19
